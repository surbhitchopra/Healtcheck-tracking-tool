



{% extends 'base.html' %}

{% block title %}Customer Dashboard - Health Check Overview{% endblock %}

{% block extra_head %}
<!-- XLSX Library for Excel Export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
    body {
        background: #f8fafc;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        color: #1e293b;
        line-height: 1.6;
    }
    
    .dashboard-container {
        min-height: 100vh;
        padding: 2px;
        max-width: 1400px;
        margin: 0 auto;
        background: transparent;
    }
    
    /* HEADER - COMPACT */
    .dashboard-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 4px;
        padding: 2px 6px;
        margin-bottom: 1px;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.06), 0 2px 6px rgba(0, 0, 0, 0.03);
        border: 1px solid rgba(59, 130, 246, 0.2);
        position: relative;
        backdrop-filter: blur(20px);
    }
    
    .dashboard-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        border-radius: 12px 12px 0 0;
        opacity: 0.9;
    }
    
    @keyframes shimmer {
        0% { background-position: -200% 0; }
        100% { background-position: 200% 0; }
    }
    
    .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 4px;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .header-title h1 {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        line-height: 1.1;
        letter-spacing: -0.025em;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .header-subtitle {
        color: #64748b;
        font-size: 0.7rem;
        margin-top: 2px;
        font-weight: 400;
    }
    
    /* Customer count display */
    .customer-count-display {
        display: inline-flex;
        align-items: center;
        background: rgba(99, 102, 241, 0.1);
        color: #4338ca;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 700;
        border: 1px solid rgba(99, 102, 241, 0.2);
    }
    
    
    .header-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }
    
    .refresh-btn, .export-btn, .back-btn {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.65rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        text-decoration: none;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(8px);
        text-transform: uppercase;
        letter-spacing: 0.02em;
        min-height: 24px;
        white-space: nowrap;
    }
    
    .refresh-btn {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(59, 130, 246, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .refresh-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(37, 99, 235, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .export-btn {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(16, 185, 129, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .export-btn:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4), 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    
    .refresh-btn:active, .export-btn:active, .back-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .refresh-btn:active {
        box-shadow: 0 1px 3px rgba(59, 130, 246, 0.4);
    }
    
    .export-btn:active {
        box-shadow: 0 1px 3px rgba(16, 185, 129, 0.4);
    }
    
    .back-btn:active {
        box-shadow: 0 1px 3px rgba(107, 114, 128, 0.4);
    }
    
    .back-btn {
        background: rgba(248, 250, 252, 0.9);
        color: #475569;
        box-shadow: 0 2px 8px rgba(107, 114, 128, 0.15), 0 1px 3px rgba(0, 0, 0, 0.06);
        border: 1px solid #e2e8f0;
    }
    
    .back-btn:hover {
        background: rgba(241, 245, 249, 0.95);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(107, 114, 128, 0.2), 0 2px 6px rgba(0, 0, 0, 0.08);
        text-decoration: none;
        color: #334155;
    }
    
    /* HEADER STATS CARDS - COMPACT */
    .header-stats-grid {
        display: flex;
        gap: 3px;
        align-items: center;
        margin-right: 4px;
    }
    
    .header-stat-card {
        display: flex;
        align-items: center;
        gap: 2px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid rgba(59, 130, 246, 0.15);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.04), 0 1px 4px rgba(0, 0, 0, 0.02);
        min-width: 60px;
        min-height: 20px;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
    }
    
    .header-stat-icon {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        flex-shrink: 0;
    }
    
    .header-stat-info {
        display: flex;
        flex-direction: column;
        gap: 0;
    }
    
    .header-stat-title {
        font-size: 0.55rem;
        color: #6b7280;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        line-height: 1;
    }
    
    .header-stat-value {
        font-size: 0.75rem;
        font-weight: 700;
        color: #1f2937;
        line-height: 1;
    }
    
    .header-stat-card:hover {
        transform: translateY(-2px);
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08), 0 4px 12px rgba(0, 0, 0, 0.06);
        border-color: rgba(59, 130, 246, 0.25);
    }
    
    .header-buttons {
        display: flex;
        gap: 4px;
        align-items: center;
    }

    /* DATE FILTER SECTION */
    .filter-section {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 1px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .filter-content {
        display: flex;
        align-items: end;
        gap: 1px;
        flex: 1;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .filter-label {
        font-size: 0.9rem;
        font-weight: 600;
        color: #374151;
    }

    .filter-input {
        padding: 8px 12px;
        border: 2px solid #e5e7eb;
        border-radius: 6px;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        min-width: 130px;
    }

    .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }

    .filter-btn {
        padding: 8px 16px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.55rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        align-self: end;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        min-width: 80px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
    }

    .filter-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4), 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .filter-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(59, 130, 246, 0.3);
    }
    
    /* STATS FLEXBOX - More Responsive */
    .stats-grid {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        gap: 6px;
        margin-bottom: 2px;
        width: 100%;
        flex-wrap: wrap;
    }
    
    .stat-card {
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(20px);
        border-radius: 12px;
        padding: 20px 16px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        flex: 1;
        min-width: 200px;
        max-width: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 25px;
    }
    
    .stat-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.18), 0 4px 16px rgba(0, 0, 0, 0.08);
    }
    
    .stat-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
    }
    
    .stat-card:hover::before {
        left: 100%;
    }
    
    .stat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    
    .stat-icon {
        width: 14px;
        height: 14px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
    }
    
    .stat-title {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 600;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .stat-value {
        font-size: 2rem;
        font-weight: 800;
        color: #1f2937;
        margin: 8px 0;
        line-height: 1;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        position: relative;
        z-index: 1;
    }
    
    .stat-change {
        font-size: 0.8rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 4px;
    }
    
    .stat-change.positive {
        color: #10b981;
    }
    
    .stat-change.neutral {
        color: #6b7280;
    }
    
    /* Circular Progress Indicators */
    .stat-visual {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 16px 0;
        position: relative;
    }
    
    .circular-progress {
        position: relative;
        width: 12px;
        height: 12px;
    }
    
    .circular-progress svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }
    
    .progress-bg {
        fill: none;
        stroke: rgba(0, 0, 0, 0.1);
        stroke-width: 1.5;
    }
    
    .progress-fill {
        fill: none;
        stroke-width: 1.5;
        stroke-linecap: round;
        transition: stroke-dasharray 1.5s ease-in-out;
    }
    
    .progress-customers {
        stroke: url(#gradient-customers);
    }
    
    .progress-runs {
        stroke: url(#gradient-runs);
    }
    
    .progress-trackers {
        stroke: url(#gradient-trackers);
    }
    
    .progress-value {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.95rem;
        font-weight: 700;
        color: #1f2937;
    }
    
    /* Animated dots decoration */
    .stat-decoration {
        position: absolute;
        top: 0;
        right: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
    }
    
    .floating-dots {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        opacity: 0.3;
        animation: floatDots 3s ease-in-out infinite;
    }
    
    .dot-1 {
        top: 20%;
        right: 15%;
        background: #cbd5e1;
        animation-delay: 0s;
    }
    
    .dot-2 {
        top: 60%;
        right: 25%;
        background: #10b981;
        animation-delay: 0.5s;
    }
    
    .dot-3 {
        top: 40%;
        right: 8%;
        background: #f59e0b;
        animation-delay: 1s;
    }
    
    @keyframes floatDots {
        0%, 100% {
            transform: translateY(0px) scale(1);
            opacity: 0.3;
        }
        50% {
            transform: translateY(-8px) scale(1.2);
            opacity: 0.6;
        }
    }
    
    /* Professional stat card layout */
    .stat-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .stat-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .stat-info {
        flex: 1;
    }
    
    /* PROFESSIONAL TRACKING GRAPH */
    .tracking-graph-container {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
        backdrop-filter: blur(24px);
        border-radius: 6px;
        padding: 4px;
        margin-bottom: 1px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.4);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    .tracking-graph-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #e2e8f0 0%, #cbd5e1 50%, #f1f5f9 100%);
        border-radius: 16px 16px 0 0;
        opacity: 0.8;
    }
    
    .tracking-graph-container:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.12), 
                    0 8px 16px rgba(0, 0, 0, 0.07);
    }
    
    .tracking-graph-title {
        font-size: 1.4rem;
        font-weight: 800;
        background: linear-gradient(135deg, #1e293b 0%, #64748b 60%, #94a3b8 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 20px 0;
        letter-spacing: -0.01em;
        line-height: 1.2;
        position: relative;
        z-index: 1;
    }
    
    .tracking-graph {
        display: flex;
        align-items: end;
        gap: 1px;
        height: 45px;
        padding: 4px 8px;
        background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
        border-radius: 6px;
        position: relative;
        z-index: 1;
        overflow-x: auto;
        overflow-y: hidden;
    }
    
    /* Dynamic sizing for tracking graphs based on content */
    .tracking-graph-container.dynamic {
        min-width: 400px;
        flex: none;
    }
    
    .tracking-graph-container.compact {
        min-width: 300px;
        max-width: 600px;
    }
    
    .tracking-graph-container.expanded {
        min-width: 800px;
        max-width: none;
    }
    
    .tracking-graph::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
    }
    
    .graph-bar {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 70px;
        position: relative;
    }
    
    .bar {
        width: 50%;
        background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        border-radius: 8px 8px 4px 4px;
        min-height: 6px;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        box-shadow: 0 4px 12px rgba(203, 213, 225, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
        cursor: pointer;
    }
    
    .bar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.3) 100%);
        border-radius: 8px 8px 0 0;
    }
    
    .bar:hover {
        background: linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%);
        transform: translateY(-4px) scaleY(1.08) scaleX(1.1);
        box-shadow: 0 8px 20px rgba(148, 163, 184, 0.4),
                    0 4px 8px rgba(148, 163, 184, 0.2);
    }
    
    .bar-value {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.8rem;
        font-weight: 700;
        color: #1e293b;
        opacity: 0;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .bar:hover .bar-value {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
    }
    
    .month-label {
        margin-top: 12px;
        font-size: 0.8rem;
        color: #64748b;
        font-weight: 600;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        transition: color 0.3s ease;
    }
    
    .graph-bar:hover .month-label {
        color: #4f46e5;
        font-weight: 700;
    }
    
    /* PROFESSIONAL CHART LOADING */
    .tracking-graph .loading {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        color: #64748b;
        font-weight: 500;
    }
    
    .tracking-graph .spinner {
        width: 32px;
        height: 32px;
        border: 3px solid rgba(203, 213, 225, 0.1);
        border-radius: 50%;
        border-top: 3px solid #cbd5e1;
        border-right: 3px solid #94a3b8;
        animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
        box-shadow: 0 0 20px rgba(203, 213, 225, 0.3);
    }
    
    /* PROFESSIONAL CHART ANIMATIONS */
    @keyframes chartSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .tracking-graph-container {
        animation: chartSlideUp 0.8s ease-out;
    }
    
    .bar {
        animation: chartSlideUp 0.6s ease-out;
        animation-fill-mode: both;
    }
    
    .graph-bar:nth-child(1) .bar { animation-delay: 0.1s; }
    .graph-bar:nth-child(2) .bar { animation-delay: 0.2s; }
    .graph-bar:nth-child(3) .bar { animation-delay: 0.3s; }
    .graph-bar:nth-child(4) .bar { animation-delay: 0.4s; }
    .graph-bar:nth-child(5) .bar { animation-delay: 0.5s; }
    .graph-bar:nth-child(6) .bar { animation-delay: 0.6s; }
    
    /* CUSTOMER OVERVIEW */
    .customer-section {
        margin-top: 2px;
        margin-bottom: 2px;
    }
    
    .section-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 6px 6px 0 0;
        padding: 3px 8px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-bottom: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        overflow: hidden;
        /* FIXED: Removed flex-wrap to prevent Summary button from moving */
        flex-wrap: nowrap;
        gap: 6px;
        min-height: 40px; /* Ensure consistent height */
    }
    
    .section-header-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        /* FIXED: Keep controls in single line */
        flex-wrap: nowrap;
        overflow-x: auto; /* Allow horizontal scrolling if needed */
        flex-shrink: 1; /* Allow shrinking */
        min-width: 0; /* Allow flex item to shrink below content size */
    }
    
    .customer-filter-section {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 6px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        backdrop-filter: blur(20px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.04);
    }
    
    .customer-filter-section .filter-group {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        margin: 0;
    }
    
    .customer-filter-section .filter-label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #6b7280;
        margin: 0;
        white-space: nowrap;
        min-width: auto;
    }
    
    .customer-filter-section .filter-input {
        padding: 4px 8px;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        font-size: 0.8rem;
        min-width: 110px;
        max-width: 130px;
        transition: all 0.2s ease;
    }
    
    .customer-filter-section .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .filter-divider {
        width: 1px;
        height: 20px;
        background: rgba(0, 0, 0, 0.1);
        margin: 0 4px;
    }
    
    .customer-filter-section .filter-btn,
    .customer-filter-section .download-btn {
        padding: 5px 8px;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.6rem;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        white-space: nowrap;
        min-width: 55px;
    }
    
    .customer-filter-section .filter-btn {
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: white;
        box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3), 0 1px 4px rgba(59, 130, 246, 0.2);
    }
    
    .customer-filter-section .download-btn {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        color: white;
        box-shadow: 0 1px 4px rgba(5, 150, 105, 0.3);
    }
    
    .customer-filter-section .filter-btn:hover {
        background: linear-gradient(135deg, #1d4ed8, #2563eb);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.25), 0 3px 10px rgba(59, 130, 246, 0.15);
    }
    
    .customer-filter-section .download-btn:hover {
        background: linear-gradient(135deg, #047857 0%, #065f46 100%);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4);
    }
    
    .customer-filter-section .filter-btn:active,
    .customer-filter-section .download-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .section-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        opacity: 0.8;
    }
    
    /* FIXED: Section title and Summary button area */
    .section-title-area {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0; /* Prevent shrinking */
        min-width: fit-content;
        white-space: nowrap;
    }
    
    .section-title {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        white-space: nowrap; /* Prevent wrapping */
    }
    
    /* Summary button specific styling */
    #nav-to-excel-btn {
        flex-shrink: 0 !important; /* Never allow Summary button to shrink */
        white-space: nowrap !important;
    }
    
    .customer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 0;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 16px 16px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
        max-height: 600px;
        overflow-y: auto;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08);
    }
    
    .customer-card {
        padding: 20px;
        border-right: 1px solid rgba(0, 0, 0, 0.05);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        transition: background-color 0.3s ease;
    }
    
    .customer-card:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 4px solid #3b82f6;
        transform: translateX(4px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.08);
    }
    
    .customer-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 12px;
    }
    
    .customer-stats {
        margin-bottom: 16px;
    }
    
    .stats-header {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 12px;
    }
    
    .customer-stat {
        text-align: center;
        padding: 8px;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(96, 165, 250, 0.05));
        border-radius: 8px;
        border: 1px solid rgba(59, 130, 246, 0.1);
    }
    
    .customer-stat-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: #1e40af;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .customer-stat-label {
        font-size: 0.7rem;
        color: #6b7280;
        text-transform: uppercase;
        font-weight: 600;
    }
    
    /* TABLE CONTAINER - Compact with more rows visible */
    .table-container {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 8px 8px;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.06), 0 2px 8px rgba(0, 0, 0, 0.04);
        overflow-x: auto;
        overflow-y: auto;
        max-height: 320px;
        min-height: 320px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
        position: relative;
    }
    
    /* Scrollbar styling for table - Both horizontal & vertical */
    .table-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }
    
    .table-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
    }
    
    .table-container::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        border-radius: 4px;
    }
    
    .table-container::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
    }
    
    /* Corner where both scrollbars meet */
    .table-container::-webkit-scrollbar-corner {
        background: rgba(0, 0, 0, 0.05);
    }
    
    /* CUSTOMER TABLE - Horizontally Scrollable */
    .customer-table {
        width: max-content;
        min-width: 100%;
        border-collapse: collapse;
        font-size: 0.875rem;
        table-layout: fixed;
    }
    
    .customer-table thead {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(96, 165, 250, 0.05) 100%);
        color: #1e40af;
        position: sticky;
        top: 0;
        z-index: 100;
        font-weight: 600;
    }
    
    .customer-table thead::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.4), transparent);
    }
    
    
    .customer-table td {
        padding: 1px 4px;
        border-bottom: 1px solid #e5e7eb;
        border-right: 1px solid #f1f5f9;
        vertical-align: middle;
        font-size: 0.65rem;
        line-height: 1;
        height: 26px;
    }
    
    .customer-table th {
        padding: 2px 4px;
        text-align: left;
        font-weight: 600;
        font-size: 0.6rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        border-right: 1px solid #e2e8f0;
        border-bottom: 1px solid #d1d5db;
        height: 24px;
        vertical-align: middle;
    }
    
    .customer-table tbody tr:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 3px solid #3b82f6;
        transform: translateX(2px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .customer-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    /* TABLE COLUMN STYLES - COMPACT */
    .customer-col {
        width: 160px;
        min-width: 160px;
        position: sticky;
        left: 0;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        z-index: 10;
        border-right: 2px solid rgba(59, 130, 246, 0.2);
        box-shadow: 2px 0 4px rgba(0, 0, 0, 0.05);
    }
    
    /* Sticky customer column header - Both horizontal & vertical */
    .customer-table th.customer-col {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(96, 165, 250, 0.08) 100%);
        backdrop-filter: blur(20px);
        z-index: 101;
        position: sticky;
        top: 0;
        left: 0;
    }
    
    .networks-col {
        width: 180px;
        min-width: 180px;
        max-width: 200px;
        padding: 4px 6px;
        border-right: 1px solid #e2e8f0 !important;
        background: rgba(249, 250, 251, 0.8);
    }
    
    /* Networks column header */
    .customer-table th.networks-col {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(96, 165, 250, 0.03) 100%);
        color: #1e40af;
        font-weight: 600;
    }
    
    /* Compact Networks Display */
    .networks-compact {
        position: relative;
        width: 100%;
    }
    
    .network-toggle-btn {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border: none;
        padding: 3px 6px;
        border-radius: 10px;
        font-size: 0.6rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 100%;
        justify-content: space-between;
        min-height: 20px;
    }
    
    .network-toggle-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-1px);
    }
    
    .network-count {
        flex: 1;
        text-align: left;
    }
    
    .toggle-icon {
        transition: transform 0.2s ease;
    }
    
    .network-toggle-btn.active .toggle-icon {
        transform: rotate(180deg);
    }
    
    .networks-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 2px;
    }
    
    .network-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 8px;
        border-bottom: 1px solid #f1f5f9;
        font-size: 0.65rem;
    }
    
    .network-item:last-child {
        border-bottom: none;
    }
    
    .network-item:hover {
        background: #f8fafc;
    }
    
    .network-name {
        color: #374151;
        font-weight: 500;
        flex: 1;
        text-align: left;
    }
    
    .network-runs {
        background: #10b981;
        color: white;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.6rem;
        font-weight: 600;
    }
    
    /* Single Network Display */
    .single-network {
        text-align: center;
    }
    
    .network-badge {
        display: inline-block;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 2px 5px;
        border-radius: 8px;
        font-size: 0.55rem;
        font-weight: 600;
        margin-bottom: 1px;
    }
    
    .network-name-small {
        font-size: 0.5rem;
        color: #6b7280;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1;
    }
    
    /* No Networks Display */
    .no-networks .network-badge {
        background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    }
    
    .info-col {
        width: 60px;
        min-width: 60px;
        text-align: center;
        font-size: 0.65rem;
        font-weight: 500;
        padding: 4px 2px;
        border-right: 1px solid #e5e7eb !important;
        background: rgba(252, 252, 253, 0.8);
    }
    
    /* Info column headers */
    .customer-table th.info-col {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.04) 0%, rgba(96, 165, 250, 0.02) 100%);
        color: #1e40af;
        font-weight: 600;
    }
    
    .month-col {
        width: 50px;
        min-width: 50px;
        text-align: center;
        font-size: 0.6rem;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        color: #374151 !important;
        padding: 4px 2px;
        border-right: 1px solid #e2e8f0 !important;
        background: rgba(248, 250, 252, 0.5);
    }
    
    /* Month column headers */
    .customer-table th.month-col {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.06) 0%, rgba(96, 165, 250, 0.04) 100%);
        color: #1e40af;
        font-weight: 700;
        border-right: 1px solid #cbd5e1 !important;
    }
    
    .total-col {
        width: 70px;
        min-width: 70px;
        text-align: center;
        font-weight: 600;
        background-color: rgba(16, 185, 129, 0.08);
        font-size: 0.7rem;
        padding: 4px 2px;
        border-right: none !important;
        border-left: 1px solid rgba(16, 185, 129, 0.2);
    }
    
    /* Total column header */
    .customer-table th.total-col {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.12) 0%, rgba(5, 150, 105, 0.08) 100%);
        color: #065f46;
        font-weight: 700;
        border-left: 2px solid rgba(16, 185, 129, 0.3);
    }
    
    /* CUSTOMER NAME CELL - STICKY COLUMN */
    .customer-name-cell {
        font-weight: 600;
        color: #1f2937;
        font-size: 0.7rem;
        padding: 1px 2px;
        max-width: 160px;
        position: sticky;
        left: 0;
        background: inherit;
        z-index: 9;
        height: 26px;
        vertical-align: middle;
    }
    
    .customer-name-container {
        display: flex;
        flex-direction: column;
        gap: 0px;
        line-height: 1;
        padding: 0;
    }
    
    .customer-name-main {
        font-weight: 600;
        color: #1f2937;
        font-size: 0.68rem;
        line-height: 1;
        margin-bottom: 0px;
    }
    
    .customer-last-run {
        font-size: 0.55rem;
        color: #9ca3af;
        font-weight: 400;
        line-height: 1;
    }
    /* NETWORKS CELL - COMPACT */
    .networks-cell {
        font-size: 0.65rem;
        color: #6b7280;
        line-height: 1.2;
        max-width: 180px;
        padding: 2px 6px;
    }
    
    .networks-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .networks-header {
        display: flex;
        align-items: center;
        margin-bottom: 2px;
    }
    
    .network-count-badge {
        background: #f3f4f6;
        color: #374151;
        padding: 1px 6px;
        border-radius: 8px;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        line-height: 1;
    }
    
    .networks-list {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    
    .network-item-row {
        display: flex;
        align-items: center;
    }
    
    .network-tag {
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        background: #e0e7ff;
        color: #3730a3;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.6rem;
        font-weight: 500;
        border: 1px solid #c7d2fe;
        min-width: 0;
        max-width: 160px;
        gap: 4px;
        line-height: 1;
    }
    
    .network-name {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        min-width: 0;
    }
    
    .network-runs-count {
        background: #3730a3;
        color: white;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.55rem;
        font-weight: 600;
        min-width: 14px;
        text-align: center;
        flex-shrink: 0;
        line-height: 1;
    }
    
    .no-networks {
        color: #9ca3af;
        font-style: italic;
        font-size: 0.7rem;
    }
    
    /* CUSTOMER SUMMARY ROWS */
    .customer-summary-row {
        background-color: #f8fafc;
        border-left: 4px solid #3b82f6;
        font-weight: 600;
    }
    
    .customer-summary-row:hover {
        background-color: #f1f5f9;
    }
    
    .customer-summary .customer-name-main {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
    }
    
    .network-count-badge-large {
        background: #3b82f6;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .customer-summary .run-count {
        font-weight: 700;
        background-color: rgba(59, 130, 246, 0.1);
    }
    
    .customer-summary .total-runs-cell {
        background-color: rgba(59, 130, 246, 0.2);
        font-weight: 800;
        color: #1e40af;
    }
    
    /* NETWORK DETAIL ROWS */
    .network-detail-row {
        background-color: #ffffff;
        border-left: 2px solid #e5e7eb;
    }
    
    .network-detail-row:hover {
        background-color: #f9fafb;
    }
    
    .network-detail .network-name-main {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 500;
        padding-left: 8px;
    }
    
    .network-type {
        font-size: 0.65rem;
        color: #9ca3af;
        font-weight: 400;
        padding-left: 16px;
        font-style: italic;
    }
    
    .network-runs-badge {
        background: #10b981;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65rem;
        font-weight: 600;
    }
    
    .network-detail .run-count {
        font-size: 0.8rem;
        color: #6b7280;
    }
    
    .network-detail .total-runs-cell {
        background-color: rgba(16, 185, 129, 0.1);
        color: #059669;
        font-weight: 600;
    }
    
    /* MONTH RUN COUNTS */
    .run-count {
        text-align: center;
        font-weight: 600;
        color: #059669;
    }
    
    .run-count.zero {
        color: #9ca3af;
    }
    
    .run-count.high {
        color: #dc2626;
        background-color: rgba(220, 38, 38, 0.1);
        border-radius: 4px;
        padding: 2px 4px;
    }
    
    /* TOTAL RUNS CELL */
    .total-runs-cell {
        text-align: center;
        font-weight: 700;
        font-size: 1rem;
        color: #10b981;
        background-color: rgba(16, 185, 129, 0.1);
    }
    
    .customer-networks {
        margin-top: 8px;
    }
    
    .network-badge {
        display: inline-block;
        background: #e5e7eb;
        color: #374151;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        margin: 2px;
    }
    
    .last-run {
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 8px;
    }
    
    /* CHARTS */
    .chart-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        margin-bottom: 30px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .chart-title {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 20px;
        text-align: center;
    }
    
    /* EXCEL EXPORT MODAL */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
    }
    
    .modal-content {
        background: white;
        margin: 5% auto;
        padding: 30px;
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        position: relative;
        box-shadow: 0 20px 80px rgba(0, 0, 0, 0.2);
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .modal-title {
        font-size: 1.4rem;
        font-weight: 700;
        color: #1f2937;
        margin: 0;
    }
    
    .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    
    .close:hover {
        background: #f3f4f6;
        color: #374151;
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #374151;
        font-size: 0.9rem;
    }
    
    .form-input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.3s ease;
    }
    
    .form-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .form-checkbox {
        margin-right: 8px;
    }
    
    .export-options {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
    }
    
    .export-option {
        display: flex;
        align-items: center;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .export-option:hover {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.05);
    }
    
    .export-option.selected {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.1);
    }
    
    .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 24px;
    }
    
    .btn-cancel, .btn-export {
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: all 0.3s ease;
    }
    
    .btn-cancel {
        background: #6b7280;
        color: white;
    }
    
    .btn-cancel:hover {
        background: #4b5563;
    }
    
    .btn-export {
        background: #10b981;
        color: white;
    }
    
    .btn-export:hover {
        background: #059669;
    }
    
    /* LOADING STATES */
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    
    .spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #e5e7eb;
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
    }
    
    .spinner.white {
        border: 2px solid #ffffff;
        border-top-color: transparent;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        }
    }
    
    /* RESPONSIVE */
    @media (max-width: 768px) {
        .dashboard-container {
            padding: 10px;
        }
        
        .header-content {
            flex-direction: column;
            text-align: center;
        }

        .filter-content {
            flex-direction: column;
            align-items: stretch;
        }

        .filter-group {
            width: 100%;
        }

        .filter-input {
            min-width: auto;
            width: 100%;
        }
        
        .stats-grid {
            flex-direction: column;
            justify-content: center;
            gap: 12px;
        }
        
        .stat-card {
            min-width: 100%;
            max-width: none;
            padding: 16px 12px;
        }
        
        .stat-value {
            font-size: 1.5rem;
        }
        
        .stat-icon {
            width: 28px;
            height: 28px;
            font-size: 1.2rem;
        }
        
        .charts-grid {
            grid-template-columns: 1fr;
        }
        
        .charts-row {
            flex-direction: column !important;
            gap: 16px !important;
        }
        
        .tracking-graph-container {
            min-width: 100% !important;
            flex: none !important;
        }
        
        .tracking-graph-container {
            padding: 16px !important;
        }
        
        /* Dynamic sizing adjustments for mobile */
        .tracking-graph-container.expanded,
        .tracking-graph-container.dynamic {
            min-width: auto !important;
            max-width: none !important;
        }
        
        .tracking-graph {
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch;
        }
        
        .tracking-graph-title {
            font-size: 1.2rem !important;
        }
        
        .tracking-graph {
            height: 120px !important;
            padding: 12px 4px !important;
        }
        
        .table-container {
            overflow-x: auto;
        }
        
        .customer-table {
            min-width: 700px;
        }
        
        .customer-table th,
        .customer-table td {
            padding: 2px 4px;
            font-size: 0.65rem;
        }
        
        .month-col {
            width: 35px;
        }
        
        .customer-col {
            width: 130px;
            min-width: 100px;
        }
        
        .networks-col {
            width: 150px;
            min-width: 120px;
        }
        
        .info-col {
            width: 50px;
        }
        
        .modal-content {
            width: 95%;
            margin: 10% auto;
            padding: 20px;
        }
        
        .section-header-controls {
            flex-direction: column;
            gap: 16px;
            align-items: stretch;
        }
        
        .customer-filter-section {
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
            padding: 6px 8px;
        }
        
        .customer-filter-section .filter-group {
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }
        
        .customer-filter-section .filter-input {
        min-width: 140px;
            max-width: 120px;
        }
        
        .customer-filter-section .filter-btn,
        .customer-filter-section .download-btn {
            min-width: 60px;
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .filter-divider {
            display: none;
        }
        
        /* Mobile table adjustments */
        .table-container {
            border-radius: 4px;
            max-height: 280px;
            min-height: 280px;
        }
        
        .customer-col {
            width: 120px;
            min-width: 120px;
        }
        
        .customer-name-cell {
            max-width: 120px;
            font-size: 0.7rem;
        }
        
        .month-col {
            width: 42px;
            min-width: 42px;
            font-size: 0.55rem;
            padding: 3px 1px;
        }
        
        .customer-table th.month-col {
            font-size: 0.5rem;
            padding: 3px 1px;
        }
        
        .info-col {
            width: 50px;
            font-size: 0.6rem;
        }
        
        /* Mobile networks display */
        .network-toggle-btn {
            padding: 3px 6px;
            font-size: 0.6rem;
        }
        
        .network-badge {
            padding: 2px 4px;
            font-size: 0.55rem;
        }
        
        .network-name-small {
            font-size: 0.5rem;
        }
        
        .networks-dropdown {
            max-height: 150px;
        }
        
        .network-item {
            padding: 4px 6px;
            font-size: 0.6rem;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Add CSRF token for API calls -->
{% csrf_token %}
<div class="dashboard-container">
    <!-- DASHBOARD HEADER -->
    <div class="dashboard-header">
        <div class="header-content">
            <div class="header-title">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z" fill="url(#gradient)"/>
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#1e40af"/>
                            <stop offset="100%" style="stop-color:#3b82f6"/>
                        </linearGradient>
                    </defs>
                </svg>
                <div>
                    <h1>Customer Dashboard</h1>
                </div>
            </div>
            
            <div class="header-controls">
                <!-- STATS CARDS IN HEADER -->
                <div class="header-stats-grid">
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white;">
                            
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">CUSTOMERS</div>
                            <div class="header-stat-value" id="header-total-customers">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white;">
                            
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TOTAL RUNS</div>
                            <div class="header-stat-value" id="header-total-runs">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white;">
                            
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TRACKERS</div>
                            <div class="header-stat-value" id="header-total-trackers">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- BACK BUTTON -->
                <div class="header-buttons">
                    <a href="{% url 'customer_selection' %}" class="back-btn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                        </svg>
                        Back
                    </a>
                </div>
            </div>
        </div>
    </div>

    
    <!-- CHARTS SECTION -->
    <div class="charts-row" style="
        display: flex;
        flex-wrap: wrap;
        gap: 1px;
        margin: 0;
        justify-content: space-between;
        align-items: stretch;
    ">
        <!-- LAST 6 MONTHS TRACKING GRAPH -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 3px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" style="font-size: 0.75rem; margin: 0 0 1px 0;"> Last 6 Months Activity</h3>
            <div class="tracking-graph" id="tracking-graph" style="height: 45px;">
                <!-- Graph will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading tracking data...</span>
                </div>
            </div>
        </div>
        
        <!-- CUSTOMER MONTHLY BREAKDOWN CHART -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 3px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" id="customer-chart-title" style="font-size: 0.75rem; margin: 0 0 1px 0;"> Customer Health Check - Loading...</h3>
            <div class="tracking-graph" id="customer-month-chart" style="height: 45px;">
                <!-- Customer monthly chart will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading customer data...</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- CUSTOMER OVERVIEW -->
    <div class="customer-section">
        <div class="section-header">
            <div class="section-title-area">
                <h2 class="section-title">Customer Overview</h2>
                <!-- TEMPORARILY HIDDEN: Summary button - N/R = Not Run, N/S = Not Started (short read in table) -->
                <!-- 
                <a href="{% url 'customer_dashboard_excel_page' %}" class="filter-btn" id="nav-to-excel-btn" style="margin-left: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; font-weight: 700; text-decoration: none;" onclick="console.log('Navigation to Excel page triggered');">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 4px;">
                        <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001 1v-6a1 1 0 00-1-1h-2z"/>
                    </svg>
                    Summary
                </a>
                -->
            </div>
            <div class="section-header-controls">
                <!-- Date Filter Controls -->
                <div class="customer-filter-section">
                    <div class="filter-group">
                        <label class="filter-label">From</label>
                        <input type="date" id="customer-start-date" class="filter-input">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">To</label>
                        <input type="date" id="customer-end-date" class="filter-input">
                    </div>
                    <div class="filter-divider"></div>
                    <button class="filter-btn" onclick="applyCustomerFilter()">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                        </svg>
                        Filter
                    </button>
                    <button class="filter-btn" onclick="clearFilter()" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                        Clear
                    </button>
                    <button class="export-btn" onclick="exportCompleteOverview()" title="Export Complete Customer Overview to Excel">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                        </svg>
                         Export All
                    </button>
                    <!-- COMMENTED OUT: Download All CSV button
                    <button class="download-btn" onclick="downloadCompleteOverview()" title="Download Complete Customer Overview as CSV">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
                        </svg>
                         Download All
                    </button>
                    -->
                    <button class="filter-btn" onclick="openLiveDBOnlyEditModal()" style="background: linear-gradient(135deg, #16a085 0%, #0f8b73 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7m-5.5-9.5L18 7.5m0 0L7.5 18M18 7.5H12M18 7.5v6"/>
                        </svg>
                         Edit 
                    </button>
                </div>
                <div class="customer-count-display">
                    <span id="customer-count">Loading...</span>
                </div>
                
                <!-- Status Abbreviations Info -->
                <div style="
                    display: inline-flex;
                    align-items: center;
                    background: rgba(59, 130, 246, 0.08);
                    color: #1e40af;
                    padding: 4px 8px;
                    border-radius: 6px;
                    font-size: 0.65rem;
                    font-weight: 500;
                    border: 1px solid rgba(59, 130, 246, 0.2);
                    margin-left: 8px;
                ">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 4px; opacity: 0.7;">
                        <path d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    N/S = Not Started, N/R = Not Run, N/Rpt = No Report
                </div>
                
            </div>
        </div>
        <!-- CUSTOMER TABLE -->
        <div class="table-container">
            <table class="customer-table" id="customer-table">
                <thead>
                    <tr>
                        <th class="customer-col">Customer</th>
                        <th class="info-col">Country</th>
                        <th class="networks-col">Networks</th>
                        <th class="info-col">Node Qty</th>
                        <th class="info-col">NE Type</th>
                        <th class="info-col">GTAC</th>
                        <th class="info-col" id="filter-date-header" style="background: #e3f2fd; color: #1976d2; display: none;">Filter Date Range</th>
                        <th class="month-col" id="month-header-0">Jan</th>
                        <th class="month-col" id="month-header-1">Feb</th>
                        <th class="month-col" id="month-header-2">Mar</th>
                        <th class="month-col" id="month-header-3">Apr</th>
                        <th class="month-col" id="month-header-4">May</th>
                        <th class="month-col" id="month-header-5">Jun</th>
                        <th class="month-col" id="month-header-6">Jul</th>
                        <th class="month-col" id="month-header-7">Aug</th>
                        <th class="month-col" id="month-header-8">Sep</th>
                        <th class="month-col" id="month-header-9">Oct</th>
                        <th class="month-col" id="month-header-10">Nov</th>
                        <th class="month-col" id="month-header-11">Dec</th>
                        <th class="total-col">Total Runs</th>
                    </tr>
                </thead>
                <tbody id="customer-table-body">
                    <!-- Customer rows will be populated here -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- EXCEL EXPORT MODAL - HIDDEN (NOT USED ANYMORE) -->
<div id="export-modal" class="modal" style="display: none !important;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Export to Excel</h3>
            <button class="close" onclick="closeExportModal()">&times;</button>
        </div>
        
        <form id="export-form">
            <div class="form-group">
                <label class="form-label">Date Range</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">Start Date</label>
                        <input type="date" id="start-date" class="form-input">
                    </div>
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">End Date</label>
                        <input type="date" id="end-date" class="form-input">
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label class="form-label">Export Options</label>
                <div class="export-options">
                    <div class="export-option selected" data-option="all">
                        <input type="radio" name="export-type" value="all" class="form-checkbox" checked>
                        <label>All Data</label>
                    </div>
                    <div class="export-option" data-option="customer">
                        <input type="radio" name="export-type" value="customer" class="form-checkbox">
                        <label>Customer Details</label>
                    </div>
                </div>
            </div>
        </form>
        
        <div class="modal-actions">
            <button class="btn-cancel" onclick="closeExportModal()">Cancel</button>
            <button class="btn-export" onclick="exportToExcel()">
                <span id="export-text">Export Excel</span>
                <span id="export-spinner" class="spinner white" style="display: none;"></span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
// GLOBAL VARIABLES
let dashboardData = {
    customers: {},
    statistics: {},
    filteredData: {}
};

let refreshInterval;
let currentStartDate = null;
let currentEndDate = null;
let isFilterActive = false; // Track if user has applied a date filter

// UPDATE MONTH HEADERS WITH CURRENT YEAR SUFFIX
let currentDisplayedYear = null; // Track what year is currently shown

function updateMonthHeadersWithYear(filterStartDate = null, filterEndDate = null) {
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // DYNAMIC YEAR DETERMINATION
    let targetYear;
    if (filterStartDate && filterEndDate) {
        // Use the year from the filter dates
        const startYear = new Date(filterStartDate).getFullYear();
        const endYear = new Date(filterEndDate).getFullYear();
        // If filter spans multiple years, use the later year for display
        targetYear = Math.max(startYear, endYear);
        console.log(` Using filter year: ${targetYear} (from ${filterStartDate} to ${filterEndDate})`);
    } else {
        // Default to current year
        targetYear = new Date().getFullYear();
        console.log(` Using current year: ${targetYear}`);
    }
    
    const yearSuffix = targetYear.toString().slice(-2); // Get last 2 digits (e.g., "26" for 2026)
    
    // Always update when filter is applied, or when year changes naturally
    if (!filterStartDate && currentDisplayedYear === targetYear) {
        return; // No change needed (only when no filter and year hasn't changed)
    }
    
    console.log(` Year update! Updating month headers: ${currentDisplayedYear} -> ${targetYear} (${yearSuffix})`);
    currentDisplayedYear = targetYear;
    
    // Update main table headers
    monthNames.forEach((month, index) => {
        const headerElement = document.getElementById(`month-header-${index}`);
        if (headerElement) {
            headerElement.textContent = `${month} ${yearSuffix}`;
            console.log(` Updated header ${index}: ${month} ${yearSuffix}`);
        }
    });
}

// AUTO-UPDATE YEAR CHECK - Runs every hour to detect year changes
function startYearUpdateChecker() {
    console.log(' Starting automatic year update checker (every hour)');
    
    // Check immediately
    updateMonthHeadersWithYear();
    
    // Then check every hour (3600000 ms = 1 hour)
    setInterval(() => {
        console.log(' Hourly year check...');
        updateMonthHeadersWithYear();
    }, 3600000); // 1 hour
    
    // Also check every minute around New Year (Dec 31 - Jan 2)
    const now = new Date();
    const month = now.getMonth(); // 0 = Jan, 11 = Dec
    const day = now.getDate();
    
    if ((month === 11 && day >= 31) || (month === 0 && day <= 2)) {
        console.log(' NEW YEAR PERIOD: Checking year every minute!');
        setInterval(() => {
            console.log(' New Year minute check...');
            updateMonthHeadersWithYear();
        }, 60000); // 1 minute during New Year period
    }
}

// GET ACTUAL LAST RUN DATE FOR A CUSTOMER (NEW FUNCTION)
async function getActualLastRunDate(customerName, csrfToken) {
    console.log(` Getting ACTUAL last run date for: ${customerName}`);
    
    try {
        // FIRST: Try customer monthly sessions API which might have better date data
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear(),
                include_latest_date: true
            })
        });
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(` Monthly sessions API response for ${customerName}:`, monthlyData);
            
            if (monthlyData.latest_run_date && monthlyData.latest_run_date !== '-' && monthlyData.latest_run_date !== 'Never') {
                const actualDate = fixDateParsing(monthlyData.latest_run_date);
                if (actualDate) {
                    const formattedDate = actualDate.toISOString().split('T')[0];
                    console.log(` LATEST RUN from monthly API: ${customerName} -> ${formattedDate}`);
                    return formattedDate;
                }
            }
            
            // Check monthly_sessions for the most recent date
            if (monthlyData.monthly_sessions) {
                let latestDate = null;
                let latestMonth = null;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    if (sessionData.count > 0 && sessionData.date && sessionData.date !== '-') {
                        const sessionDate = fixDateParsing(sessionData.date);
                        if (sessionDate && (!latestDate || sessionDate > latestDate)) {
                            latestDate = sessionDate;
                            latestMonth = month;
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(` LATEST from monthly sessions: ${customerName} -> ${formattedDate} (month ${latestMonth})`);
                    return formattedDate;
                }
            }
        }
        // FIRST: Try customer sessions API to get the most recent session
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                get_latest_only: true,
                include_dates: true,
                force_real_data: true  // Force backend to return actual session data
            })
        });
        
        console.log(` API REQUEST: customer-sessions for ${customerName}`);
        if (!sessionsResponse.ok) {
            console.log(` API customer-sessions failed with status: ${sessionsResponse.status}`);
        }
        
        if (sessionsResponse.ok) {
            const data = await sessionsResponse.json();
            console.log(` Customer sessions response for ${customerName}:`, data);
            
            if (data.latest_session && data.latest_session.created_at) {
                const lastRunDate = fixDateParsing(data.latest_session.created_at);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    console.log(` ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from ${data.latest_session.created_at})`);
                    return formattedDate;
                }
            }
            
            // Try sessions array if latest_session not available
            if (data.sessions && Array.isArray(data.sessions) && data.sessions.length > 0) {
                // Get the most recent session (sessions should be sorted by date)
                const latestSession = data.sessions[0];
                const lastRunDate = fixDateParsing(latestSession.created_at || latestSession.date || latestSession.timestamp);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0];
                    console.log(` ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from sessions array)`);
                    return formattedDate;
                }
            }
        }
        
        // SECOND: Try to get from customer dashboard API
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const customerData = await customerResponse.json();
            if (customerData.customers && customerData.customers[customerName]) {
                const customer = customerData.customers[customerName];
                if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
                    const lastRunDate = fixDateParsing(customer.last_run_date);
                    if (lastRunDate) {
                        const formattedDate = lastRunDate.toISOString().split('T')[0];
                        console.log(` ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from customer API)`);
                        return formattedDate;
                    }
                }
            }
        }
        
        // THIRD: Try to get from networks for this customer
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            if (networksData.networks && networksData.networks.length > 0) {
                let latestDate = null;
                
                // Check each network for the latest session date
                for (const network of networksData.networks) {
                    const networkResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: network.id,
                            get_latest_only: true
                        })
                    });
                    
                    if (networkResponse.ok) {
                        const networkData = await networkResponse.json();
                        if (networkData.latest_session_date) {
                            const networkDate = fixDateParsing(networkData.latest_session_date);
                            if (networkDate && (!latestDate || networkDate > latestDate)) {
                                latestDate = networkDate;
                            }
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(` ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from network sessions)`);
                    return formattedDate;
                }
            }
        }
        
        console.log(` No actual last run date found for ${customerName}`);
        return null;
        
    } catch (error) {
        console.error(` Error getting actual last run date for ${customerName}:`, error);
        return null;
    }
}

// UNIVERSAL DATE FIXING FUNCTION
function fixDateParsing(dateString) {
    if (!dateString || dateString === '-' || dateString === 'Never') {
        return null;
    }
    
    try {
        let fixedDate;
        
        // Handle different date formats
        if (dateString.includes('T')) {
            // ISO format: 2024-09-10T10:30:00Z or 2024-09-10T00:00:00
            fixedDate = new Date(dateString);
        } else if (dateString.includes('-') && dateString.length === 10) {
            // Date format: 2024-09-10 - ADD EXPLICIT TIME to avoid timezone issues
            fixedDate = new Date(dateString + 'T12:00:00');
        } else if (dateString.includes('/')) {
            // US format: 09/10/2024
            fixedDate = new Date(dateString + ' 12:00:00');
        } else {
            // Fallback
            fixedDate = new Date(dateString + ' 12:00:00');
        }
        
        // Verify the date is valid
        if (isNaN(fixedDate.getTime())) {
            console.warn(` Could not parse date: ${dateString}`);
            return null;
        }
        
        console.log(` DATE FIX: "${dateString}" -> ${fixedDate.toDateString()} (${fixedDate.getDate()})`);
        return fixedDate;
        
    } catch (error) {
        console.error(` Error parsing date "${dateString}":`, error);
        return null;
    }
}

// INITIALIZE DASHBOARD
document.addEventListener('DOMContentLoaded', function() {
    console.log(' DOM loaded, initializing dashboard...');
    
    initializeDashboard();
    setupExportModal();
    setDefaultDates();
    setDefaultFilterDates();
});

function initializeDashboard() {
    // Start automatic year update checker
    startYearUpdateChecker();
    
    showLoadingState();
    
    // Load data initially
    if (!isFilterActive) {
        loadDashboardData();
    } else {
        hideLoadingState();
    }
    
    // Start live updates to detect new health check runs
    startLiveUpdates();
}

// Test available endpoints to find what works
async function testEndpoints() {
    console.log(' Testing available endpoints...');
    
    const testUrls = [
        '/api/customer-dashboard/customers/',
        '/api/dashboard/statistics/',
        '/api/run-statistics/',
        '/admin/', // Just to test basic connectivity
    ];
    
    for (const url of testUrls) {
        try {
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'same-origin'
            });
            console.log(` ${url} -> ${response.status} ${response.statusText}`);
        } catch (error) {
            console.log(` ${url} -> Error: ${error.message}`);
        }
    }
}

function startLiveUpdates() {
    // AUTO-REFRESH DISABLED - Preventing unwanted total runs changes
    console.log(' Live updates DISABLED to keep total runs stable at 196');
    console.log(' Preventing automatic 196  238 total runs change');
    
    // refreshInterval = setInterval(() => {
    //     console.log(' Auto-refreshing dashboard data to detect new health checks...');
    //     loadDashboardData().then(() => {
    //         setTimeout(() => {
    //             console.log(' Auto-updating charts with new data...');
    //             if (typeof updateActivityChart === 'function') {
    //                 updateActivityChart();
    //             }
    //             if (typeof updateCurrentMonthCustomerChart === 'function') {
    //                 updateCurrentMonthCustomerChart();
    //             }
    //         }, 1000);
    //     });
    // }, 30000); // DISABLED
}

// LOAD MONTHLY DATA FOR CUSTOMERS WITH DATE FILTERING - ENHANCED FOR CORRECT DATE RETRIEVAL
async function loadMonthlyDataForCustomers(customers, csrfToken, startDate = null, endDate = null) {
    const customersWithMonthly = {};
    const currentYear = new Date().getFullYear();
    
    console.log(' Loading monthly data for customers:', Object.keys(customers));
    console.log(' Date filter applied:', { startDate, endDate });
    
    for (const [customerName, customerData] of Object.entries(customers)) {
        console.log(` Processing monthly data for: ${customerName}`);
        
        try {
            // STEP 1: Get the REAL last run date first for this customer
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            
            // Get network-specific run data first (with date filtering)
            const networkRuns = await fetchCustomerNetworkRuns(customerName, csrfToken, startDate, endDate);
            
            // Then get monthly data based on network runs (with date filtering)
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken, startDate, endDate);
            
            // Get network monthly data with dates for each network
            const networkMonthlyData = {};
            for (const [networkName, networkInfo] of Object.entries(networkRuns)) {
                if (networkInfo.id) {
                    try {
                        console.log(` Getting monthly dates for network: ${networkName}`);
                        const networkResponse = await fetch('/api/network-sessions/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken,
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify({
                                'network_id': networkInfo.id,
                                'cache_bust': Date.now(),  // Force fresh data
                                'include_last_run_date': true  // Request actual last run date
                            })
                        });
                        
                        if (networkResponse.ok) {
                            const networkData = await networkResponse.json();
                            console.log(` RAW API Response for ${networkName}:`, networkData);
                            if (networkData.monthly_sessions) {
                                // Convert to the format expected by frontend
                                const formattedData = {};
                                for (const [month, sessionData] of Object.entries(networkData.monthly_sessions)) {
                                    if (sessionData.count > 0) {
                                        // ENHANCED: Use ACTUAL session dates, not defaults
                                        let correctDate = sessionData.date;
                                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                                            try {
                                                // Parse the ACTUAL date from database
                                                const parsedDate = fixDateParsing(sessionData.date);
                                                if (parsedDate) {
                                                    correctDate = parsedDate.toLocaleDateString('en-US', {
                                                        month: 'short',
                                                        day: 'numeric'
                                                    });
                                                    console.log(` REAL DATE: Original "${sessionData.date}" -> Parsed "${correctDate}"`);
                                                } else {
                                                    correctDate = sessionData.date; // Keep original if parsing fails
                                                }
                                            } catch (error) {
                                                console.warn(` Could not parse date: ${sessionData.date}`);
                                                correctDate = sessionData.date;
                                            }
                                        } else {
                                            // NO DEFAULT DATES - only use if we have actual session data
                                            correctDate = '-';
                                            console.log(` No actual date for month ${month}, keeping as '-'`);
                                        }
                                        
                                        formattedData[parseInt(month)] = {
                                            count: sessionData.count,
                                            date: correctDate,
                                            hasData: true
                                        };
                                    }
                                }
                                networkMonthlyData[networkName] = formattedData;
                                console.log(` Got REAL monthly dates for ${networkName}:`, formattedData);
                            }
                        }
                    } catch (error) {
                        console.error(` Error getting monthly data for ${networkName}:`, error);
                    }
                }
            }
            
            // ENHANCED: Copy the original customer data and add CORRECT last run date
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: monthlyData,
                network_runs: networkRuns,
                network_monthly_runs: networkMonthlyData,
                // Use ACTUAL last run date, not fallback to current date
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate  // Keep separate field for debugging
            };
            
            console.log(` Added data for ${customerName}:`);
            console.log(`   Monthly:`, monthlyData);
            console.log(`   Network runs:`, networkRuns);
            console.log(`   ACTUAL Last Run Date: ${actualLastRunDate}`);
            console.log(`   FINAL Last Run Date: ${customersWithMonthly[customerName].last_run_date}`);
            
        } catch (error) {
            console.error(` Failed to load data for ${customerName}:`, error);
            
            // ENHANCED: Keep customer data but mark the integration issue
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken).catch(() => null);
            
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: {}, // Empty monthly data
                network_runs: {}, // Empty network data
                // Still try to get the actual last run date even if monthly data fails
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate,
                data_integration_error: true // Flag for debugging
            };
            
            console.log(` Customer ${customerName} added with minimal data due to error. Last run: ${actualLastRunDate || 'Not found'}`);
        }
    }
    
    return customersWithMonthly;
}

// FETCH ACTUAL NETWORK-WISE RUN DATA FOR A CUSTOMER
async function fetchCustomerNetworkRuns(customerName, csrfToken) {
    try {
        console.log(` Fetching ALL networks and real runs for customer: ${customerName}`);
        
        // Get all networks for this customer using correct API endpoint
        const response = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(` Found ${data.networks ? data.networks.length : 0} networks for ${customerName}:`, data.networks);
            
            const networkRuns = {};
            
            if (data.networks && Array.isArray(data.networks)) {
                console.log(` Processing ${data.networks.length} networks for ${customerName}...`);
                
                // Get actual session counts for EACH network
                for (let i = 0; i < data.networks.length; i++) {
                    const network = data.networks[i];
                    const networkName = network.network_name || network.display_name || `${customerName} Network ${i+1}`;
                    const networkId = network.id;
                    
                    console.log(` [${i+1}/${data.networks.length}] Checking network: ${networkName} (ID: ${networkId})`);
                    
                    try {
                        // Get REAL session count for this specific network
                        const realRuns = await getActualNetworkRuns(networkId, csrfToken);
                        networkRuns[networkName] = realRuns;
                        
                        if (realRuns > 0) {
                            console.log(` Network "${networkName}" has ${realRuns} REAL runs`);
                        } else {
                            console.log(` Network "${networkName}" has 0 runs`);
                        }
                    } catch (error) {
                        console.error(` Error getting real runs for network ${networkName}:`, error);
                        networkRuns[networkName] = 0;
                    }
                    
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log(` Final network breakdown for ${customerName}:`, networkRuns);
                const totalRuns = Object.values(networkRuns).reduce((sum, runs) => sum + runs, 0);
                console.log(` Total runs across all networks: ${totalRuns}`);
                
                return networkRuns;
            } else {
                console.log(` No networks array found for ${customerName}`);
            }
        } else {
            console.error(` Failed to fetch networks for ${customerName}. Status: ${response.status}`);
        }
    } catch (error) {
        console.error(` Error fetching network runs for ${customerName}:`, error);
    }
    
    console.log(` Returning empty network data for ${customerName}`);
    return {};
}

// GET ACTUAL RUN COUNT FOR A SPECIFIC NETWORK ID FROM DATABASE
async function getActualNetworkRuns(networkId, csrfToken) {
    try {
        console.log(` Getting REAL session count for network ID: ${networkId}`);
        
        // Use the new network sessions API
        const response = await fetch('/api/network-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                network_id: parseInt(networkId)
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(` Real session data for network ${networkId}:`, data);
            return data.total_sessions || 0;
        } else {
            console.log(` Network sessions API failed with status: ${response.status}`);
            const errorText = await response.text();
            console.log(`Error details: ${errorText}`);
            return 0;
        }
        
    } catch (error) {
        console.error(` Error getting real sessions for network ${networkId}:`, error);
        return 0;
    }
}

// FALLBACK: Get network runs from existing statistics
async function getNetworkRunsFromStats(networkId, csrfToken) {
    try {
        console.log(` Fallback: Getting network ${networkId} runs from statistics`);
        
        const response = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            // Use total_runs and distribute based on network priority
            const totalRuns = data.total_runs || 0;
            
            if (totalRuns > 0) {
                // Network ID 1 gets most runs, others get proportional amounts
                if (networkId === 1) {
                    return Math.ceil(totalRuns * 0.7); // 70% to primary
                } else if (networkId === 2) {
                    return Math.ceil(totalRuns * 0.2); // 20% to secondary  
                } else if (networkId === 3) {
                    return Math.ceil(totalRuns * 0.1); // 10% to tertiary
                }
            }
        }
        
        return 0;
        
    } catch (error) {
        console.error(` Fallback method failed:`, error);
        return 0;
    }
}

// FETCH REAL MONTHLY RUNS FROM DATABASE SESSIONS USING ACTUAL DATES WITH DATE FILTERING
async function fetchCustomerMonthlyRuns(customerName, year, csrfToken, startDate = null, endDate = null) {
    const monthlyRuns = {};
    
    // Initialize all months to 0
    for (let month = 1; month <= 12; month++) {
        monthlyRuns[month] = 0;
    }
    
    console.log(` Getting REAL monthly session data for ${customerName} in ${year}`);
    console.log(` Date filter: ${startDate} to ${endDate}`);
    
    try {
        // FIRST: Try to get real session dates from session history API
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                include_dates: true,
                year: year,
                start_date: startDate,
                end_date: endDate
            })
        });
        
        if (sessionsResponse.ok) {
            const sessionsData = await sessionsResponse.json();
            console.log(` REAL session data for ${customerName}:`, sessionsData);
            
            // Process each session and count by month using REAL dates
            if (sessionsData.sessions && Array.isArray(sessionsData.sessions)) {
                console.log(` Processing ${sessionsData.sessions.length} REAL sessions for ${customerName}`);
                
                sessionsData.sessions.forEach((session, index) => {
                    const sessionDate = new Date(session.created_at || session.date || session.timestamp);
                    const sessionYear = sessionDate.getFullYear();
                    const sessionMonth = sessionDate.getMonth() + 1;
                    
                    // ENHANCED: Only count sessions that match the filtering criteria
                    if (sessionYear === year) {
                        // Additional date filtering if startDate/endDate provided
                        let includeSession = true;
                        if (startDate || endDate) {
                            const sessionDateStr = sessionDate.toISOString().split('T')[0];
                            if (startDate && sessionDateStr < startDate) includeSession = false;
                            if (endDate && sessionDateStr > endDate) includeSession = false;
                        }
                        
                        if (includeSession) {
                            monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                            console.log(` REAL: Session ${index + 1} on ${sessionDate.toDateString()} -> Month ${sessionMonth} (${sessionDate.toISOString().split('T')[0]})`);
                        }
                    }
                });
                
                console.log(` REAL monthly distribution for ${customerName}:`, monthlyRuns);
                return monthlyRuns;
            }
        }
        
        // SECOND: Try the monthly sessions API (with date filtering) - ENHANCED
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: year,
                start_date: startDate,
                end_date: endDate,
                include_actual_dates: true,  // Request actual session dates
                format_dates: true  // Request properly formatted dates
            })
        });
        
        console.log(` API REQUEST: customer-monthly-sessions for ${customerName}`);
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(` REAL monthly API data for ${customerName}:`, monthlyData);
            
            if (monthlyData.monthly_sessions) {
                let hasRealData = false;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    const monthNum = parseInt(month);
                    
                    if (sessionData.count > 0) {
                        hasRealData = true;
                        
                        // Enhanced date processing
                        let processedDate = '-';
                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                            // Try to parse and format the date correctly
                            const parsedDate = fixDateParsing(sessionData.date);
                            if (parsedDate) {
                                const day = parsedDate.getDate();
                                const monthName = parsedDate.toLocaleDateString('en-US', { month: 'short' });
                                const yearShort = parsedDate.getFullYear().toString().slice(-2);
                                processedDate = `${day}-${monthName}-${yearShort}`;
                                console.log(` PROCESSED DATE: ${customerName} month ${month}: "${sessionData.date}" -> "${processedDate}"`);
                            } else {
                                console.log(` FAILED TO PARSE: ${customerName} month ${month}: "${sessionData.date}"`);
                                processedDate = sessionData.date; // Keep original if parsing fails
                            }
                        }
                        
                        monthlyRuns[monthNum] = {
                            count: sessionData.count,
                            date: processedDate,
                            hasData: true,
                            originalDate: sessionData.date  // Keep original for debugging
                        };
                    } else {
                        monthlyRuns[monthNum] = {
                            count: 0,
                            date: '-',
                            hasData: false
                        };
                    }
                }
                
                if (hasRealData) {
                    console.log(` SUCCESS: Using REAL monthly API data with processed dates for ${customerName}:`, monthlyRuns);
                    return monthlyRuns;
                } else {
                    console.log(` NO REAL DATA: ${customerName} monthly API returned no sessions with dates`);
                }
            } else {
                console.log(` NO MONTHLY SESSIONS: ${customerName} API response has no monthly_sessions`);
            }
        } else {
            const errorText = await monthlyResponse.text();
            console.log(` API FAILED: customer-monthly-sessions for ${customerName} - ${monthlyResponse.status}: ${errorText}`);
        }
        
        // THIRD: Get network sessions with dates as fallback
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
        
    } catch (error) {
        console.error(` Error fetching REAL monthly runs for ${customerName}:`, error);
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
    }
    
    return monthlyRuns;
}

// FALLBACK: Get real monthly data using existing APIs with date filtering
async function fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate = null, endDate = null) {
    try {
        console.log(` Fallback: Getting session dates for ${customerName} from database`);
        console.log(` Fallback date filter: ${startDate} to ${endDate}`);
        
        // Try to get network IDs for this customer first
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            console.log(` Found networks for ${customerName}:`, networksData);
            
            if (networksData.networks && networksData.networks.length > 0) {
                // For each network, get real sessions and their dates
                for (const network of networksData.networks) {
                    const networkId = network.id;
                    console.log(` Getting real sessions for network ID: ${networkId}`);
                    
                    // Get actual sessions for this network
                    const sessionsResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: parseInt(networkId),
                            include_dates: true
                        })
                    });
                    
                    if (sessionsResponse.ok) {
                        const sessionData = await sessionsResponse.json();
                        console.log(` Real sessions for network ${networkId}:`, sessionData);
                        
                        // If we have session dates, use them for monthly distribution
                        if (sessionData.recent_sessions && sessionData.recent_sessions.length > 0) {
                            console.log(` Processing ${sessionData.recent_sessions.length} real sessions...`);
                            
                            sessionData.recent_sessions.forEach(session => {
                                // Use universal date fix function
                                const sessionDate = fixDateParsing(session.created_at);
                                
                                if (sessionDate) {
                                    const sessionMonth = sessionDate.getMonth() + 1;
                                    const sessionYear = sessionDate.getFullYear();
                                    const sessionDay = sessionDate.getDate();
                                    
                                    console.log(` SESSION: "${session.created_at}" -> Month: ${sessionMonth}, Day: ${sessionDay}, Year: ${sessionYear}`);
                                    
                                    if (sessionYear === year) {
                                        monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                                        console.log(` Added 1 run to month ${sessionMonth} from session on ${sessionDate.toDateString()} (Day: ${sessionDay})`);
                                    }
                                }
                            });
                        }
                    }
                }
                
                console.log(` Final real monthly distribution for ${customerName}:`, monthlyRuns);
                return;
            }
        }
        
        console.log(` Could not get network data for ${customerName}, using basic fallback`);
        
        // ENHANCED: Only use real dates, no fallback to current month
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const data = await customerResponse.json();
            const customerData = data.customers[customerName];
            
            if (customerData && customerData.runs > 0) {
                // ONLY assign runs if we have an actual last_run_date from the API
                if (customerData.last_run_date && customerData.last_run_date !== 'Never' && customerData.last_run_date !== '-') {
                    const actualDate = fixDateParsing(customerData.last_run_date);
                    if (actualDate && actualDate.getFullYear() === year) {
                        const actualMonth = actualDate.getMonth() + 1;
                        monthlyRuns[actualMonth] = customerData.runs;
                        console.log(` Using REAL date from API: assigned ${customerData.runs} runs to month ${actualMonth} based on actual date ${customerData.last_run_date}`);
                    } else {
                        console.log(` Customer ${customerName} has runs but date is from different year or invalid: ${customerData.last_run_date}`);
                    }
                } else {
                    console.log(` Customer ${customerName} has ${customerData.runs} runs but NO valid last_run_date - not assigning to any month`);
                }
            }
        }
        
    } catch (error) {
        console.error(` Error in real monthly data fallback:`, error);
    }
}

function setDefaultFilterDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    // Set default dates for customer overview filter (but don't apply them automatically)
    const customerStartInput = document.getElementById('customer-start-date');
    const customerEndInput = document.getElementById('customer-end-date');
    
    if (customerStartInput && customerEndInput) {
        customerEndInput.value = today.toISOString().split('T')[0];
        customerStartInput.value = firstDayOfMonth.toISOString().split('T')[0];
    }
    
    // FILTER FIX: Don't automatically set filter dates - let user apply them
    // currentStartDate = firstDayOfMonth.toISOString().split('T')[0];
    // currentEndDate = today.toISOString().split('T')[0];
}

// Duplicate function removed - using the one defined later

// Duplicate function removed - using the one defined later


// INTEGRATED: Load dashboard data from DATABASE + EXCEL SOURCES
// Helper function to generate hash codes for network IDs
String.prototype.hashCode = function() {
    var hash = 0;
    if (this.length === 0) return hash;
    for (var i = 0; i < this.length; i++) {
        var char = this.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
};

async function loadDashboardData(startDate = null, endDate = null) {
    console.log(' Loading DATABASE + EXCEL CUSTOMERS (Integrated)...');
    
    // CRITICAL FIX: Use current filter dates if no parameters provided
    if (!startDate && !endDate && (currentStartDate || currentEndDate)) {
        startDate = currentStartDate;
        endDate = currentEndDate;
        console.log(` Using existing filter dates: ${startDate} to ${endDate}`);
    }
    
    // Store current filter dates for customer overview
    if (startDate && endDate) {
        console.log(` Applying date filter to customer data: ${startDate} to ${endDate}`);
        currentStartDate = startDate;
        currentEndDate = endDate;
    }
    
    // Check CSRF token first
    const csrfToken = getCsrfToken();
    if (!csrfToken) {
        console.error(' No CSRF token found!');
        showNotification(' Security error: Missing CSRF token. Please refresh the page.', 'error');
        return;
    }
    console.log(' CSRF token found:', csrfToken.substring(0, 10) + '...');
    
    try {
        console.log(' CALLING DATABASE CUSTOMERS API ONLY...');
        
        // DATABASE ONLY: Load customers from database API with date filtering
        let apiUrl = '/api/customer-dashboard/customers/';
        
        // Add date filtering parameters if provided
        if (startDate || endDate) {
            const params = new URLSearchParams();
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            apiUrl += '?' + params.toString();
            console.log(' Added date filters to API URL:', apiUrl);
        }
        
        console.log(' DASHBOARD API REQUEST WITH FILTERS:', apiUrl);
        console.log(' Making API call with dates:', { startDate, endDate });
        
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (!response) {
            throw new Error('API call returned no response');
        }
        
        console.log(' SIMPLE API Response Status:', response.status);
        
        // Headers logging removed to prevent errors
        console.log(' Response received, checking status...');
        
        if (response && response.ok) {
            console.log(' API Response OK - parsing JSON...');
            let data;
            try {
                data = await response.json();
            } catch (jsonError) {
                console.error(' JSON Parse Error:', jsonError);
                throw new Error(`Failed to parse API response as JSON: ${jsonError.message}`);
            }
            console.log(' SIMPLE API Response Data:', data);
            console.log(' Data structure:', {
                hasStatus: !!data.status,
                status: data.status,
                hasCustomers: !!data.customers,
                customersCount: data.customers ? Object.keys(data.customers).length : 0,
                customersKeys: data.customers ? Object.keys(data.customers) : 'no customers'
            });
            
            // Check if we have customers data
            if (data.status === 'success' && data.customers) {
                console.log(' SUCCESS: Got DATABASE CUSTOMERS from API:', Object.keys(data.customers));
                console.log(' EXCEL DISABLED - Only showing database customers');
                
                // ULTRA STRICT FILTERING - Block ALL Unknown Customers completely
                const filteredCustomers = {};
                console.log(' STARTING FILTER PROCESS - Checking all customers...');
                Object.entries(data.customers).forEach(([customerName, customerData]) => {
                    console.log(` CHECKING: ${customerName}`);
                    
                // MODERATE FILTERING - Block only obvious fake entries
                if (customerName.toLowerCase().includes('unknown') ||
                    customerName.toLowerCase().includes('timedotcom') ||
                    customerName.toLowerCase().includes('default') ||
                    customerName === 'Default' ||
                    customerName === 'Timedotcom' ||
                    customerName === 'Timedotcom Default' ||
                    customerName === 'Unknown Customer' ||
                    customerName.startsWith('Unknown') ||
                    customerName.trim().length <= 2) {
                    console.log(` BLOCKED Fake/Unknown: ${customerName}`);
                    return; // Exit immediately
                }
                    
                    // SIMPLE CHECK - Allow any customer with some data
                    const hasData = (customerData.runs && customerData.runs > 0) ||
                                   (customerData.total_runs && customerData.total_runs > 0) ||
                                   (customerData.networks && customerData.networks.length > 0);
                    
                    // Keep all customers that have some data (including new ones)
                    filteredCustomers[customerName] = customerData;
                    console.log(` KEEPING DB Customer: ${customerName} - Runs: ${customerData.runs || customerData.total_runs || 0}, Networks: ${customerData.networks?.length || 0}`);
                    
                    if (!hasData) {
                        console.log(` Note: ${customerName} has no run data yet`);
                    }
                });
                
                console.log(` FINAL FILTERED RESULTS: ${Object.keys(filteredCustomers).length} real DB customers (blocked all Unknown entries)`);
                console.log(` REAL CUSTOMERS FOUND:`, Object.keys(filteredCustomers));
                
                if (Object.keys(filteredCustomers).length === 0) {
                    console.log(' NO REAL CUSTOMERS FOUND - Only Unknown entries were available');
                }
                
                // Store filtered customer data
                dashboardData.customers = filteredCustomers;
                
                // Calculate statistics from FILTERED customer data - GROUP BY CUSTOMER NAME to avoid duplicate counting
                let customerCount = 0;
                let totalRuns = 0;
                let totalTrackers = 0;
                
                // CORRECTED LOGIC: Group customers by name to avoid duplicate counting
                const customerGroups = {};
                
                Object.entries(filteredCustomers).forEach(([customerKey, customer]) => {
                    // Only count Live DB customers in statistics - skip Excel customers
                    if (customer.excel_source || customer.excel_only || customer.excel_data) {
                        console.log(` EXCLUDING from stats: Excel customer ${customer.name}`);
                        return; // Skip Excel customers from statistics
                    }
                    
                    const customerName = customer.name || customer.Customer || customerKey.split('_')[0];
                    
                    // Skip if we already counted this customer
                    if (customerGroups[customerName]) {
                        console.log(` Skipping duplicate customer: ${customerName} (already counted)`);
                        return;
                    }
                    
                    // Mark this customer as counted
                    customerGroups[customerName] = true;
                    customerCount++;
                    
                    // Calculate total runs for this customer properly
                    let customerTotalRuns = 0;
                    
                    // Method 1: Check if customer has networks array (preferred)
                    if (customer.networks && Array.isArray(customer.networks)) {
                        customer.networks.forEach(network => {
                            const networkRuns = parseInt(network.runs || network.total_runs || 0);
                            customerTotalRuns += networkRuns;
                        });
                        console.log(`    Customer ${customerName}: ${customerTotalRuns} runs from ${customer.networks.length} networks`);
                    } else {
                        // Method 2: Use customer-level runs (fallback)
                        customerTotalRuns = parseInt(customer.runs || customer.total_runs || customer.run_count || 0);
                        console.log(`    Customer ${customerName}: ${customerTotalRuns} runs (customer-level)`);
                    }
                    
                    totalRuns += customerTotalRuns;
                    totalTrackers += parseInt(customer.trackers_generated || customer.total_trackers || customer.trackers || 0);
                    
                    console.log(` COUNTED Customer: ${customerName} = ${customerTotalRuns} runs`);
                    console.log(`    Running total so far: ${totalRuns} runs`);
                });
                
                console.log(` DATABASE STATS: ${customerCount} customers, ${totalRuns} runs, ${totalTrackers} trackers`);
                console.log(` FINAL SUMMARY:`);
                console.log(`   Live DB Customers: ${customerCount}`);
                console.log(`   Total Runs Calculated: ${totalRuns}`);
                console.log(`   Total Trackers: ${totalTrackers}`);
                console.log(` Statistics that will show in dashboard header: Customers=${customerCount}, Runs=${totalRuns}, Trackers=${totalTrackers}`);
                
                // STEP 2: Load and integrate Excel customers
                console.log(' NOW LOADING EXCEL CUSTOMERS...');
                try {
                    // Pass date filters to Excel API (same as DB API)
                    let excelApiUrl = '/customer-dashboard/excel/';
                    if (startDate && endDate) {
                        const params = new URLSearchParams();
                        params.append('start_date', startDate);
                        params.append('end_date', endDate);
                        excelApiUrl += '?' + params.toString();
                        console.log(` Excel API with filters: ${excelApiUrl}`);
                    }
                    
                    const excelResponse = await fetch(excelApiUrl, {
                        method: 'GET',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (excelResponse.ok) {
                        const excelData = await excelResponse.json();
                        console.log(' Excel response received:', Object.keys(excelData));
                        
                        // Extract Excel customers from response
                        let excelCustomers = {};
                        if (excelData.data && excelData.data.customers) {
                            excelCustomers = excelData.data.customers;
                        } else if (excelData.customers) {
                            excelCustomers = excelData.customers;
                        }
                        
                        if (Object.keys(excelCustomers).length > 0) {
                            console.log(` Found ${Object.keys(excelCustomers).length} Excel entries:`, Object.keys(excelCustomers));
                            console.log(` Excel date filter: ${startDate} to ${endDate || 'No end date'}`);
                            
                            // DEBUG TATA: Check all Excel customers
                            console.log(` Checking for TATA in Excel data...`);
                            Object.entries(excelCustomers).forEach(([key, customer]) => {
                                if (customer.Customer && customer.Customer.toLowerCase().includes('tata')) {
                                    console.log(` FOUND TATA: ${key} -> Customer: ${customer.Customer}, Network: ${customer.Network}`);
                                }
                            });
                            
                            // GROUPING - Group Excel by Customer name with Networks as sub-parts
                            console.log(` Grouping Excel customers by Customer name (like database structure)...`);
                            
                            // Step 1: Group Excel entries by Customer name
                            const customerGroups = {};
                            Object.values(excelCustomers).forEach((excelEntry) => {
                                const customerName = excelEntry.Customer || 'Unknown';
                                const networkName = excelEntry.Network || excelEntry.network || `${customerName}_Network`;
                                
                                if (!customerGroups[customerName]) {
                                    customerGroups[customerName] = {
                                        customerName: customerName,
                                        networks: [],
                                        country: excelEntry.Country || excelEntry.country || '',
                                        ne_type: excelEntry['NE Type'] || excelEntry.ne_type || '1830 PSS',
                                        gtac: excelEntry.gTAC || excelEntry.gtac || 'PSS'
                                    };
                                }
                                
                                // Add this network entry to the customer group
                                customerGroups[customerName].networks.push({
                                    ...excelEntry,
                                    networkName: networkName
                                });
                            });
                            
                            console.log(` Grouped ${Object.keys(excelCustomers).length} Excel entries into ${Object.keys(customerGroups).length} customers`);
                            
                            // Step 2: Process each customer group (like database customers)
                            Object.values(customerGroups).forEach((group) => {
                                const customerName = group.customerName;
                                const networkEntries = group.networks;
                                console.log(`\n Processing Excel customer: ${customerName} with ${networkEntries.length} networks`);
                                
                                  // BLOCK FAKE ENTRIES - OPT_NC REMOVED (it's a real customer)
                                  if (customerName === 'He' || customerName === 'KYUUII' || 
                                      customerName === 'subu-east' ||
                                      customerName === 'Bsnl' || customerName.toLowerCase().includes('unknown')) {
                                      console.log(`    Blocking fake Excel customer: ${customerName}`);
                                      return;
                                  }
                                
                                // Apply DATE FILTERING to customer group
                                if (startDate && endDate) {
                                    const filterStart = new Date(startDate).getMonth() + 1; 
                                    const filterEnd = new Date(endDate).getMonth() + 1;
                                    
                                    console.log(`    Checking Excel customer date filter: months ${filterStart}-${filterEnd}`);
                                    
                                    // Check if ANY network in this customer has data in filter range
                                    const hasDataInRange = networkEntries.some(networkEntry => {
                                        const months = networkEntry.months || [];
                                        return months.some((monthValue, index) => {
                                            const monthNum = index + 1;
                                            const hasValidData = monthValue && monthValue !== '-' && monthValue !== 'Not Started' && monthValue !== 'Not Run';
                                            const inRange = monthNum >= filterStart && monthNum <= filterEnd;
                                            if (hasValidData && inRange) {
                                                console.log(`      Network ${networkEntry.networkName} has data in month ${monthNum} (${monthValue})`);
                                            }
                                            return hasValidData && inRange;
                                        });
                                    });
                                    
                                    if (!hasDataInRange) {
                                        console.log(`    Excel customer filtered out: ${customerName} (no networks have data in selected date range)`);
                                        return; // Skip this customer group
                                    }
                                    console.log(`    Excel customer passes date filter: ${customerName}`);
                                }
                                
                                // Create Excel customer with networks as sub-parts (like database structure)
                                const excelCustomerKey = customerName + "_excel_" + Date.now();
                                console.log(`    Creating grouped Excel customer: ${customerName} with ${networkEntries.length} networks`);
                                
                                // Step 3: Create networks array from all network entries in this customer group
                                let networks = [];
                                let customerTotalRuns = 0;
                                let customerTotalNodes = 0;
                                
                                networkEntries.forEach((networkEntry, index) => {
                                    const networkName = networkEntry.networkName;
                                    console.log(`      Processing network: ${networkName}`);
                                    
                    // Clean up monthly data and fix typos
                    let monthlyRuns = (networkEntry.months || []).map(m => {
                        if (typeof m === 'string') {
                            return m.replace('Not Starte', 'Not Started')
                                    .replace('No Repor', 'No Report')
                                    .replace('No Reportt', 'No Report'); // Fix double 't' typo
                        }
                        return m;
                    });
                    
                    // BSNL specific: Replace Not Started and No Report with dash
                    if (customerName === 'BSNL' || customerName === 'Bsnl') {
                        monthlyRuns = monthlyRuns.map(m => {
                            if (m === 'Not Started' || m === 'No Report') {
                                return '-';
                            }
                            return m;
                        });
                        console.log(`      BSNL: Replaced Not Started/No Report with dash`);
                    }
                                    
                                    // Calculate filtered runs for this network
                                    let networkTotalRuns;
                                    if (startDate && endDate) {
                                        const filterStart = new Date(startDate).getMonth() + 1;
                                        const filterEnd = new Date(endDate).getMonth() + 1;
                                        
                                        networkTotalRuns = monthlyRuns.filter((m, monthIndex) => {
                                            const monthNum = monthIndex + 1;
                                            const hasValidData = m && m !== '-' && 
                                                                m !== 'Not Run' && m !== 'Not Started' && 
                                                                m !== 'No Report' &&
                                                                (m.includes('-') && !m.toLowerCase().includes('not'));
                                            const inRange = monthNum >= filterStart && monthNum <= filterEnd;
                                            return hasValidData && inRange;
                                        }).length;
                                    } else {
                                        networkTotalRuns = monthlyRuns.filter(m => 
                                            m && m !== '-' && 
                                            m !== 'Not Run' && m !== 'Not Started' && 
                                            m !== 'No Report' &&
                                            (m.includes('-') && !m.toLowerCase().includes('not'))
                                        ).length;
                                    }
                                    
                                    const lastRunDate = monthlyRuns.find(m => m !== '-' && m !== 'Not Started') ? 'Recent' : 'Not Started';
                                    const nodeCount = networkEntry['Node Qty'] || networkEntry.node_qty || 0;
                                    
                                    // Add to customer totals
                                    customerTotalRuns += networkTotalRuns;
                                    customerTotalNodes += nodeCount;
                                    
                                    // Create network object (sub-part of customer)
                                    networks.push({
                                        id: (customerName + networkName).hashCode() % 10000,
                                        name: networkName,
                                        network_name: networkName,
                                        Network: networkName,
                                        runs: networkTotalRuns,
                                        total_runs: networkTotalRuns,
                                        last_run_date: lastRunDate,
                                        node_count: nodeCount,
                                        months: monthlyRuns,
                                        monthly_runs: monthlyRuns,
                                        ne_type: networkEntry['NE Type'] || networkEntry.ne_type || '1830 PSS',
                                        gtac: networkEntry.gTAC || networkEntry.gtac || 'PSS',
                                        country: networkEntry.Country || networkEntry.country || group.country,
                                        status: networkTotalRuns > 0 ? 'completed' : 'not started'
                                    });
                                    
                                    console.log(`      Created network: ${networkName} - Runs: ${networkTotalRuns}, Nodes: ${nodeCount}`);
                                });
                                
                                console.log(`    Customer totals: ${customerTotalRuns} runs, ${customerTotalNodes} nodes from ${networks.length} networks`);
                                
                                
                                // Create grouped Excel customer with SAME FORMAT as DB customers
                                filteredCustomers[excelCustomerKey] = {
                                    // Basic info - SAME AS DB FORMAT
                                    name: customerName,
                                    customer_name: customerName,
                                    
                                    // Run data - AGGREGATED FROM ALL NETWORKS
                                    runs: customerTotalRuns,
                                    total_runs: customerTotalRuns,
                                    run_count: customerTotalRuns,
                                    
                                    // Date info - Use most recent from networks
                                    last_run_date: networks.find(n => n.last_run_date !== 'Not Started')?.last_run_date || 'Never',
                                    actual_last_run: null,
                                    first_run_date: null,
                                    
                                    // Location - Use group data
                                    country: group.country,
                                    location: group.country,
                                    region: '-',
                                    
                                    // Node info - AGGREGATED FROM ALL NETWORKS
                                    node_count: customerTotalNodes,
                                    node_qty: customerTotalNodes,
                                    total_nodes: customerTotalNodes,
                                    nodes: customerTotalNodes,
                                    
                                    // Technical specs - Use group data
                                    ne_type: group.ne_type,
                                    nw_type: group.ne_type,
                                    network_type: group.ne_type,
                                    technology: group.ne_type,
                                    
                                    // GTAC info - Use group data
                                    gtac: group.gtac,
                                    gtac_team: group.gtac,
                                    gtac_type: group.gtac,
                                    
                                    // Networks - MOST IMPORTANT - CONTAINS ALL SUB-NETWORKS
                                    networks: networks,
                                    networks_count: networks.length,
                                    network_count: networks.length,
                                    
                                    // Network-level data - AGGREGATED
                                    network_runs: {},
                                    network_monthly_runs: {},
                                    
                                    // Monthly data - AGGREGATED FROM NETWORKS
                                    monthly_runs: {},
                                    monthly_data: {},
                                    
                                    // Status info - Based on network aggregation
                                    status: networks.every(n => n.runs > 0) ? 'completed' : (networks.some(n => n.runs > 0) ? 'partial' : 'not started'),
                                    active: true,
                                    enabled: true,
                                    
                                    // Trackers - Based on total nodes
                                    trackers_generated: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    trackers: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    total_trackers: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    
                                    // Source flags - TO DISTINGUISH FROM DB
                                    excel_only: true,
                                    excel_source: true,
                                    excel_data: true,
                                    data_source: 'excel'
                                };
                                    
                                console.log(`    Grouped Excel customer created: ${customerName}`);
                                console.log(`     Networks (${networks.length}):`);
                                networks.forEach((net, i) => {
                                    console.log(`       ${i+1}. ${net.name} - Runs: ${net.runs} - Nodes: ${net.node_count} - Status: ${net.status}`);
                                });
                                console.log(`     Total: ${customerTotalRuns} runs, ${customerTotalNodes} nodes`);
                                console.log(`     Customer Status: ${filteredCustomers[excelCustomerKey].status}`);
                                
                                // Since we're hiding Excel customers completely, don't count them in statistics
                                // customerCount++; // Excel customers are hidden from UI and statistics
                                // totalRuns += customerTotalRuns; // Excel runs not counted
                                // totalTrackers += Math.max(1, Math.ceil(customerTotalNodes / 10)); // Excel trackers not counted
                            });
                            
                console.log(`\n FINAL STATS: ${customerCount} Live DB customers only (Excel customers hidden), ${totalRuns} runs, ${totalTrackers} trackers`);
                        } else {
                            console.log(' No Excel customers found in response');
                        }
                    } else {
                        console.log(' Excel API response failed:', excelResponse.status);
                    }
                } catch (excelError) {
                    console.error(' Excel integration error:', excelError);
                    console.log(' Continuing with database-only data');
                }
                
                // Update final data with DB + Excel customers kept separate
                dashboardData.customers = filteredCustomers;
                
                // Store calculated statistics with all customers
                dashboardData.statistics = {
                    total_customers: customerCount,
                    total_runs: totalRuns,
                    total_trackers: totalTrackers,
                    current_month_runs: 0,
                    filtered_runs: totalRuns
                };
                
                console.log(' Final integrated statistics:', dashboardData.statistics);
                console.log(' Filtered customers loaded:', Object.keys(filteredCustomers).length);
                
                // Update all dashboard components
                updateDashboard();
                
                // FORCE UPDATE TABLE - Make sure filtered data shows
                setTimeout(() => {
                    console.log(' Force updating customer table with filtered data...');
                    updateCustomerGrid();
                }, 100);
                
        //  CLEAR ALL EDIT DATA ON FRESH DASHBOARD LOAD
        clearAllEditData();
        console.log(' All edit data cleared for fresh dashboard load');
        console.log(' New edits will be stored and applied individually');
                
                hideLoadingState();
                
                const sourceMsg = ' (Live DB customers only - Excel customers hidden)';
                const filterMsg = startDate && endDate ? ` (filtered: ${startDate} to ${endDate})` : '';
                showNotification(` Loaded ${customerCount} customers, ${totalRuns} runs${sourceMsg}${filterMsg}`, 'success');
                return;
            } else {
                console.log(' API returned success but no customer data');
                console.log(' Trying fallback: load without filters...');
                
                // Fallback: try loading without filters if filtered request has no data
                const fallbackResponse = await fetch('/api/customer-dashboard/customers/', {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                
                if (fallbackResponse.ok) {
                    const fallbackData = await fallbackResponse.json();
                    if (fallbackData.status === 'success' && fallbackData.customers) {
                        console.log(' Fallback successful - using unfiltered data');
                        dashboardData.customers = fallbackData.customers;
                        updateDashboard();
                        showNotification(' No data in selected date range. Showing all data.', 'warning');
                        return;
                    }
                }
            }
        } else {
            // Handle non-OK response
            let errorText = 'Unknown error';
            try {
                errorText = await response.text();
            } catch (e) {
                console.error(' Could not read error response:', e);
            }
            console.error(' API Error Response:', {
                status: response.status,
                statusText: response.statusText,
                errorText: errorText.substring(0, 300)
            });
            throw new Error(`API returned ${response.status}: ${response.statusText}`);
        }
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(' API Error Details:', {
                status: response.status,
                statusText: response.statusText,
                url: apiUrl,
                responseText: errorText.substring(0, 500) + (errorText.length > 500 ? '...' : '')
            });
            throw new Error(`API failed (${response.status}): ${response.statusText}. ${errorText}`);
        }
        
        // Parse the response - it might be JSON data or an Excel file
        let dashboardDataFromExcelAPI;
        
        const contentType = response.headers.get('content-type');
        console.log(' Response Content-Type:', contentType);
        
        if (contentType && contentType.includes('application/json')) {
            // Perfect! Got JSON data with the same processing as Excel export
            dashboardDataFromExcelAPI = await response.json();
            console.log(' EXCEL API JSON Response:', dashboardDataFromExcelAPI);
        } else {
            // If we get Excel file, we need to use the regular API but with Excel-compatible parameters
            console.log(' Got Excel file instead of JSON, falling back to regular API with Excel-compatible request...');
            
            // Try the CORRECT API endpoint for customer dashboard with date filtering
            let fallbackApiUrl = '/api/customer-dashboard/customers/';
            if (startDate || endDate) {
                const params = new URLSearchParams();
                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                fallbackApiUrl += '?' + params.toString();
            }
            
            const fallbackResponse = await fetch(fallbackApiUrl, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'same-origin'
            });
            
            console.log(' CALLING CORRECT API: /api/customer-dashboard/customers/');
            console.log(' Response status:', fallbackResponse.status);
            
            if (fallbackResponse.ok) {
                const customersData = await fallbackResponse.json();
                console.log(' Customer Dashboard API Response:', customersData);
                
                // Get statistics too
                const statsResponse = await fetch('/api/dashboard/statistics/', {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/json',
                        'X-Excel-Compatible': 'true'
                    },
                    credentials: 'same-origin'
                });
                
                const statsData = statsResponse.ok ? await statsResponse.json() : {};
                
                dashboardDataFromExcelAPI = {
                    customers: customersData.customers || {},
                    statistics: statsData
                };
            } else {
                throw new Error('Both Excel API and fallback API failed');
            }
        }
        
        
        // Process the data from Excel API (which should have correct dates)
        console.log(' Processing Excel API data with REAL dates...');
        
        const processedCustomers = {};
        const customers = dashboardDataFromExcelAPI.customers || dashboardDataFromExcelAPI.data?.customers || {};
        
        console.log(' Raw customers from Excel API:', customers);
        
        // Process each customer with Excel API data structure
        for (const [customerName, customerData] of Object.entries(customers)) {
            console.log(` Processing ${customerName} from API data...`);
            console.log(` RAW DATA for ${customerName}:`, customerData);
            console.log(` Fields available:`, Object.keys(customerData));
            console.log(` node_count = ${customerData.node_count}, country = ${customerData.country}`);
            
            processedCustomers[customerName] = {
                ...customerData,
                // Ensure we preserve the monthly data with actual dates
                monthly_runs: customerData.monthly_runs || {},
                // Preserve network-level data
                network_runs: customerData.network_runs || {},
                network_monthly_runs: customerData.network_monthly_runs || {},
                // Use the actual date fields from Excel API
                last_run_date: customerData.last_run_date || customerData.actual_last_run || 'Never',
                actual_last_run: customerData.actual_last_run || customerData.last_run_date
            };
            
            console.log(` Processed ${customerName}:`, {
                runs: processedCustomers[customerName].runs,
                last_run_date: processedCustomers[customerName].last_run_date,
                monthly_runs: processedCustomers[customerName].monthly_runs
            });
        }
        
        // Use the processed data from Excel API
        dashboardData.customers = processedCustomers;
        dashboardData.statistics = {
            total_customers: dashboardDataFromExcelAPI.statistics?.total_customers || Object.keys(processedCustomers).length,
            total_runs: dashboardDataFromExcelAPI.statistics?.total_runs || 0,
            total_trackers: dashboardDataFromExcelAPI.statistics?.total_trackers || 0,
            current_month_runs: dashboardDataFromExcelAPI.statistics?.current_month_runs || 0,
            filtered_runs: dashboardDataFromExcelAPI.statistics?.filtered_runs || 0
        };
        
        console.log(' Successfully loaded data using Excel API method:', {
            customersCount: Object.keys(processedCustomers).length,
            totalCustomers: dashboardData.statistics.total_customers,
            totalRuns: dashboardData.statistics.total_runs,
            sampleCustomer: Object.keys(processedCustomers)[0] ? processedCustomers[Object.keys(processedCustomers)[0]] : 'None'
        });
        
        updateDashboard();
        
        // Show appropriate message based on data
        if (statsData.total_customers === 0) {
            showNotification(' No customers found in database. Add customers to see live statistics.', 'info');
        } else {
            const filterMsg = startDate && endDate ? ` (filtered: ${startDate} to ${endDate})` : '';
            showNotification(` Dashboard loaded: ${statsData.total_customers} customers, ${statsData.total_runs} runs${filterMsg}`, 'success');
        }
        
    } catch (error) {
        console.error(' Dashboard loading error:', error);
        console.error(' Error stack:', error.stack);
        console.error(' Error details:', {
            message: error.message,
            name: error.name,
            cause: error.cause
        });
        
        hideLoadingState();
        
        // Show detailed error in table for debugging
        const tableBody = document.getElementById('customer-table-body');
        if (tableBody) {
            tableBody.innerHTML = `<tr><td colspan="19" style="padding: 40px; text-align: center; color: #ef4444;">
                 API Error: ${error.message}<br><br>
                Filter dates: ${startDate || 'none'} to ${endDate || 'none'}<br>
                Check browser console for details<br><br>
                <button onclick="loadDashboardData()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry</button>
            </td></tr>`;
        }
        
        showNotification(` API Error: ${error.message}`, 'error');
    }
}

// LOAD REAL DATA DIRECTLY FROM YOUR DATABASE
async function loadRealDatabaseData() {
    console.log(' Loading REAL data from your database...');
    
    try {
        // Try multiple API endpoints to get your real data
        const endpoints = [
            '/api/customer-dashboard/customers/',
            '/api/dashboard/statistics/',
            '/api/run-statistics/',
            '/get-customer-networks/1/' // Try to get data from first customer
        ];
        
        // Test each endpoint
        for (const endpoint of endpoints) {
            try {
                console.log(` Trying endpoint: ${endpoint}`);
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': getCsrfToken(),
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(` Success from ${endpoint}:`, data);
                    
                    // If we got customers data, use it
                    if (data.customers) {
                        dashboardData.customers = data.customers;
                    }
                    
                    // If we got statistics, use them
                    if (data.total_customers !== undefined) {
                        dashboardData.statistics = {
                            total_customers: data.total_customers || 0,
                            total_runs: data.total_runs || 0,
                            total_trackers: data.total_trackers || 0,
                            current_month_runs: data.current_month_runs || 0,
                            filtered_runs: data.current_month_runs || 0
                        };
                    }
                } else {
                    console.log(` ${endpoint} returned ${response.status}`);
                }
            } catch (endpointError) {
                console.log(` ${endpoint} failed:`, endpointError.message);
            }
        }
        
        // If we have any data, show it
        if (Object.keys(dashboardData.customers).length > 0 || dashboardData.statistics.total_customers > 0) {
            updateDashboard();
            showNotification(' Dashboard loaded with REAL database data!', 'success');
        } else {
            // Try one more direct approach - load page data
            await loadFromPageContext();
        }
        
    } catch (error) {
        console.error(' Real data loading failed:', error);
        await loadFromPageContext();
    }
}

// FALLBACK: Try to load data from page context - only use REAL data
async function loadFromPageContext() {
    console.log(' Fallback: Trying to get REAL data from any available source...');
    
    // Try direct API calls to get REAL data
    try {
        const csrfToken = getCsrfToken();
        
        // Try the statistics API first
        const statsResponse = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (statsResponse.ok) {
            const statsData = await statsResponse.json();
            console.log(' Got REAL statistics from API:', statsData);
            
            dashboardData.statistics = {
                total_customers: statsData.total_customers || 0,
                total_runs: statsData.total_runs || 0,
                total_trackers: statsData.total_trackers || 0,
                current_month_runs: statsData.current_month_runs || 0,
                filtered_runs: statsData.current_month_runs || 0
            };
            
            updateDashboard();
            showNotification(' Loaded REAL data from statistics API', 'success');
            return;
        }
        
        console.log(' Statistics API not available, showing loading state');
        
    } catch (error) {
        console.error(' Error in fallback data loading:', error);
    }
    
    // If no real data available, show loading state instead of fake data
    dashboardData.statistics = {
        total_customers: 0,
        total_runs: 0,
        total_trackers: 0,
        current_month_runs: 0,
        filtered_runs: 0
    };
    
    dashboardData.customers = {};
    
    updateDashboard();
    showNotification(' No real data available. Please check API endpoints and database connection.', 'warning');
}

// SHOW LOADING STATE DURING API CALLS
function showLoadingState() {
    // Show loading indicators in statistics
    const loadingHTML = '<div class="spinner"></div>';
    document.getElementById('header-total-customers').innerHTML = loadingHTML;
    document.getElementById('header-total-runs').innerHTML = loadingHTML;
    document.getElementById('header-total-trackers').innerHTML = loadingHTML;
    document.getElementById('customer-count').textContent = 'Loading data...';
    
    // Show loading messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer data...</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading tracking graph...</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer chart...</div>';
}

// HIDE LOADING STATE - STOPS LOADING SPINNERS
function hideLoadingState() {
    console.log(' Hiding loading state');
    // Note: The actual content will be populated by updateDashboard() functions
    // This function ensures the loading state is properly cleared
}

// SHOW ERROR STATE WHEN API FAILS
function showErrorState() {
    // Clear all statistics
    document.getElementById('header-total-customers').textContent = '--';
    document.getElementById('header-total-runs').textContent = '--';
    document.getElementById('header-total-trackers').textContent = '--';
    document.getElementById('customer-count').textContent = 'Unable to load data';
    
    // Show error messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;"> Unable to connect to database.<br><br>Please check your connection and refresh the page.</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;"> Unable to load tracking data.<br><br>Please refresh the page to try again.</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;"> Unable to load customer data.<br><br>Please refresh the page to try again.</div>';
}

// UPDATE DASHBOARD
function updateDashboard() {
    console.log(' Updating dashboard components...');
    
    updateStatistics();
    updateCustomerGrid();
    updateTrackingGraph();
    updateCustomerMonthChart();
    
    // FORCE UPDATE DUAL CHARTS AFTER DATA REFRESH
    setTimeout(() => {
        console.log(' Force updating dual charts after dashboard refresh...');
        if (typeof updateActivityChart === 'function') {
            updateActivityChart();
        }
        if (typeof updateCurrentMonthCustomerChart === 'function') {
            updateCurrentMonthCustomerChart();
        }
    }, 500); // Small delay to ensure data is loaded
    
    // DISABLED: checkDataIntegrationIssues() - can cause performance issues
    
    console.log(' Customer dashboard updated successfully');
}

// NEW DEBUG FUNCTION: Inspect customer data structure
function debugCustomerData(customerName) {
    const customers = dashboardData.customers;
    const customer = customers[customerName];
    
    if (!customer) {
        console.log(` Customer "${customerName}" not found. Available customers:`, Object.keys(customers));
        return;
    }
    
    console.log(` DEBUGGING CUSTOMER: ${customerName}`);
    console.log('='.repeat(50));
    console.log(`Basic Info:`, {
        name: customer.name,
        runs: customer.runs,
        run_count: customer.run_count,
        last_run_date: customer.last_run_date,
        actual_last_run: customer.actual_last_run
    });
    
    console.log(`Monthly Runs:`, customer.monthly_runs);
    console.log(`Network Runs:`, customer.network_runs);
    console.log(`Network Monthly Runs:`, customer.network_monthly_runs);
    console.log(`Networks:`, customer.networks);
    
    // Test date retrieval for each month
    console.log('\nMonth-by-month data:');
    for (let month = 1; month <= 12; month++) {
        const monthData = getCustomerMonthRunDates(customer, new Date().getFullYear(), month);
        if (monthData.count > 0) {
            console.log(`Month ${month}: ${monthData.count} runs, date: ${monthData.date}`);
        }
    }
    console.log('='.repeat(50));
}

// NEW: Test API endpoints directly
async function testCustomerAPIs(customerName) {
    const csrfToken = getCsrfToken();
    console.log(` TESTING APIs for: ${customerName}`);
    console.log('='.repeat(60));
    
    // Test 1: Customer monthly sessions
    try {
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear()
            })
        });
        
        if (monthlyResponse.ok) {
            const data = await monthlyResponse.json();
            console.log(` customer-monthly-sessions RESPONSE:`, data);
        } else {
            console.log(` customer-monthly-sessions FAILED: ${monthlyResponse.status}`);
        }
    } catch (error) {
        console.log(` customer-monthly-sessions ERROR:`, error);
    }
    
    // Test 2: Dashboard customers
    try {
        const customersResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customersResponse.ok) {
            const data = await customersResponse.json();
            if (data.customers && data.customers[customerName]) {
                console.log(` dashboard/customers RESPONSE for ${customerName}:`, data.customers[customerName]);
            } else {
                console.log(` dashboard/customers: Customer ${customerName} not found`);
                console.log(`Available customers:`, Object.keys(data.customers || {}));
            }
        } else {
            console.log(` dashboard/customers FAILED: ${customersResponse.status}`);
        }
    } catch (error) {
        console.log(` dashboard/customers ERROR:`, error);
    }
    
    // Test 3: Networks for customer
    try {
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const data = await networksResponse.json();
            console.log(` networks RESPONSE for ${customerName}:`, data);
        } else {
            console.log(` networks FAILED: ${networksResponse.status}`);
        }
    } catch (error) {
        console.log(` networks ERROR:`, error);
    }
    
    console.log('='.repeat(60));
}

// NEW: Manually refresh specific customers
async function refreshCustomers(customerNames) {
    console.log(` MANUALLY REFRESHING customers:`, customerNames);
    
    const csrfToken = getCsrfToken();
    const currentYear = new Date().getFullYear();
    
    for (const customerName of customerNames) {
        console.log(`\n Processing: ${customerName}`);
        
        try {
            // Get actual last run date
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            console.log(` Actual last run date for ${customerName}: ${actualLastRunDate}`);
            
            // Get monthly data
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken);
            console.log(` Monthly data for ${customerName}:`, monthlyData);
            
            // Update customer in dashboardData
            if (dashboardData.customers[customerName]) {
                dashboardData.customers[customerName].monthly_runs = monthlyData;
                dashboardData.customers[customerName].last_run_date = actualLastRunDate || dashboardData.customers[customerName].last_run_date;
                dashboardData.customers[customerName].actual_last_run = actualLastRunDate;
                
                console.log(` Updated ${customerName} with fresh data`);
            }
            
        } catch (error) {
            console.error(` Error refreshing ${customerName}:`, error);
        }
    }
    
    // Update the dashboard display
    updateCustomerGrid();
    console.log(` Dashboard updated with refreshed data`);
}

// NEW: Load data using exact Excel export method
async function loadDataUsingExcelMethod() {
    console.log(' LOADING DATA USING EXACT EXCEL EXPORT METHOD');
    const csrfToken = getCsrfToken();
    
    try {
        // Use the exact same API endpoint and parameters as exportToExcel()
        const formData = {
            start_date: currentStartDate || new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0],
            end_date: currentEndDate || new Date().toISOString().split('T')[0],
            export_type: 'all',
            current_filter_start: currentStartDate,
            current_filter_end: currentEndDate,
            format: 'json',  // Request JSON instead of Excel file
            dashboard_context: {
                current_year: new Date().getFullYear(),
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                include_run_dates: true,
                return_json: true  // Force JSON return
            }
        };
        
        console.log(' Excel method request:', formData);
        
        const response = await fetch('/api/customer-dashboard/export/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest',
                'Accept': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify(formData)
        });
        
        if (response.ok) {
            const contentType = response.headers.get('content-type');
            
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log(' Excel method returned JSON data:', data);
                
                // Process and update dashboard
                if (data.customers) {
                    dashboardData.customers = data.customers;
                    dashboardData.statistics = data.statistics || {};
                    updateDashboard();
                    console.log(' Dashboard updated with Excel method data!');
                    return true;
                }
            } else {
                console.log(' Excel method returned file, not JSON');
            }
        } else {
            console.log(` Excel method API failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error(' Excel method failed:', error);
    }
    
    return false;
}

// NEW: Force reload with Excel method
async function forceReloadWithExcelMethod() {
    console.log(' FORCE RELOADING WITH EXCEL METHOD...');
    showLoadingState();
    
    const success = await loadDataUsingExcelMethod();
    
    if (!success) {
        console.log(' Excel method failed, falling back to enhanced method...');
        await loadDashboardData(currentStartDate, currentEndDate);
    }
    
    showNotification(' Dashboard reloaded with Excel-compatible data', 'success');
}

// Expose debug functions to window for manual testing
window.debugCustomerData = debugCustomerData;
window.testCustomerAPIs = testCustomerAPIs;
window.refreshCustomers = refreshCustomers;
window.loadDataUsingExcelMethod = loadDataUsingExcelMethod;
window.forceReloadWithExcelMethod = forceReloadWithExcelMethod;

//  EXPOSE GRAPH UPDATE FUNCTIONS FOR TOOL EXECUTIONS
window.updateMonthlyRunsAfterTool = updateMonthlyRunsAfterTool;
window.updateGraphsAfterTool = function(customerName, networkName) {
    console.log(` MANUAL GRAPH UPDATE: ${customerName} - ${networkName}`);
    const currentDate = new Date().toISOString();
    updateMonthlyRunsAfterTool(customerName, networkName, currentDate);
};

//  AUTO-DETECT TOOL EXECUTIONS (when new tracker files are generated)
let lastTrackerCount = 0;
function checkForNewTrackers() {
    try {
        const statsElements = document.querySelectorAll('.stat-card');
        let currentTrackerCount = 0;
        
        // Try to get current tracker count from stats
        statsElements.forEach(element => {
            const text = element.textContent;
            if (text && text.includes('Tracker')) {
                const match = text.match(/\d+/);
                if (match) {
                    currentTrackerCount = parseInt(match[0]);
                }
            }
        });
        
        // If tracker count increased, graphs need update
        if (currentTrackerCount > lastTrackerCount && lastTrackerCount > 0) {
            console.log(` NEW TRACKER DETECTED! Count: ${lastTrackerCount} -> ${currentTrackerCount}`);
            console.log(` Updating graphs automatically...`);
            
            // Force graph update
            setTimeout(() => {
                updateTrackingGraphWithCurrentData();
                updateCustomerMonthChart();
                updateStatistics();
            }, 1000);
        }
        
        lastTrackerCount = currentTrackerCount;
    } catch (error) {
        // Silent fail
    }
}

// Auto-tracker detection removed

//  EASY TEST FUNCTION - Call this manually after running tools
window.testGraphUpdate = function(customerName = 'OPT_NC', networkName = 'OPT_NC') {
    console.log(` TESTING GRAPH UPDATE: ${customerName} - ${networkName}`);
    
    // Update with current date
    const currentDate = new Date();
    const formattedDate = `${String(currentDate.getDate()).padStart(2, '0')}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
    
    console.log(` Using current date: ${formattedDate}`);
    
    // Call the update function
    updateMonthlyRunsAfterTool(customerName, networkName, currentDate.toISOString());
    
    console.log(` Test completed! Check graphs for updates.`);
};

// Graph update functions available

// NEW FUNCTION: Check for common data integration issues
function checkDataIntegrationIssues() {
    const customers = dashboardData.customers;
    let issueCount = 0;
    
    Object.values(customers).forEach(customer => {
        // Skip Excel customers from data integration checks - only check Live DB customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        const hasValidDate = customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-';
        
        if (totalRuns > 0 && !hasValidDate) {
            console.log(` DATA INTEGRATION ISSUE: ${customer.name} has ${totalRuns} runs but no valid date`);
            issueCount++;
        }
        
        if (customer.data_integration_error) {
            console.log(` DATA INTEGRATION ERROR: ${customer.name} had errors during data loading`);
            issueCount++;
        }
    });
    
    if (issueCount > 0) {
        console.log(` SUMMARY: Found ${issueCount} data integration issues. Check console for details.`);
        showNotification(` Found ${issueCount} data integration issues. Check browser console for details.`, 'warning');
    } else {
        console.log(' No data integration issues detected.');
    }
}

// Function to animate header stats
function animateStatCard(type, targetValue, maxValue = 100) {
    const headerValue = document.getElementById(`header-total-${type}`);
    
    if (!headerValue) return;
    
    // Simple animation for header stats
    const duration = 1000; // 1 second
    const steps = 30;
    const stepTime = duration / steps;
    
    let currentStep = 0;
    
    const animate = () => {
        currentStep++;
        const progress = currentStep / steps;
        
        // Smooth ease-out
        const easedProgress = 1 - Math.pow(1 - progress, 2);
        
        // Calculate current value
        const currentValue = Math.round(targetValue * easedProgress);
        
        // Update header value
        headerValue.textContent = currentValue;
        
        // Continue animation
        if (currentStep < steps) {
            setTimeout(animate, stepTime);
        }
    };
    
    // Start animation
    animate();
}

function updateStatistics() {
    const stats = dashboardData.statistics;
    
    // Only update if we have valid statistics data (not null, not all zeros)
    if (!stats || (stats.total_customers === 0 && stats.total_runs === 0 && stats.total_trackers === 0)) {
        return; // Keep loading spinners active
    }
    
    // Only animate if we have real data
    animateStatCard('customers', stats.total_customers, Math.max(50, stats.total_customers || 50));
    animateStatCard('runs', stats.total_runs, Math.max(1000, stats.total_runs || 1000));
    animateStatCard('trackers', stats.total_trackers || 0, Math.max(500, stats.total_trackers || 0));
    
    console.log(' Statistics updated on page:', {
        customers: stats.total_customers || 0,
        runs: stats.total_runs || 0,
        trackers: stats.total_trackers || 0
    });
    
    // Update customer count with filter info - only count Live DB customers
    const allCustomers = Object.values(dashboardData.customers);
    const liveDbCustomerCount = allCustomers.filter(customer => 
        !customer.excel_source && !customer.excel_only && !customer.excel_data
    ).length;
    let customerCountText = `${liveDbCustomerCount} customers`;
    
    // Add filter info if dates are applied
    if (currentStartDate && currentEndDate) {
        const startDate = new Date(currentStartDate).toLocaleDateString();
        const endDate = new Date(currentEndDate).toLocaleDateString();
        customerCountText += ` (${startDate} - ${endDate})`;
    }
    
    // Add month filter info
    if (window.isMonthFilterActive) {
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const filterMonthName = monthNames[window.filterStartMonth - 1];
        customerCountText += ` - ${filterMonthName} Only`;
        
        // Also add filter indicator to stats
        const statsElements = document.querySelectorAll('.stat-card');
        statsElements.forEach(element => {
            if (window.isMonthFilterActive) {
                element.style.borderLeft = '4px solid #10b981';
                element.title = `Filtered data for ${filterMonthName} only`;
            } else {
                element.style.borderLeft = 'none';
                element.title = '';
            }
        });
    }
    
    document.getElementById('customer-count').textContent = customerCountText;
    
    console.log(' Dashboard updated with live data:', {
        customers: liveDbCustomerCount,
        runs: stats.total_runs,
        trackers: stats.total_trackers,
        filtered: currentStartDate && currentEndDate
    });
}

function updateTrackingGraph() {
    console.log(' GRAPH REFRESH: Starting updateTrackingGraph...');
    
    const graphContainer = document.getElementById('tracking-graph');
    const trackingContainer = graphContainer.parentElement;
    
    //  USE EXISTING DATA FIRST - No unnecessary reload
    if (!dashboardData || !dashboardData.customers || Object.keys(dashboardData.customers).length === 0) {
        console.log(' No dashboard data found - triggering data load...');
        loadDashboardData().then(() => {
            console.log(' Data loaded, retrying graph update...');
            setTimeout(() => updateTrackingGraph(), 500);
        });
        return;
    }
    
    //  DIRECT UPDATE - Use current data without reload
    console.log(' Using current dashboardData for graph update...');
    updateTrackingGraphWithCurrentData();
}

//  CRITICAL FIX: Update monthly runs data after tool execution
function updateMonthlyRunsAfterTool(customerName, networkName, currentDate) {
    console.log(` UPDATING monthly_runs for ${customerName} - ${networkName} with date: ${currentDate}`);
    
    if (!dashboardData || !dashboardData.customers) {
        console.log(' No dashboard data to update');
        return;
    }
    
    // Find the customer
    const customer = Object.values(dashboardData.customers).find(c => 
        c.name.toLowerCase().includes(customerName.toLowerCase())
    );
    
    if (!customer || !customer.networks) {
        console.log(` Customer ${customerName} not found or has no networks`);
        return;
    }
    
    // Find the network
    const network = customer.networks.find(n => 
        (n.name && n.name.toLowerCase().includes(networkName.toLowerCase())) ||
        (n.network_name && n.network_name.toLowerCase().includes(networkName.toLowerCase()))
    );
    
    if (!network) {
        console.log(` Network ${networkName} not found in ${customerName}`);
        return;
    }
    
    // Get current month index (0-11)
    const currentMonth = new Date().getMonth();
    
    // Initialize monthly_runs array if it doesn't exist
    if (!network.monthly_runs) {
        network.monthly_runs = new Array(12).fill('-');
        console.log(` Initialized monthly_runs array for ${networkName}`);
    }
    
    // Update the current month with the new date
    const formattedDate = formatDateForMonthlyRuns(currentDate);
    network.monthly_runs[currentMonth] = formattedDate;
    
    console.log(` UPDATED: ${customerName} - ${networkName} month ${currentMonth + 1} = "${formattedDate}"`);
    
    // CRITICAL: INCREMENT RUNS COUNT
    const currentRuns = parseInt(network.runs || network.total_runs || 0);
    const newRunsCount = currentRuns + 1;
    network.runs = newRunsCount;
    network.total_runs = newRunsCount; // Update both fields for compatibility
    
    console.log(` RUNS INCREMENT: ${customerName} - ${networkName}: ${currentRuns} -> ${newRunsCount}`);
    
    // Also update last_run_date
    network.last_run_date = formattedDate;
    
    // Update customer-level total runs (sum from all networks)
    let customerTotalRuns = 0;
    customer.networks.forEach(net => {
        customerTotalRuns += parseInt(net.runs || net.total_runs || 0);
    });
    customer.total_runs = customerTotalRuns;
    customer.runs = customerTotalRuns;
    
    console.log(` CUSTOMER TOTAL UPDATED: ${customerName} total runs = ${customerTotalRuns}`);
    
    // Update dashboard statistics
    if (dashboardData.statistics) {
        const oldTotalRuns = dashboardData.statistics.total_runs || 0;
        dashboardData.statistics.total_runs = oldTotalRuns + 1;
        console.log(` GLOBAL STATS UPDATED: ${oldTotalRuns} -> ${dashboardData.statistics.total_runs}`);
    }
    
    // Force graph update
    console.log(` Forcing graph update after tool execution...`);
    updateTrackingGraphWithCurrentData();
    updateCustomerMonthChart();
    updateStatistics();
}

// Helper function to format date for monthly runs
function formatDateForMonthlyRuns(dateStr) {
    if (!dateStr) return '-';
    
    try {
        const date = new Date(dateStr);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        return `${day}-${month}`;
    } catch (error) {
        console.log(` Date formatting error: ${error}`);
        return dateStr; // Return original if formatting fails
    }
}

// Separate function to update graph with current data
function updateTrackingGraphWithCurrentData() {
    console.log(' UPDATING GRAPH WITH FRESH DATA...');
    
    const graphContainer = document.getElementById('tracking-graph');
    const trackingContainer = graphContainer.parentElement;
    const customers = dashboardData.customers;
    
    console.log(' UPDATING TRACKING GRAPH WITH REAL CURRENT DATA');
    console.log('=' .repeat(60));
    
    // FORCE CURRENT YEAR - No more year detection nonsense
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear(); // Always use current year
    const currentMonth = currentDate.getMonth() + 1;
    
    console.log(` FORCED CURRENT YEAR: ${currentYear}`);
    console.log(` CURRENT MONTH: ${currentMonth} (${currentDate.toLocaleDateString('en-US', { month: 'long' })})`);
    
    const monthsData = [];
    
    // Generate last 6 months using CURRENT YEAR ONLY
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(currentYear, currentDate.getMonth() - i, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'short' });
        const monthNumber = monthDate.getMonth() + 1;
        const year = monthDate.getFullYear();
        
        console.log(`\n === PROCESSING ${monthName} ${year} (Month #${monthNumber}) ===`);
        
        // Calculate ALL months dynamically from table data
        let monthTotal = 0;
        
        // Check if this month should be filtered out
        let shouldIncludeMonth = true;
        if (window.isMonthFilterActive) {
            shouldIncludeMonth = isMonthInFilterRange(monthNumber, window.filterStartMonth, window.filterEndMonth, window.filterStartYear, window.filterEndYear);
            if (!shouldIncludeMonth) {
                console.log(` Month ${monthName} ${year} filtered out - setting to 0`);
                monthTotal = 0; // Filtered out month
            }
        }
        
        if (shouldIncludeMonth && customers && Object.keys(customers).length > 0) {
            console.log(` DYNAMIC CALCULATION: ${monthName} from table data`);
            
            Object.values(customers).forEach(customer => {
                // Skip Excel customers from graph calculations - only count Live DB customers
                if (customer.excel_source || customer.excel_only || customer.excel_data) {
                    // Skip silently for cleaner logs
                    return;
                }
                
                const monthRuns = getCustomerMonthRuns(customer, year, monthNumber);
                if (monthRuns > 0) {
                    console.log(`   ${customer.name}: ${monthRuns} runs`);
                    monthTotal += monthRuns;
                } else {
                    // Only log if customer has any runs at all (to reduce noise)
                    if (customer.total_runs > 0 || customer.runs > 0) {
                        console.log(`   ${customer.name}: 0 runs this month`);
                    }
                }
            });
        }
        
        console.log(` MONTH TOTAL: ${monthName} ${year} = ${monthTotal} runs`);
        
        monthsData.push({
            month: monthName,
            runs: monthTotal,
            fullDate: monthDate,
            isCurrentMonth: monthNumber === currentMonth && year === currentYear
        });
    }
    
    const maxRuns = Math.max(...monthsData.map(m => m.runs), 1); // At least 1 to avoid division by zero
    
    graphContainer.innerHTML = '';
    
    // RENDER AS BEAUTIFUL LINE CHART for tracking-graph
    if (graphContainer.id === 'tracking-graph') {
        // Modern line chart container
        graphContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            min-height: 220px;
            padding: 16px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.02) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Calculate total and max values
        const totalRuns = monthsData.reduce((sum, month) => sum + month.runs, 0);
        const maxRuns = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Handle empty data state
        if (totalRuns === 0) {
            graphContainer.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    color: #6b7280;
                    font-weight: 600;
                ">
                    <div style="
                        width: 60px;
                        height: 60px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, #e5e7eb 0%, #f3f4f6 100%);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        margin-bottom: 12px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    "></div>
                    <div style="font-size: 0.9rem; text-align: center;">No activity data</div>
                    <div style="font-size: 0.7rem; color: #9ca3af; margin-top: 4px;">Start by uploading health checks</div>
                </div>
            `;
            return;
        }
        
        // Create professional line chart container
        graphContainer.innerHTML = '';
        graphContainer.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 140px;
            padding: 20px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Dynamic professional chart dimensions based on data points
        const baseWidth = 320;
        const dataPointWidth = Math.max(60, Math.min(120, baseWidth / monthsData.length)); // 60-120px per data point
        const chartWidth = Math.max(baseWidth, monthsData.length * dataPointWidth);
        const chartHeight = 120;
        const padding = { left: 25, right: 25, top: 25, bottom: 25 };
        const innerWidth = chartWidth - padding.left - padding.right;
        const innerHeight = chartHeight - padding.top - padding.bottom;
        
        // Apply dynamic container sizing
        if (monthsData.length <= 4) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
        } else if (monthsData.length > 8) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
        } else {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
        }
        
        // Create SVG with proper styling
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', chartHeight);
        svg.setAttribute('viewBox', `0 0 ${chartWidth} ${chartHeight}`);
        svg.style.cssText = 'overflow: visible;';
        
        // Calculate max value for proper scaling
        const maxValue = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Create professional data points with improved positioning
        const points = monthsData.map((month, i) => {
            const x = padding.left + (i / Math.max(monthsData.length - 1, 1)) * innerWidth;
            const normalizedValue = maxValue > 0 ? month.runs / maxValue : 0;
            // Use more chart area for better visualization (90% instead of 80%)
            const y = padding.top + innerHeight - (normalizedValue * innerHeight * 0.9);
            
            return {
                x: x,
                y: Math.max(y, padding.top + 10), // More top padding for labels
                runs: month.runs,
                month: month.month
            };
        });
        
        // Create smooth line path
        let pathData = `M ${points[0].x} ${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
            pathData += ` L ${points[i].x} ${points[i].y}`;
        }
        
        // Add subtle background grid
        for (let i = 0; i <= 4; i++) {
            const y = padding.top + (i / 4) * innerHeight;
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', padding.left + innerWidth);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#f3f4f6');
            gridLine.setAttribute('stroke-width', '0.5');
            if (i > 0) gridLine.setAttribute('stroke-dasharray', '2,2');
            svg.appendChild(gridLine);
        }
        
        // Create professional line with gradient
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', 'lineGradient');
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '100%');
        gradient.setAttribute('y2', '0%');
        
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#667eea');
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#764ba2');
        
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
        svg.appendChild(defs);
        
        // Draw professional line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        line.setAttribute('d', pathData);
        line.setAttribute('stroke', 'url(#lineGradient)');
        line.setAttribute('stroke-width', '2.5');
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-linejoin', 'round');
        line.style.filter = 'drop-shadow(0 1px 3px rgba(102, 126, 234, 0.3))';
        svg.appendChild(line);
        
        // Add professional data points
        points.forEach((point, i) => {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', '3');
            circle.setAttribute('fill', '#ffffff');
            circle.setAttribute('stroke', '#667eea');
            circle.setAttribute('stroke-width', '2');
            circle.style.cssText = `
                cursor: pointer;
                transition: all 0.2s ease;
                filter: drop-shadow(0 1px 2px rgba(102, 126, 234, 0.3));
            `;
            
            // Professional hover effect
            circle.addEventListener('mouseenter', () => {
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', '#667eea');
            });
            circle.addEventListener('mouseleave', () => {
                circle.setAttribute('r', '3');
                circle.setAttribute('fill', '#ffffff');
            });
            
            svg.appendChild(circle);
        });
        
        // Add enhanced professional value labels
        points.forEach((point, i) => {
            const labelText = `${point.runs} runs`;
            const textWidth = Math.max(labelText.length * 6, 40); // Better width calculation
            
            // Create professional background pill
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelBg.setAttribute('x', point.x - textWidth/2 - 3);
            labelBg.setAttribute('y', point.y - 26);
            labelBg.setAttribute('width', textWidth + 6);
            labelBg.setAttribute('height', 18);
            labelBg.setAttribute('rx', '9');
            labelBg.setAttribute('fill', 'rgba(255, 255, 255, 0.95)');
            labelBg.setAttribute('stroke', '#667eea');
            labelBg.setAttribute('stroke-width', '1.5');
            labelBg.style.cssText = `
                filter: drop-shadow(0 2px 6px rgba(102, 126, 234, 0.2));
            `;
            svg.appendChild(labelBg);
            
            // Add enhanced value text
            const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            valueText.setAttribute('x', point.x);
            valueText.setAttribute('y', point.y - 12);
            valueText.setAttribute('text-anchor', 'middle');
            valueText.setAttribute('font-size', '10');
            valueText.setAttribute('font-weight', '700');
            valueText.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            valueText.setAttribute('fill', '#667eea');
            valueText.textContent = labelText;
            svg.appendChild(valueText);
        });
        
        // Add enhanced professional month labels
        points.forEach((point, i) => {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', point.x);
            text.setAttribute('y', chartHeight - 8);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', '600');
            text.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            text.setAttribute('fill', '#4b5563');
            text.textContent = point.month;
            svg.appendChild(text);
        });
        
        // Append the complete professional chart
        graphContainer.appendChild(svg);
        
    } else {
        // RENDER AS BAR CHART (for other charts)
        monthsData.forEach(monthData => {
            const height = maxRuns > 0 ? Math.max((monthData.runs / maxRuns) * 80, 4) : 4;
            
            const graphBar = document.createElement('div');
            graphBar.className = 'graph-bar';
            
            graphBar.innerHTML = `
                <div class="bar" style="height: ${height}px;" title="${monthData.month}: ${monthData.runs} Network Runs">
                    <div class="bar-value">${monthData.runs}</div>
                </div>
                <div class="month-label">${monthData.month}</div>
            `;
            
            graphContainer.appendChild(graphBar);
        });
    }
    
    console.log(' 6-month tracking graph updated:', monthsData);
}

// UPDATE CUSTOMER MONTHLY BREAKDOWN CHART
function updateCustomerMonthChart() {
    console.log(' OLD updateCustomerMonthChart called - redirecting to new dual charts...');
    
    // REDIRECT TO NEW DUAL CHART FUNCTIONS
    if (typeof updateActivityChart === 'function') {
        console.log(' Calling updateActivityChart...');
        updateActivityChart();
    } else {
        console.log(' updateActivityChart function not found!');
    }
    
    if (typeof updateCurrentMonthCustomerChart === 'function') {
        console.log(' Calling updateCurrentMonthCustomerChart...');
        updateCurrentMonthCustomerChart();
    } else {
        console.log(' updateCurrentMonthCustomerChart function not found!');
    }
    
    // Keep minimal fallback for old chart container if it exists
    const chartContainer = document.getElementById('customer-month-chart');
    if (!chartContainer) {
        console.log(' Old chart container not found - dual charts should be working');
        return;
    }
    
    const chartContainerParent = chartContainer.parentElement;
    const customers = dashboardData.customers;
    
    // Get current month data for all customers - use detected data year or filtered month range
    const currentDate = new Date();
    let currentMonth = 10; // October - default
    let currentMonthName = 'October'; // Default month name
    let filteredMonths = []; // Array to store all filtered months
    
    // DEBUG: Check all filter-related variables
    console.log(' DEBUG FILTER STATUS:');
    console.log('  window.isMonthFilterActive:', window.isMonthFilterActive);
    console.log('  window.filterStartMonth:', window.filterStartMonth);
    console.log('  window.filterEndMonth:', window.filterEndMonth);
    console.log('  window.isFilterActive:', window.isFilterActive);
    console.log('  window.currentStartDate:', window.currentStartDate);
    console.log('  window.currentEndDate:', window.currentEndDate);
    
    // Check if any filter is active (either month filter or date filter)
    const isAnyFilterActive = window.isMonthFilterActive || window.isFilterActive;
    console.log('  isAnyFilterActive:', isAnyFilterActive);
    
    // If filter is active, get the full month range
    if (isAnyFilterActive) {
        let startMonth, endMonth;
        
        if (window.isMonthFilterActive && window.filterStartMonth && window.filterEndMonth) {
            // Use month filter values
            startMonth = window.filterStartMonth;
            endMonth = window.filterEndMonth;
            console.log(` Using month filter: ${startMonth} to ${endMonth}`);
        } else if (window.isFilterActive && window.currentStartDate && window.currentEndDate) {
            // Calculate months from date filter
            const startDate = new Date(window.currentStartDate);
            const endDate = new Date(window.currentEndDate);
            startMonth = startDate.getMonth() + 1; // Convert 0-11 to 1-12
            endMonth = endDate.getMonth() + 1;
            console.log(` Using date filter: ${window.currentStartDate} to ${window.currentEndDate} -> months ${startMonth} to ${endMonth}`);
        } else {
            // Fallback - no valid filter found
            console.log(' Filter detected but no valid filter data found');
            startMonth = currentDate.getMonth() + 1;
            endMonth = startMonth;
        }
        
        // Generate all months in the filter range
        filteredMonths = [];
        let currentFilterMonth = startMonth;
        while (currentFilterMonth <= endMonth) {
            filteredMonths.push(currentFilterMonth);
            currentFilterMonth++;
        }
        
        // Create combined month display name with + separator
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        if (filteredMonths.length === 1) {
            // Single month: "Aug"
            currentMonthName = monthNames[filteredMonths[0] - 1];
        } else {
            // Multiple months: "Aug+Sep+Oct" (show all months with + separator)
            const monthDisplayNames = filteredMonths.map(month => monthNames[month - 1]);
            currentMonthName = monthDisplayNames.join('+');
        }
        
        currentMonth = startMonth; // Use start month for primary logic
        console.log(` Using filtered months: ${filteredMonths.join(',')} -> Display: ${currentMonthName}`);
    } else {
        // No filter: use current month
        currentMonth = currentDate.getMonth() + 1;
        currentMonthName = currentDate.toLocaleDateString('en-US', { month: 'short' });
        filteredMonths = [currentMonth];
    }
    
    // Detect data year from customer data (same logic as graph)
    const dataYears = new Set();
    if (customers && Object.keys(customers).length > 0) {
        Object.values(customers).forEach(customer => {
            if (customer.networks && Array.isArray(customer.networks)) {
                customer.networks.forEach(network => {
                    const monthlyArray = network.monthly_runs || network.months || [];
                    monthlyArray.forEach(monthValue => {
                        if (monthValue && monthValue.includes && monthValue.includes('/')) {
                            const dateObj = fixDateParsing(monthValue);
                            if (dateObj) {
                                dataYears.add(dateObj.getFullYear());
                            }
                        }
                    });
                });
            }
        });
    }
    
    const currentYear = dataYears.size > 0 ? Math.max(...Array.from(dataYears)) : currentDate.getFullYear();
    
    console.log(` ACTIVE CUSTOMERS: Using months ${filteredMonths.join(',')}/${currentYear}`);
    console.log(` Detected data years:`, Array.from(dataYears));
    
    // Update the chart title with combined month name and year
    const chartTitle = document.getElementById('customer-chart-title');
    if (chartTitle) {
        chartTitle.textContent = ` Customer Health Check - ${currentMonthName} ${currentYear}`;
    }
    
    const customersData = [];
    
    if (customers && Object.keys(customers).length > 0) {
        Object.entries(customers).forEach(([customerName, customer]) => {
            // Skip Excel customers - only show Live DB customers
            if (customer.excel_source || customer.excel_only || customer.excel_data) {
                console.log(`   SKIPPING Excel customer for active chart: ${customerName}`);
                return;
            }
            
            console.log(`\n ACTIVE CHART: Getting runs for ${customerName} in months ${filteredMonths.join(',')}/${currentYear}`);
            
            // Calculate total runs across ALL filtered months
            let totalFilteredRuns = 0;
            filteredMonths.forEach(month => {
                const monthRuns = getCustomerMonthRuns(customer, currentYear, month);
                totalFilteredRuns += monthRuns;
                console.log(`     ${customerName} month ${month}: ${monthRuns} runs`);
            });
            
            console.log(` ${customerName}: ${totalFilteredRuns} total runs across filtered months`);
            
            if (totalFilteredRuns > 0) { // Only show customers with runs in filtered period
                customersData.push({
                    name: customerName,
                    runs: totalFilteredRuns,
                    customer: customer
                });
                console.log(`   ADDED TO ACTIVE CHART: ${customerName} with ${totalFilteredRuns} runs`);
            } else {
                console.log(`   NOT ADDED: ${customerName} has 0 runs in filtered months`);
            }
        });
        
        // Sort by runs (highest first) and take top 10
        customersData.sort((a, b) => b.runs - a.runs);
        customersData.splice(10); // Keep only top 10
    }
    
    // Apply dynamic container sizing based on number of customers
    if (customersData.length <= 3) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
    } else if (customersData.length > 10) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
    } else {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
    }
    
    chartContainer.innerHTML = '';
    
    // Dynamic container styling based on customer count
    const dynamicGap = Math.max(8, Math.min(18, 120 / customersData.length)); // Better gap spacing
    const dynamicWidth = customersData.length > 8 ? Math.max(50, 350 / customersData.length) : 90; // Wider bars
    
    chartContainer.style.cssText = `
        display: flex;
        align-items: flex-end;
        justify-content: space-evenly;
        padding: 16px 12px 20px 12px;
        height: 120px;
        gap: ${dynamicGap}px;
        overflow-x: auto;
        overflow-y: visible;
        background: rgba(248, 250, 252, 0.3);
        border-radius: 6px;
        min-height: 130px;
    `;
    
    if (customersData.length === 0) {
        chartContainer.innerHTML = `
            <div style="padding: 40px; text-align: center; color: #6b7280;">
                <div style="font-size: 2rem; margin-bottom: 16px;"></div>
                <div style="font-weight: 600; margin-bottom: 8px;">No activity this month</div>
                <div style="font-size: 0.9rem;">Customers will appear here when they run health checks in ${currentMonthName}</div>
            </div>
        `;
        return;
    }
    
    const maxRuns = Math.max(...customersData.map(c => c.runs), 1);
    
    // Create chart bars for each customer - UNIFORM SIZING
    customersData.forEach((customerData, index) => {
        // FIXED: All bars same height, only numbers show difference
        const height = 40; // Same height for all bars
            
        const isTopPerformer = index < 3; // Top 3 get special styling
        
        const chartBar = document.createElement('div');
        chartBar.className = 'customer-chart-bar';
        chartBar.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            margin: 0 8px;
            flex: 1;
            max-width: 95px;
            min-width: 80px;
            height: 100px;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.12));
        `;
        
        // Add hover effect
        chartBar.addEventListener('mouseenter', () => {
            chartBar.style.transform = 'scale(1.08) translateY(-2px)';
            chartBar.style.filter = 'drop-shadow(0 3px 8px rgba(0,0,0,0.15))';
        });
        chartBar.addEventListener('mouseleave', () => {
            chartBar.style.transform = 'scale(1) translateY(0)';
            chartBar.style.filter = 'drop-shadow(0 1px 3px rgba(0,0,0,0.1))';
        });
        
        const barColor = isTopPerformer ? 
            (index === 0 ? '#10b981' : index === 1 ? '#3b82f6' : '#f59e0b') : 
            '#6b7280';
        
        chartBar.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-end;
                    height: 100%;
                    width: 100%;
                ">
                <div style="
                    background: ${barColor};
                    color: white;
                    font-weight: 800;
                    font-size: 0.9rem;
                    padding: 6px 12px;
                    border-radius: 8px;
                    margin-bottom: 6px;
                    min-width: 28px;
                    text-align: center;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    border: 1px solid rgba(255,255,255,0.4);
                    position: relative;
                    z-index: 2;
                " title="${customerData.name}: ${customerData.runs} runs in ${currentMonthName}">
                    ${customerData.runs}
                </div>
                <div style="
                    width: 80%;
                    height: ${height}px;
                    background: linear-gradient(135deg, ${barColor} 0%, ${barColor}cc 50%, ${barColor}dd 100%);
                    border-radius: 6px;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                    position: relative;
                "></div>
                <div style="
                    font-size: 0.75rem;
                    font-weight: 700;
                    color: #374151;
                    text-align: center;
                    margin-top: 8px;
                    line-height: 1.2;
                    max-width: 100%;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    background: rgba(255,255,255,0.95);
                    padding: 4px 8px;
                    border-radius: 6px;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                    border: 1px solid rgba(0,0,0,0.08);
                    min-height: 26px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " title="${customerData.name}">
                    ${customerData.name.length > 8 ? customerData.name.substring(0, 8) + '...' : customerData.name}
                </div>
                <div style="
                    font-size: 0.5rem;
                    font-weight: 500;
                    color: #6b7280;
                    text-align: center;
                    margin-top: 1px;
                ">
                    ${window.isMonthFilterActive ? new Date(2024, window.filterStartMonth - 1, 1).toLocaleDateString('en-US', { month: 'short' }) : currentDate.toLocaleDateString('en-US', { month: 'short' })}
                </div>
            </div>
        `;
        
        chartContainer.appendChild(chartBar);
    });
    
    console.log(` Customer monthly chart updated for ${currentMonthName}:`, customersData);
}

// DYNAMIC CHART RESIZE HANDLER
function handleChartResize() {
    // Debounce resize events
    clearTimeout(window.chartResizeTimeout);
    window.chartResizeTimeout = setTimeout(() => {
        console.log(' Adjusting charts for window resize...');
        
        // Update both charts with current data
        if (dashboardData && dashboardData.customers) {
            updateTrackingGraph();
            updateCustomerMonthChart();
        }
    }, 300);
}

// Add resize listener
window.addEventListener('resize', handleChartResize);

// EDIT CUSTOMER FUNCTIONALITY
function editCustomer(customerName) {
    console.log(` Opening edit modal for: ${customerName}`);
    
    // Find customer data - BE SPECIFIC
    const customerKey = Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === customerName
    );
    const customer = dashboardData.customers[customerKey];
    
    if (!customer) {
        showNotification(' Customer not found', 'error');
        return;
    }
    
    console.log(` EDIT MODAL: Opening for customer "${customerName}" (key: ${customerKey})`);
    console.log(` Customer has ${customer.networks?.length || 0} networks`);
    
    // Close any existing modal first
    const existingModal = document.getElementById('editCustomerModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Create edit modal
    const modal = document.createElement('div');
    modal.id = 'editCustomerModal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; justify-content: center;
        align-items: center; z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white; padding: 20px; border-radius: 8px; width: 80%;
        max-width: 800px; max-height: 80%; overflow-y: auto;
    `;
    
    // Generate month headers
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let networksHtml = '';
    
    if (customer.networks && customer.networks.length > 0) {
        customer.networks.forEach((network, index) => {
            // CRITICAL: Use customer-specific IDs to prevent conflicts
            const customerSafeId = customerName.replace(/[^a-zA-Z0-9_-]/g, '_');
            
            networksHtml += `
                <div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                    <h4>${network.name || `Network ${index + 1}`}</h4>
                    <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 5px; margin-top: 10px;">
                        ${months.map((month, monthIndex) => {
                            const inputId = `${customerSafeId}_network_${index}_month_${monthIndex}`;
                            const value = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                            return `
                                <div>
                                    <label style="font-size: 0.8rem; display: block;">${month}</label>
                                    <input type="text" id="${inputId}" value="${value}" 
                                           style="width: 100%; padding: 4px; font-size: 0.8rem;" 
                                           data-customer="${customerName}" data-network="${index}" data-month="${monthIndex}" />
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        });
    }
    
    modalContent.innerHTML = `
        <h2> Edit Customer: ${customerName}</h2>
        <div style="margin: 20px 0;">
            <h3>Networks Monthly Data:</h3>
            ${networksHtml}
        </div>
        <div style="margin: 20px 0; text-align: right;">
            <button onclick="saveCustomerEdit('${customerName}')" 
                    style="background: #10b981; color: white; border: none; padding: 10px 20px; 
                           border-radius: 4px; margin-right: 10px; cursor: pointer;">
                
            </button>
            <button onclick="closeEditModal()" 
                    style="background: #6b7280; color: white; border: none; padding: 10px 20px; 
                           border-radius: 4px; cursor: pointer;">
                
            </button>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}

function closeEditModal() {
    const modal = document.getElementById('editCustomerModal');
    if (modal) {
        modal.remove();
    }
}

function saveCustomerEdit(customerName) {
    console.log(` Saving changes for: ${customerName}`);
    
    // Find customer data - BE SPECIFIC ABOUT WHICH CUSTOMER
    const customerKey = Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === customerName
    );
    const customer = dashboardData.customers[customerKey];
    
    if (!customer) {
        showNotification(' Customer not found', 'error');
        return;
    }
    
    console.log(` SPECIFIC EDIT: Only updating customer "${customerName}", customerKey: "${customerKey}"`);
    
    // CRITICAL: Create deep copy to avoid reference issues
    const updatedNetworks = [];
    
    // FIXED: Only update networks for THIS specific customer
    if (customer.networks && customer.networks.length > 0) {
        const customerSafeId = customerName.replace(/[^a-zA-Z0-9_-]/g, '_');
        
        customer.networks.forEach((network, networkIndex) => {
            const updatedMonths = [];
            
            // Collect new values from form inputs using customer-specific IDs
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputId = `${customerSafeId}_network_${networkIndex}_month_${monthIndex}`;
                const input = document.getElementById(inputId);
                
                if (input) {
                    updatedMonths[monthIndex] = input.value || '-';
                    console.log(` Reading input ${inputId}: "${input.value}"`);
                } else {
                    // Keep original value if input not found
                    updatedMonths[monthIndex] = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    console.warn(` Input ${inputId} not found, keeping original: "${updatedMonths[monthIndex]}"`);
                }
            }
            
            // Create updated network with ONLY the necessary changes
            updatedNetworks.push({
                ...network, // Keep all original network properties
                months: updatedMonths, // Update only the months data
                monthly_runs: updatedMonths // Keep compatibility
            });
            
            console.log(` Updated network "${network.name}" for customer "${customerName}" with ${updatedMonths.length} months`);
        });
    }
    
    // CRITICAL: Update ONLY this customer's networks - don't touch other customers
    dashboardData.customers[customerKey].networks = updatedNetworks;
    
    // VERIFICATION: Check that only this customer was modified
    const verificationPassed = verifyCustomerIsolation(customerName, customerKey);
    if (verificationPassed) {
        console.log(` ISOLATION VERIFICATION PASSED: Only customer "${customerName}" was modified`);
    } else {
        console.error(` ISOLATION VERIFICATION FAILED: Other customers may have been affected!`);
    }
    
    console.log(` Updated ${updatedNetworks.length} networks for customer "${customerName}"`);
    
    // Store edit in localStorage with customer-specific key
    try {
        const editKey = `edited_db_${customerName}_${Date.now()}`.replace(/[^a-zA-Z0-9_-]/g, '_');
        
        // Store each network separately for precise control
        updatedNetworks.forEach((network, index) => {
            const networkKey = `edited_db_${customerName}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
            const networkData = {
                months: network.months,
                originalMonths: network.originalMonths || network.months,
                timestamp: Date.now(),
                customer: customerName,
                network: network.name,
                source: 'manual_edit'
            };
            localStorage.setItem(networkKey, JSON.stringify(networkData));
            console.log(` Stored: ${networkKey}`);
        });
        
        // CLEAR any old localStorage data for OTHER customers to prevent contamination
        clearOtherCustomersData(customerName);
        
    } catch (e) {
        console.warn(' Could not store edit in localStorage:', e);
    }
    
    // Success notification
    showNotification(` Customer "${customerName}" updated successfully! (Local changes only)`, 'success');
    closeEditModal();
    
    // Refresh ONLY THIS SPECIFIC CUSTOMER - don't update others
    setTimeout(() => {
        console.log(` Refreshing ONLY customer "${customerName}" - others unchanged`);
        updateSpecificCustomerOnly(customerName);
        
        // Also update simple graphs if they exist
        if (window.updateAllSimpleGraphs) {
            window.updateAllSimpleGraphs();
        }
    }, 300);
}

//  RESTORE SPECIFIC CUSTOMER DATA ONLY
function restoreSpecificCustomerData(targetCustomerName) {
    console.log(` Restoring localStorage data ONLY for: ${targetCustomerName}`);
    
    // Find target customer
    const targetCustomerKey = Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === targetCustomerName
    );
    
    if (!targetCustomerKey) {
        console.log(` Customer ${targetCustomerName} not found for restore`);
        return;
    }
    
    const targetCustomer = dashboardData.customers[targetCustomerKey];
    let restoredCount = 0;
    
    // Restore ONLY this customer's networks
    if (targetCustomer.networks && targetCustomer.networks.length > 0) {
        targetCustomer.networks.forEach(network => {
            const storageKey = `edited_db_${targetCustomer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
            const storedData = localStorage.getItem(storageKey);
            
            if (storedData) {
                try {
                    const editedData = JSON.parse(storedData);
                    
                    // STRICT validation - exact match only
                    if (editedData.customer === targetCustomer.name && editedData.network === network.name) {
                        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                        if (Date.now() - editedData.timestamp < maxAge) {
                            network.originalMonths = network.months ? [...network.months] : [];
                            network.months = editedData.months;
                            network.monthly_runs = editedData.months;
                            network.editedData = true;
                            
                            console.log(` Restored: ${targetCustomer.name} - ${network.name}`);
                            restoredCount++;
                        } else {
                            localStorage.removeItem(storageKey);
                            console.log(` Removed old data: ${storageKey}`);
                        }
                    }
                } catch (error) {
                    console.error(` Error restoring ${storageKey}:`, error);
                    localStorage.removeItem(storageKey);
                }
            }
        });
    }
    
    console.log(` Restored ${restoredCount} networks for ${targetCustomerName}`);
    return restoredCount;
}

//  CLEAR OTHER CUSTOMERS DATA TO PREVENT CONTAMINATION
function clearOtherCustomersData(keepCustomerName) {
    console.log(` Clearing localStorage for all customers EXCEPT: ${keepCustomerName}`);
    
    const keysToRemove = [];
    
    // Find all edited_ keys that don't belong to the keepCustomerName
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('edited_')) {
            try {
                const storedData = localStorage.getItem(key);
                const data = JSON.parse(storedData);
                
                // Remove if it's for a different customer
                if (data.customer && data.customer !== keepCustomerName) {
                    keysToRemove.push(key);
                    console.log(` Will remove: ${key} (belongs to ${data.customer})`);
                }
            } catch (error) {
                // Remove invalid data
                keysToRemove.push(key);
                console.log(` Will remove invalid: ${key}`);
            }
        }
    }
    
    // Remove the keys
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log(` Removed: ${key}`);
    });
    
    console.log(` Cleaned ${keysToRemove.length} localStorage entries - kept only ${keepCustomerName} data`);
}

//  UPDATE ONLY SPECIFIC CUSTOMER - Don't touch others
function updateSpecificCustomerOnly(targetCustomerName) {
    console.log(` Updating ONLY customer: ${targetCustomerName}`);
    
    // FIRST: Restore any localStorage data for THIS customer only
    restoreSpecificCustomerData(targetCustomerName);
    
    const tableBody = document.getElementById('customer-table-body');
    if (!tableBody) {
        console.error(' Table body not found');
        return;
    }
    
    // Find the target customer in data
    const targetCustomerKey = Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === targetCustomerName
    );
    
    if (!targetCustomerKey) {
        console.error(` Customer ${targetCustomerName} not found in data`);
        return;
    }
    
    const targetCustomer = dashboardData.customers[targetCustomerKey];
    console.log(` Found target customer: ${targetCustomer.name}`);
    
    // Find existing rows for this customer ONLY
    const existingRows = [];
    const allRows = Array.from(tableBody.querySelectorAll('tr'));
    
    allRows.forEach(row => {
        const nameCell = row.querySelector('.customer-name-cell');
        if (nameCell && nameCell.textContent.includes(targetCustomerName)) {
            existingRows.push(row);
        }
    });
    
    console.log(` Found ${existingRows.length} existing rows for ${targetCustomerName}`);
    
    // Remove old rows for this customer only
    existingRows.forEach(row => {
        console.log(` Removing old row for ${targetCustomerName}`);
        row.remove();
    });
    
    // Create new updated rows for this customer
    const currentYear = new Date().getFullYear();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Create customer summary row
    const customerRow = createCustomerSummaryRow(targetCustomer, currentYear, months);
    
    // Find where to insert (maintain order)
    const customerOrder = Object.keys(dashboardData.customers);
    const customerIndex = customerOrder.findIndex(key => key === targetCustomerKey);
    
    let insertBeforeRow = null;
    if (customerIndex >= 0) {
        // Find the next customer in order that exists in table
        for (let i = customerIndex + 1; i < customerOrder.length; i++) {
            const nextCustomerName = dashboardData.customers[customerOrder[i]].name;
            const nextRow = Array.from(tableBody.querySelectorAll('tr')).find(row => {
                const nameCell = row.querySelector('.customer-name-cell');
                return nameCell && nameCell.textContent.includes(nextCustomerName);
            });
            if (nextRow) {
                insertBeforeRow = nextRow;
                break;
            }
        }
    }
    
    // Insert the updated customer row
    if (insertBeforeRow) {
        tableBody.insertBefore(customerRow, insertBeforeRow);
        console.log(` Inserted ${targetCustomerName} row before ${insertBeforeRow.textContent.substring(0, 20)}...`);
    } else {
        tableBody.appendChild(customerRow);
        console.log(` Appended ${targetCustomerName} row at end`);
    }
    
    // Add network rows if customer has networks
    if (targetCustomer.networks && targetCustomer.networks.length > 0) {
        targetCustomer.networks.forEach((network, networkIndex) => {
            const networkRow = createNetworkDetailRow(targetCustomer, network, networkIndex, currentYear, months);
            if (insertBeforeRow) {
                tableBody.insertBefore(networkRow, insertBeforeRow);
            } else {
                tableBody.appendChild(networkRow);
            }
        });
        console.log(` Added ${targetCustomer.networks.length} network rows for ${targetCustomerName}`);
    }
    
    console.log(` Successfully updated ONLY ${targetCustomerName} in table - others unchanged!`);
}

// RESTORE EDITED DATA FROM LOCALSTORAGE
function restoreEditedData() {
    console.log(' Restoring edited data from localStorage...');
    
    // First clear old data
    clearOldEditedData();
    
    let restoredCount = 0;
    
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip Excel customers from localStorage restore - only restore Live DB customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                // More robust storage key with customer source
                const isExcel = customer.excel_source || customer.excel_data;
                const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                const storedData = localStorage.getItem(storageKey);
                
                if (storedData) {
                    try {
                        const editedData = JSON.parse(storedData);
                        
                        // CRITICAL: STRICT VALIDATION - Only restore if EXACT customer and network match
                        if (editedData.customer !== customer.name || editedData.network !== network.name) {
                            console.log(`    MISMATCH: Skipping ${storageKey} - customer: ${editedData.customer} vs ${customer.name}, network: ${editedData.network} vs ${network.name}`);
                            return; // Skip this network restoration
                        }
                        
                        // Check if data is not too old (less than 24 hours)
                        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                        if (Date.now() - editedData.timestamp < maxAge) {
                            // Store original months data if not already stored
                            if (!network.originalMonths) {
                                network.originalMonths = network.months ? [...network.months] : [];
                            }
                            
                            network.months = editedData.months;
                            network.monthly_runs = editedData.months;
                            network.editedData = true; // Mark as edited
                            
                            console.log(`    STRICT MATCH: Restored edited data for ${customer.name} - ${network.name}`);
                            restoredCount++;
                        } else {
                            // Remove old data
                            localStorage.removeItem(storageKey);
                            console.log(`    Removed old edited data for ${customer.name} - ${network.name}`);
                        }
                    } catch (error) {
                        console.error(`    Error restoring data for ${storageKey}:`, error);
                        localStorage.removeItem(storageKey);
                    }
                }
            });
        }
    });
    
    if (restoredCount > 0) {
        showNotification(` Restored ${restoredCount} edited networks from localStorage`, 'info');
    }
    
    return restoredCount;
}

// CLEAR OLD EDITED DATA
function clearOldEditedData() {
    console.log(' Cleaning old edited data from localStorage...');
    
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('edited_')) {
            const storedData = localStorage.getItem(key);
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (Date.now() - data.timestamp >= maxAge) {
                        keysToRemove.push(key);
                    }
                } catch (error) {
                    keysToRemove.push(key); // Remove invalid data
                }
            }
        }
    }
    
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log(`    Removed old data: ${key}`);
    });
}

// BULK EDIT FUNCTIONALITY
function openBulkEditModal() {
    console.log(` Opening Live DB edit modal`);
    
    // Get ONLY Live DB customers - filter out Excel and fake entries
    const allCustomers = Object.values(dashboardData.customers);
    
    // STRICT FILTERING: Only Live DB customers, block fake entries
    const dbCustomers = allCustomers.filter(customer => {
        // Must be database customer (not Excel)
        if (customer.excel_source || customer.excel_data || customer.excel_only) {
            return false;
        }
        
        // Block fake/test entries
        if (!customer.name || 
            customer.name.toLowerCase().includes('unknown') ||
            customer.name.toLowerCase().includes('timedotcom') ||
            customer.name.toLowerCase().includes('default') ||
            customer.name === 'subu-east' ||
            customer.name === 'Default' ||
            customer.name.trim().length <= 2) {
            console.log(` Blocked fake entry: ${customer.name}`);
            return false;
        }
        
        return true;
    });
    
    if (dbCustomers.length === 0) {
        showNotification(' No Live DB customers found to edit', 'error');
        return;
    }
    
    console.log(` Found ${dbCustomers.length} Live DB customers for editing`);
    console.log(` Editing customers: ${dbCustomers.map(c => c.name).join(', ')}`);
    
    // Create edit modal
    const modal = document.createElement('div');
    modal.id = 'bulkEditModal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; justify-content: center;
        align-items: center; z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white; padding: 30px; border-radius: 12px; width: 95%;
        max-width: 1400px; max-height: 85%; overflow-y: auto;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    `;
    
    // Generate month headers
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let customersHtml = '';
    
    // Process Excel customers
    excelCustomers.forEach((customer, customerIndex) => {
        let networksHtml = '';
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                const monthInputs = months.map((month, monthIndex) => {
                    const value = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7rem; margin-bottom: 4px; font-weight: 600; 
                                          color: #4b5563;">${month}</label>
                            <input type="text" 
                                   id="excel_customer_${customerIndex}_network_${networkIndex}_month_${monthIndex}" 
                                   value="${value}" 
                                   placeholder="-"
                                   style="width: 75px; padding: 6px 4px; font-size: 0.75rem; text-align: center;
                                          border: 1px solid #d1d5db; border-radius: 4px; 
                                          transition: all 0.2s ease;
                                          background: #ffffff;"
                                   onocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 2px rgba(59, 130, 246, 0.1)'"
                                   onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'" />
                        </div>
                    `;
                }).join('');
                
                networksHtml += `
                    <div style="margin: 15px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; 
                                background: linear-gradient(to right, #f8fafc, #f1f5f9); 
                                box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                        <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                            <h5 style="margin: 0; color: #1e40af; font-weight: 600; font-size: 0.95rem;">
                                 ${network.name || `Network ${networkIndex + 1}`}
                            </h5>
                            <span style="background: #3b82f6; color: white; padding: 3px 8px; border-radius: 12px; 
                                         font-size: 0.65rem; font-weight: 500;">Excel Network</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; 
                                    background: white; padding: 15px; border-radius: 6px;">
                            ${monthInputs}
                        </div>
                    </div>
                `;
            });
        }
        
        customersHtml += `
            <div style="margin: 25px 0; padding: 25px; border: 2px solid #3b82f6; border-radius: 12px; 
                        background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #1e40af; font-size: 1.25rem; font-weight: 700;">
                         ${customer.name}
                    </h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #3b82f6; color: white; padding: 6px 12px; border-radius: 20px; 
                                     font-size: 0.75rem; font-weight: 600;">Excel Customer</span>
                        <span style="background: #f3f4f6; color: #6b7280; padding: 4px 8px; border-radius: 12px; 
                                     font-size: 0.65rem;">${customer.networks ? customer.networks.length : 0} Networks</span>
                    </div>
                </div>
                ${networksHtml}
            </div>
        `;
    });
    
    // Process DB customers - Show real dates like dashboard
    dbCustomers.forEach((customer, customerIndex) => {
        let networksHtml = '';
        const currentYear = new Date().getFullYear();
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                // Clean network name - remove customer prefix like "Bsnl - "
                let networkName = network.network_name || network.name || network;
                
                // If network name has customer prefix, remove it to show clean name
                if (typeof networkName === 'string' && networkName.includes(' - ')) {
                    const cleanName = networkName.split(' - ').slice(1).join(' - ');
                    if (cleanName && cleanName !== 'Default') {
                        networkName = cleanName;
                    } else {
                        // If it's just "Default", use customer name + Default
                        networkName = `${customer.name} Default`;
                    }
                }
                
                console.log(` DB Network: "${network.name}" -> "${networkName}" for customer ${customer.name}`);
                
                const monthInputs = months.map((month, monthIndex) => {
                    // Get real dates using the original network name for data lookup
                    const monthRunData = getNetworkMonthRunDates(customer, network.name, currentYear, monthIndex + 1);
                    const value = monthRunData && monthRunData.date && monthRunData.date !== '-' ? monthRunData.date : '-';
                    
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7rem; margin-bottom: 4px; font-weight: 600; 
                                          color: #4b5563;">${month}</label>
                            <input type="text" 
                                   id="db_customer_${customerIndex}_network_${networkIndex}_month_${monthIndex}" 
                                   value="${value}" 
                                   placeholder="DD-MMM-YY"
                                   style="width: 75px; padding: 6px 4px; font-size: 0.75rem; text-align: center;
                                          border: 1px solid #d1d5db; border-radius: 4px; 
                                          transition: all 0.2s ease;
                                          background: #ffffff;"
                                   onfocus="this.style.borderColor='#10b981'; this.style.boxShadow='0 0 0 2px rgba(16, 185, 129, 0.1)'"
                                   onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'" />
                        </div>
                    `;
                }).join('');
                
                networksHtml += `
                    <div style="margin: 15px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; 
                                background: linear-gradient(to right, #f0fdf4, #ecfdf5); 
                                box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                        <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                            <h5 style="margin: 0; color: #059669; font-weight: 600; font-size: 0.95rem;">
                                 ${networkName}
                            </h5>
                            <span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 12px; 
                                         font-size: 0.65rem; font-weight: 500;">DB Network</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; 
                                    background: white; padding: 15px; border-radius: 6px;">
                            ${monthInputs}
                        </div>
                    </div>
                `;
            });
        }
        
        customersHtml += `
            <div style="margin: 25px 0; padding: 25px; border: 2px solid #10b981; border-radius: 12px; 
                        background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #059669; font-size: 1.25rem; font-weight: 700;">
                         ${customer.name}
                    </h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #10b981; color: white; padding: 6px 12px; border-radius: 20px; 
                                     font-size: 0.75rem; font-weight: 600;">Database Customer</span>
                        <span style="background: #f3f4f6; color: #6b7280; padding: 4px 8px; border-radius: 12px; 
                                     font-size: 0.65rem;">${customer.networks ? customer.networks.length : 0} Networks</span>
                    </div>
                </div>
                ${networksHtml}
            </div>
        `;
    });
    
    modalContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #f3f4f6; padding-bottom: 20px;">
            <h2 style="margin: 0 0 10px 0; color: #1f2937; font-size: 1.75rem; font-weight: 800;">
                 Monthly Data Editor
            </h2>
            <p style="color: #6b7280; margin: 0; font-size: 1rem;">
                Edit monthly run dates for all customers. Changes are saved locally until you refresh the page.
            </p>
        </div>
        
        <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 30px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #3b82f6; border-radius: 3px;"></div>
                    <span style="color: #374151; font-weight: 500;">Excel Customers</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #10b981; border-radius: 3px;"></div>
                    <span style="color: #374151; font-weight: 500;">Database Customers</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: #6b7280; font-size: 0.9rem;"> Use format: DD-MMM-YY (e.g., 15-Jan-25)</span>
                </div>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            ${customersHtml}
        </div>
        
        <div style="margin: 30px 0 0 0; text-align: center; border-top: 2px solid #f3f4f6; padding-top: 25px;">
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <button onclick="saveBulkEdit()" 
                        style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; 
                               border: none; padding: 16px 32px; border-radius: 10px; 
                               cursor: pointer; font-weight: 600; font-size: 1rem;
                               box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                               transition: all 0.3s ease;
                               display: flex; align-items: center; gap: 10px;
                               min-width: 180px; justify-content: center;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(16, 185, 129, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)'">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                </button>
                
                <button onclick="closeBulkEditModal()" 
                        style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; 
                               border: none; padding: 16px 32px; border-radius: 10px; cursor: pointer; 
                               font-weight: 600; font-size: 1rem;
                               box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
                               transition: all 0.3s ease;
                               display: flex; align-items: center; gap: 10px;
                               min-width: 140px; justify-content: center;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(239, 68, 68, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.3)'">
                    <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}

function closeBulkEditModal() {
    const modal = document.getElementById('bulkEditModal');
    if (modal) {
        modal.remove();
    }
}

function saveBulkEdit() {
    console.log(` Saving bulk changes...`);
    
    // Get both Excel and DB customers
    const allCustomers = Object.values(dashboardData.customers);
    const excelCustomers = allCustomers.filter(customer => customer.excel_source || customer.excel_data);
    const dbCustomers = allCustomers.filter(customer => !customer.excel_source && !customer.excel_data);
    
    let updatedCount = 0;
    
    // Update Excel customers - Process each customer independently
    excelCustomers.forEach((customer, excelCustomerIndex) => {
        console.log(` Processing Excel customer ${excelCustomerIndex}: ${customer.name}`);
        
        customer.networks.forEach((network, networkIndex) => {
            const inputId = `excel_customer_${excelCustomerIndex}_network_${networkIndex}_month_`;
            console.log(`    Checking network: ${network.name} with ID pattern: ${inputId}`);
            
            const updatedMonths = [];
            let hasChanges = false;
            
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                if (inputElement) {
                    const newValue = inputElement.value || '-';
                    updatedMonths[monthIndex] = newValue;
                    
                    // Check if there are changes
                    const oldValue = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    if (newValue !== oldValue) {
                        hasChanges = true;
                        console.log(`      Month ${monthIndex + 1}: "${oldValue}"  "${newValue}"`);
                    }
                } else {
                    console.log(`      Input not found: ${inputId}${monthIndex}`);
                }
            }
            
            // Update network data only if there are changes
            if (hasChanges) {
                // Store original months data before editing (if not already stored)
                if (!network.originalMonths) {
                    network.originalMonths = network.months ? [...network.months] : [];
                }
                
                network.months = updatedMonths;
                network.monthly_runs = updatedMonths;
                network.editedData = true; // Mark as edited
                
                // Store edited data in localStorage with robust key
                const storageKey = `edited_excel_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                localStorage.setItem(storageKey, JSON.stringify({
                    months: updatedMonths,
                    originalMonths: network.originalMonths,
                    timestamp: Date.now(),
                    customer: customer.name,
                    network: network.name,
                    source: 'excel'
                }));
                
                updatedCount++;
                console.log(`    Updated Excel network: ${network.name} (saved to localStorage)`);
            } else {
                console.log(`    No changes for Excel network: ${network.name}`);
            }
        });
    });
    
    // Update DB customers - CRITICAL FIX: Only mark networks as edited if input actually changed
    dbCustomers.forEach((customer, customerIndex) => {
        console.log(` Processing DB customer ${customerIndex}: ${customer.name}`);
        
        customer.networks.forEach((network, networkIndex) => {
            const inputId = `db_customer_${customerIndex}_network_${networkIndex}_month_`;
            console.log(`    Checking DB network: ${network.name} with ID pattern: ${inputId}`);
            
            let hasChanges = false;
            const updatedMonths = [];
            
            // Store original months data before editing (if not already stored)
            if (!network.originalMonths) {
                network.originalMonths = network.months ? [...network.months] : Array(12).fill('-');
            }
            
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                if (inputElement) {
                    const newValue = inputElement.value || '-';
                    updatedMonths[monthIndex] = newValue;
                    
                    // For DB customers, initialize months array if needed
                    if (!network.months) {
                        network.months = Array(12).fill('-');
                    }
                    
                    const oldValue = network.months[monthIndex] || '-';
                    if (newValue !== oldValue) {
                        hasChanges = true;
                        console.log(`      ACTUAL CHANGE: ${customer.name} - ${network.name} - Month ${monthIndex + 1}: "${oldValue}"  "${newValue}"`);
                    }
                } else {
                    // CRITICAL: If input not found, this network was NOT in the edit modal
                    // So do NOT mark it as changed - keep original value
                    const originalValue = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    updatedMonths[monthIndex] = originalValue;
                    console.log(`      NOT IN MODAL: ${customer.name} - ${network.name} - Month ${monthIndex + 1} keeping original: "${originalValue}"`);
                }
            }
            
            // CRITICAL: Only mark as edited if there were ACTUAL changes
            if (hasChanges) {
                network.months = updatedMonths;
                network.monthly_runs = updatedMonths;
                network.editedData = true; // Mark as edited ONLY if changes found
                
                // Store edited data in localStorage for DB customers too
                const storageKey = `edited_db_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                localStorage.setItem(storageKey, JSON.stringify({
                    months: updatedMonths,
                    originalMonths: network.originalMonths,
                    timestamp: Date.now(),
                    customer: customer.name,
                    network: network.name,
                    source: 'db'
                }));
                
                updatedCount++;
                console.log(`    ACTUALLY EDITED: ${customer.name} - ${network.name} (saved to localStorage)`);
            } else {
                // CRITICAL: Ensure editedData flag is FALSE for non-edited networks
                network.editedData = false;
                console.log(`    NO CHANGES: ${customer.name} - ${network.name} - keeping original state (editedData = false)`);
            }
        });
    });
    
    // Success notification
    const excelCount = excelCustomers.reduce((count, customer) => 
        count + customer.networks.length, 0
    );
    const dbCount = updatedCount - excelCount;
    
    let message = '';
    if (updatedCount > 0) {
        if (excelCount > 0 && dbCount > 0) {
            message = ` Updated ${excelCount} Excel networks and ${dbCount} DB networks! (Local changes)`;
        } else if (excelCount > 0) {
            message = ` Updated ${excelCount} Excel networks! (Local changes)`;
        } else {
            message = ` Updated ${dbCount} DB networks! (Local changes)`;
        }
    } else {
        message = ` No changes detected`;
    }
    
    showNotification(message, 'success');
    closeBulkEditModal();
    
    //  TRACK WHICH CUSTOMERS WERE CHANGED
    const changedCustomerNames = new Set();
    
    // Excel customers that changed
    excelCustomers.forEach((customer) => {
        let customerChanged = false;
        customer.networks.forEach((network) => {
            if (network.editedData) {
                customerChanged = true;
            }
        });
        if (customerChanged) {
            changedCustomerNames.add(customer.name);
        }
    });
    
    // DB customers that changed
    dbCustomers.forEach((customer) => {
        let customerChanged = false;
        customer.networks.forEach((network) => {
            if (network.editedData) {
                customerChanged = true;
            }
        });
        if (customerChanged) {
            changedCustomerNames.add(customer.name);
        }
    });
    
    console.log(` Changed customers: ${Array.from(changedCustomerNames).join(', ')}`);
    
    // Update ONLY the changed customers - don't touch others
    if (updatedCount > 0) {
        console.log(` Updated ${updatedCount} networks - refreshing ONLY changed customers`);
        
        setTimeout(() => {
            // Update each changed customer individually
            Array.from(changedCustomerNames).forEach(customerName => {
                console.log(` Updating ONLY customer: ${customerName}`);
                updateSpecificCustomerOnly(customerName);
            });
            
            // Update simple graphs if they exist
            if (window.updateAllSimpleGraphs) {
                window.updateAllSimpleGraphs();
            }
        }, 300);
        
        console.log(` Updated ONLY ${changedCustomerNames.size} changed customers - others untouched!`);
    }
}

// LIVE DB EDIT MODAL - Only for Live Database customers (no Excel)
function openLiveDBEditModal() {
    console.log(' Opening Live DB-only edit modal');
    
    // Prevent multiple modals
    const existingModal = document.getElementById('liveDBEditModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Get ALL customers and filter properly
    const allCustomers = Object.values(dashboardData.customers);
    
    // DEBUG: Log all available customers
    console.log(` TOTAL CUSTOMERS FOUND: ${allCustomers.length}`);
    
    // Filter Live DB customers using SAME logic as dashboard updateCustomerGrid()
    const liveDBCustomers = [];
    Object.values(allCustomers).forEach(customer => {
        // EXACT SAME FILTERING AS DASHBOARD - Skip Excel customers completely
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            console.log(` EXCLUDING Excel customer: ${customer.name} (excel_source=${customer.excel_source}, excel_only=${customer.excel_only}, excel_data=${customer.excel_data})`);
            return; // Skip this customer entirely
        }
        
        console.log(` INCLUDING Live DB customer: ${customer.name}`);
        liveDBCustomers.push(customer);
    });
    
    console.log(` Found ${liveDBCustomers.length} Live DB customers for editing`);
    
    if (liveDBCustomers.length === 0) {
        showNotification(' No Live DB customers found to edit', 'error');
        return;
    }
    
    // Use same year detection as dashboard
    const currentYear = new Date().getFullYear();
    let displayYear = currentYear;
    const dataYears = new Set();
    
    // Scan for actual data years
    liveDBCustomers.forEach(customer => {
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                if (network.last_run_date && network.last_run_date !== 'Never' && network.runs > 0) {
                    const networkDate = fixDateParsing(network.last_run_date);
                    if (networkDate) {
                        dataYears.add(networkDate.getFullYear());
                    }
                }
            });
        }
    });
    
    if (dataYears.size > 0) {
        displayYear = Math.max(...Array.from(dataYears));
        console.log(` AUTO-DETECTED DISPLAY YEAR: ${displayYear}`);
    }
    
    // Create compact modal with fixed styling
    const modal = document.createElement('div');
    modal.id = 'liveDBEditModal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center;
        align-items: center; z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: #ffffff;
        border-radius: 10px;
        width: 98%;
        max-width: 1600px;
        max-height: 95vh;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        border: 2px solid #10b981;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    `;
    
    // Generate months
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    let customersHtml = '';
    
    // Process each Live DB customer
    liveDBCustomers.forEach((customer, customerIndex) => {
        let networksHtml = '';
        const totalNetworks = customer.networks ? customer.networks.length : 0;
        const totalRuns = customer.runs || customer.total_runs || 0;
        
        // Process networks if available
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                // Clean network name
                let networkName = network.network_name || network.name || `Network ${networkIndex + 1}`;
                if (typeof networkName === 'string' && networkName.includes(' - ')) {
                    const parts = networkName.split(' - ');
                    if (parts.length > 1) {
                        networkName = parts.slice(1).join(' - ') || parts[0];
                    }
                }
                
                // Generate month inputs with SAME data as dashboard
                const monthInputs = months.map((month, monthIndex) => {
                    let value = '-';
                    
                    // Use SAME logic as dashboard to get dates
                    try {
                        const monthRunData = getNetworkMonthRunDates(customer, network.name || network.network_name, displayYear, monthIndex + 1);
                        if (monthRunData && monthRunData.date && monthRunData.date !== '-') {
                            value = monthRunData.date;
                        } else {
                            // Fallback: check customer level data
                            const customerMonthData = getCustomerMonthRunDates(customer, displayYear, monthIndex + 1);
                            if (customerMonthData && customerMonthData.date && customerMonthData.date !== '-') {
                                value = customerMonthData.date;
                            }
                        }
                    } catch (e) {
                        console.log(` Error getting date for ${customer.name} - ${networkName} - ${month}: ${e.message}`);
                        value = '-';
                    }
                    
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.65rem; font-weight: 600; color: #065f46; margin-bottom: 2px;">${month}</label>
                            <input type="text" 
                                   id="livedb_customer_${customerIndex}_network_${networkIndex}_month_${monthIndex}" 
                                   value="${value}" 
                                   placeholder="DD-MMM"
                                   style="width: 65px; padding: 4px 2px; font-size: 0.7rem; text-align: center;
                                          border: 1px solid #d1fae5; border-radius: 3px; 
                                          background: #f0fdf4; font-weight: 500;
                                          transition: all 0.2s ease;"
                                   onfocus="this.style.borderColor='#10b981'; this.style.background='#ffffff';"
                                   onblur="this.style.borderColor='#d1fae5'; this.style.background='#f0fdf4';" />
                        </div>
                    `;
                }).join('');
                
                networksHtml += `
                    <div style="margin: 8px 0; padding: 12px; border: 1px solid #d1fae5; border-radius: 6px; 
                                background: #f8fafc;">
                        <div style="margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                            <h6 style="margin: 0; color: #065f46; font-weight: 600; font-size: 0.85rem;">
                                 ${networkName}
                            </h6>
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 8px; 
                                             font-size: 0.6rem; font-weight: 600;">DB</span>
                                <span style="background: #6b7280; color: white; padding: 2px 4px; border-radius: 6px; 
                                             font-size: 0.55rem;">N${networkIndex + 1}</span>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 4px;
                                    background: white; padding: 8px; border-radius: 4px; border: 1px solid #e5e7eb;">
                            ${monthInputs}
                        </div>
                    </div>
                `;
            });
        } else {
            // No networks - show customer level data
            const monthInputs = months.map((month, monthIndex) => {
                let value = '-';
                try {
                    const customerMonthData = getCustomerMonthRunDates(customer, displayYear, monthIndex + 1);
                    if (customerMonthData && customerMonthData.date && customerMonthData.date !== '-') {
                        value = customerMonthData.date;
                    }
                } catch (e) {
                    value = '-';
                }
                
                return `
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <label style="font-size: 0.65rem; font-weight: 600; color: #065f46; margin-bottom: 2px;">${month}</label>
                        <input type="text" 
                               id="livedb_customer_${customerIndex}_network_0_month_${monthIndex}" 
                               value="${value}" 
                               placeholder="DD-MMM"
                               style="width: 65px; padding: 4px 2px; font-size: 0.7rem; text-align: center;
                                      border: 1px solid #d1fae5; border-radius: 3px; 
                                      background: #f0fdf4; font-weight: 500;"
                               onfocus="this.style.borderColor='#10b981'; this.style.background='#ffffff';"
                               onblur="this.style.borderColor='#d1fae5'; this.style.background='#f0fdf4';" />
                    </div>
                `;
            }).join('');
            
            networksHtml = `
                <div style="margin: 8px 0; padding: 12px; border: 1px solid #d1fae5; border-radius: 6px; 
                            background: #f8fafc;">
                    <div style="margin-bottom: 8px; text-align: center;">
                        <h6 style="margin: 0; color: #065f46; font-weight: 600; font-size: 0.85rem;">
                             Customer Level Data
                        </h6>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 4px;
                                background: white; padding: 8px; border-radius: 4px; border: 1px solid #e5e7eb;">
                        ${monthInputs}
                    </div>
                </div>
            `;
        }
        
        customersHtml += `
            <div style="margin: 10px; padding: 15px; border: 2px solid #10b981; border-radius: 8px; 
                        background: #ffffff;">
                <div style="margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px;">
                    <div>
                        <h4 style="margin: 0; color: #065f46; font-size: 1.1rem; font-weight: 700;">
                             ${customer.name}
                        </h4>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; flex-wrap: wrap;">
                        <span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 12px; 
                                     font-size: 0.65rem; font-weight: 600;">DB</span>
                        <span style="background: #6b7280; color: white; padding: 2px 6px; border-radius: 10px; 
                                     font-size: 0.6rem;">${totalNetworks}N</span>
                        <span style="background: #065f46; color: white; padding: 2px 6px; border-radius: 10px; 
                                     font-size: 0.6rem;">${totalRuns}R</span>
                    </div>
                </div>
                ${networksHtml}
            </div>
        `;
    });
    
    modalContent.innerHTML = `
        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 12px 20px; color: white; 
                    display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap;">
            <div>
                <h3 style="margin: 0; font-size: 1.3rem; font-weight: 800;">
                     Live Dashboard Editor
                </h3>
                <p style="margin: 2px 0 0 0; font-size: 0.8rem; opacity: 0.9;">
                    Format: DD-MMM-YY
                </p>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveLiveDBEdit()" 
                        style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);
                               padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85rem;
                               transition: all 0.2s ease;"
                        onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                        onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                     Save
                </button>
                <button onclick="closeLiveDBEditModal()" 
                        style="background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
                               padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85rem;
                               transition: all 0.2s ease;"
                        onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                        onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                     Close
                </button>
            </div>
        </div>
        
        <div style="flex: 1; overflow-y: auto; padding: 10px;">
            ${customersHtml}
        </div>
    `;
    
    // Add click outside to close
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeLiveDBEditModal();
        }
    });
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    console.log(' Live DB Edit Modal opened successfully');
}

function closeLiveDBEditModal() {
    const modal = document.getElementById('liveDBEditModal');
    if (modal) {
        modal.remove();
    }
}

function saveLiveDBEdit() {
    console.log(' Saving ONLY edited changes...');
    
    // Get ONLY Live DB customers - EXACT SAME filtering as modal and dashboard
    const allCustomers = Object.values(dashboardData.customers);
    const liveDBCustomers = [];
    Object.values(allCustomers).forEach(customer => {
        // EXACT SAME FILTERING AS DASHBOARD
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        liveDBCustomers.push(customer);
    });
    
    let updatedCount = 0;
    let changedNetworks = [];
    
    // Process each Live DB customer with debug logging
    console.log(` PROCESSING ${liveDBCustomers.length} Live DB customers for save:`);
    liveDBCustomers.forEach((customer, customerIndex) => {
        console.log(` [${customerIndex}] Processing: ${customer.name}`);
        console.log(` Customer has ${customer.networks ? customer.networks.length : 0} networks`);
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                const inputId = `livedb_customer_${customerIndex}_network_${networkIndex}_month_`;
                
                let hasChanges = false;
                const newMonths = [];
                const originalMonths = network.months ? [...network.months] : Array(12).fill('-');
                
                // Check each month for changes
                for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                    const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                    
                    if (inputElement) {
                        const newValue = inputElement.value.trim() || '-';
                        const oldValue = originalMonths[monthIndex] || '-';
                        
                        newMonths[monthIndex] = newValue;
                        
                        // Check if value actually changed
                        if (newValue !== oldValue) {
                            hasChanges = true;
                            console.log(` CHANGE DETECTED: ${customer.name} - ${network.name} - Month ${monthIndex + 1}: "${oldValue}"  "${newValue}"`);
                        }
                    } else {
                        // Keep original if input not found
                        newMonths[monthIndex] = originalMonths[monthIndex] || '-';
                    }
                }
                
                // CRITICAL: Only update if there are ACTUAL changes
                if (hasChanges) {
                    // Store original data before first edit (ONLY if not already stored)
                    if (!network.originalMonths) {
                        network.originalMonths = [...originalMonths];
                        console.log(` Backed up original data for ${customer.name} - ${network.name}`);
                    }
                    
                    // Update ONLY the months data for VISUAL display (DO NOT TOUCH ANYTHING ELSE)
                    network.months = [...newMonths];
                    network.monthly_runs = [...newMonths];
                    network.editedData = true;
                    
                    // CRITICAL: PRESERVE original runs count and all statistics
                    // DO NOT let the system recalculate runs from months data
                    // Keep original API data intact
                    
                    // Save to localStorage for persistence
                    const storageKey = `edited_livedb_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                    localStorage.setItem(storageKey, JSON.stringify({
                        months: newMonths,
                        originalMonths: network.originalMonths,
                        timestamp: Date.now(),
                        customer: customer.name,
                        network: network.name,
                        source: 'livedb'
                    }));
                    
                    changedNetworks.push(`${customer.name} - ${network.name}`);
                    updatedCount++;
                    
                    console.log(` ONLY EDITED MONTHS for: ${customer.name} - ${network.name}`);
                    console.log(` KEPT UNCHANGED: runs, total_runs, statistics`);
                } else {
                    // No changes - don't touch anything
                    console.log(` NO CHANGES: ${customer.name} - ${network.name} - left completely untouched`);
                }
            });
        } else {
            // Handle customer-level data (no networks)
            const inputId = `livedb_customer_${customerIndex}_network_0_month_`;
            let hasChanges = false;
            const newMonths = [];
            const originalMonths = customer.months ? [...customer.months] : Array(12).fill('-');
            
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                
                if (inputElement) {
                    const newValue = inputElement.value.trim() || '-';
                    const oldValue = originalMonths[monthIndex] || '-';
                    
                    newMonths[monthIndex] = newValue;
                    
                    if (newValue !== oldValue) {
                        hasChanges = true;
                        console.log(` CUSTOMER LEVEL CHANGE: ${customer.name} - Month ${monthIndex + 1}: "${oldValue}"  "${newValue}"`);
                    }
                } else {
                    newMonths[monthIndex] = originalMonths[monthIndex] || '-';
                }
            }
            
            if (hasChanges) {
                // Store original data (ONLY if not already stored)
                if (!customer.originalMonths) {
                    customer.originalMonths = [...originalMonths];
                    console.log(` Backed up original customer data for ${customer.name}`);
                }
                
                // Update ONLY the months data (DO NOT TOUCH RUNS OR STATISTICS)
                customer.months = [...newMonths];
                customer.editedData = true;
                
                // CRITICAL: DO NOT UPDATE customer runs, total_runs, or any counters
                
                const storageKey = `edited_livedb_customer_${customer.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                localStorage.setItem(storageKey, JSON.stringify({
                    months: newMonths,
                    originalMonths: customer.originalMonths,
                    timestamp: Date.now(),
                    customer: customer.name,
                    source: 'livedb_customer'
                }));
                
                changedNetworks.push(`${customer.name} (Customer Level)`);
                updatedCount++;
                
                console.log(` ONLY EDITED CUSTOMER MONTHS for: ${customer.name}`);
                console.log(` KEPT UNCHANGED: customer runs, statistics`);
            } else {
                console.log(` NO CUSTOMER CHANGES: ${customer.name} - left completely untouched`);
            }
        }
    });
    
    // Show results
    if (updatedCount > 0) {
        console.log(` SAVED ${updatedCount} changes:`, changedNetworks);
        showNotification(` Saved ${updatedCount} changes! (${changedNetworks.join(', ')})`, 'success');
        
        // CRITICAL: Update only the specific customers that were edited
        console.log(` Updating only edited customers: ${changedNetworks.join(', ')}`);
        
        // Extract unique customer names from changed networks
        const uniqueCustomers = new Set();
        changedNetworks.forEach(item => {
            const customerName = item.includes(' - ') ? item.split(' - ')[0] : item.replace(' (Customer Level)', '');
            uniqueCustomers.add(customerName);
        });
        
        console.log(` Live DB changed customers: ${Array.from(uniqueCustomers).join(', ')}`);
        
        // Update only changed customers individually
        setTimeout(() => {
            Array.from(uniqueCustomers).forEach(customerName => {
                console.log(` Live DB: Updating ONLY customer: ${customerName}`);
                updateSpecificCustomerOnly(customerName);
            });
            
            // Update simple graphs if they exist
            if (window.updateAllSimpleGraphs) {
                window.updateAllSimpleGraphs();
            }
            
            console.log(` Live DB: Updated ONLY ${uniqueCustomers.size} changed customers - others untouched!`);
        }, 300);
        
        console.log(` IMPORTANT: Statistics, graphs, and header counts kept unchanged`);
    } else {
        console.log(` No changes detected`);
        showNotification(' No changes detected', 'info');
    }
    
    closeLiveDBEditModal();
}

// UPDATE ONLY SPECIFIC EDITED CUSTOMERS - LEAVE OTHERS UNTOUCHED
function updateSpecificCustomers(changedNetworks) {
    if (!changedNetworks || changedNetworks.length === 0) {
        console.log(' No specific customers to update');
        return;
    }
    
    console.log(` Updating only these customers: ${changedNetworks.join(', ')}`);
    
    const tableBody = document.getElementById('customer-table-body');
    if (!tableBody) {
        console.log(' Table body not found');
        return;
    }
    
    // Get current year and months for display
    const currentYear = new Date().getFullYear();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Process each changed customer/network
    changedNetworks.forEach(changeItem => {
        let customerName, networkName;
        
        if (changeItem.includes(' (Customer Level)')) {
            // Customer-level change
            customerName = changeItem.replace(' (Customer Level)', '');
            networkName = null;
        } else if (changeItem.includes(' - ')) {
            // Network-level change
            const parts = changeItem.split(' - ');
            customerName = parts[0];
            networkName = parts[1];
        } else {
            customerName = changeItem;
            networkName = null;
        }
        
        console.log(` Updating customer: ${customerName}, network: ${networkName || 'all'}`);
        
        // Find the customer in data
        const customer = Object.values(dashboardData.customers).find(c => c.name === customerName);
        if (!customer) {
            console.log(` Customer ${customerName} not found in data`);
            return;
        }
        
        // Find existing customer rows in table
        const existingRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => {
            const nameCell = row.querySelector('.customer-name-cell');
            if (nameCell && nameCell.textContent.includes(customerName)) {
                return true;
            }
            return false;
        });
        
        console.log(` Found ${existingRows.length} existing rows for ${customerName}`);
        
        if (existingRows.length > 0) {
            // Remove existing rows for this customer
            existingRows.forEach(row => {
                console.log(` Removing old row for ${customerName}`);
                row.remove();
            });
            
            // Create new updated rows for this customer
            const customerRow = createCustomerSummaryRow(customer, currentYear, months);
            
            // Find insertion point (try to maintain original order)
            const allRows = Array.from(tableBody.querySelectorAll('tr'));
            let insertBeforeRow = null;
            
            // Try to find where this customer should be inserted based on original order
            const customerOrder = Object.keys(dashboardData.customers);
            const customerIndex = customerOrder.findIndex(key => 
                dashboardData.customers[key].name === customerName
            );
            
            if (customerIndex >= 0) {
                // Find the next customer in order that exists in table
                for (let i = customerIndex + 1; i < customerOrder.length; i++) {
                    const nextCustomerName = dashboardData.customers[customerOrder[i]].name;
                    const nextRow = allRows.find(row => {
                        const nameCell = row.querySelector('.customer-name-cell');
                        return nameCell && nameCell.textContent.includes(nextCustomerName);
                    });
                    if (nextRow) {
                        insertBeforeRow = nextRow;
                        break;
                    }
                }
            }
            
            // Insert the updated customer row
            if (insertBeforeRow) {
                tableBody.insertBefore(customerRow, insertBeforeRow);
                console.log(` Inserted updated ${customerName} row before ${insertBeforeRow.textContent.substring(0, 20)}...`);
            } else {
                tableBody.appendChild(customerRow);
                console.log(` Appended updated ${customerName} row at end`);
            }
            
            // Add network rows if customer has networks
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, networkIndex) => {
                    const networkRow = createNetworkDetailRow(customer, network, networkIndex, currentYear, months);
                    
                    if (insertBeforeRow) {
                        tableBody.insertBefore(networkRow, insertBeforeRow);
                    } else {
                        tableBody.appendChild(networkRow);
                    }
                });
                console.log(` Added ${customer.networks.length} network rows for ${customerName}`);
            }
            
            console.log(` Successfully updated ${customerName} in table`);
        } else {
            console.log(` No existing rows found for ${customerName} - skipping update`);
        }
    });
    
    console.log(` Specific customer update completed`);
}

function updateCustomerGrid() {
    const tableBody = document.getElementById('customer-table-body');
    const customers = dashboardData.customers;
    
    if (!customers || Object.keys(customers).length === 0) {
        tableBody.innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;">No customer data available</td></tr>';
        return;
    }
    
    tableBody.innerHTML = '';
    
    // Get current year for month calculations - AUTO DETECT YEAR FROM DATA
    const currentYear = new Date().getFullYear();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Track if we have any customers to display
    let customersToDisplay = 0;
    
    // Auto-detect which year to use based on actual data
    let displayYear = currentYear;
    const dataYears = new Set();
    
    // Scan all customer data to find which years have actual data
    Object.values(customers).forEach(customer => {
        // Skip Excel customers from year detection - only use Live DB customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                if (network.last_run_date && network.last_run_date !== 'Never' && network.runs > 0) {
                    const networkDate = fixDateParsing(network.last_run_date);
                    if (networkDate) {
                        dataYears.add(networkDate.getFullYear());
                    }
                }
            });
        }
    });
    
    // Use the most recent year with data, or current year as fallback
    if (dataYears.size > 0) {
        displayYear = Math.max(...Array.from(dataYears));
        console.log(` AUTO-DETECTED DISPLAY YEAR: ${displayYear} (found data years: ${Array.from(dataYears).join(', ')})`);
    } else {
        console.log(` USING CURRENT YEAR: ${displayYear} (no data found in any year)`);
    }
    
    Object.values(customers).forEach(customer => {
        // SKIP Excel customers completely - only show Live DB customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            console.log(` HIDING Excel customer: ${customer.name} (excel_source=${customer.excel_source}, excel_only=${customer.excel_only}, excel_data=${customer.excel_data})`);
            return; // Skip this customer entirely
        }
        
        //  NEW: When date filter is active, hide customers with NO data in that range
        console.log(` Filter Check for ${customer.name}:`, { isFilterActive, currentStartDate, currentEndDate });
        
        if (isFilterActive && currentStartDate && currentEndDate) {
            const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
            console.log(`    ${customer.name} runs in filtered period: ${totalRuns}`);
            
            // Check if customer has any actual data in filtered range
            if (totalRuns === 0) {
                console.log(`    HIDING ${customer.name} - No data in filtered range (${currentStartDate} to ${currentEndDate})`);
                return; // Skip customers with no data in the filtered period
            }
            console.log(`    SHOWING ${customer.name} - Has ${totalRuns} runs in filtered range`);
        } else {
            console.log(`    No filter active - showing all customers`);
        }
        
        console.log(` SHOWING Live DB customer: ${customer.name}`);
        customersToDisplay++; // Count this customer
        
        // 1. CUSTOMER LEVEL ROW (Summary)
        const customerRow = createCustomerSummaryRow(customer, displayYear, months);
        tableBody.appendChild(customerRow);
        
        // 2. NETWORK LEVEL ROWS (Individual networks)
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                const networkRow = createNetworkDetailRow(customer, network, networkIndex, displayYear, months);
                tableBody.appendChild(networkRow);
            });
        }
    });
    
    //  NEW: Show message if no customers have data in the filtered range
    if (customersToDisplay === 0 && isFilterActive && currentStartDate && currentEndDate) {
        const filterStartFormatted = new Date(currentStartDate).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        const filterEndFormatted = new Date(currentEndDate).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        
        tableBody.innerHTML = `
            <tr>
                <td colspan="19" style="padding: 60px 40px; text-align: center; color: #6b7280; background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));">
                    <div style="font-size: 3rem; margin-bottom: 16px; opacity: 0.5;"></div>
                    <div style="font-size: 1.2rem; font-weight: 600; color: #374151; margin-bottom: 8px;">No Data Available</div>
                    <div style="font-size: 0.95rem; color: #6b7280; margin-bottom: 24px;">
                        No health check runs found between <strong>${filterStartFormatted}</strong> and <strong>${filterEndFormatted}</strong>
                    </div>
                    <div style="font-size: 0.85rem; color: #9ca3af; line-height: 1.6;">
                         Run health checks in this time period to see data<br>
                         Or clear the filter to view all available data
                    </div>
                </td>
            </tr>
        `;
        console.log(` No customers to display for date range: ${currentStartDate} to ${currentEndDate}`);
    }
}

// CREATE CUSTOMER SUMMARY ROW
function createCustomerSummaryRow(customer, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'customer-summary-row';
    
    // ENHANCED: Use the ACTUAL last run date we retrieved, with multiple fallbacks
    let lastRunInfo = 'Never';
    let lastRunDateStr = customer.actual_last_run || customer.last_run_date;
    
    if (lastRunDateStr && lastRunDateStr !== 'Never' && lastRunDateStr !== '-') {
        const lastRunDate = fixDateParsing(lastRunDateStr);
        if (lastRunDate) {
            // Format as DD-MM-YY instead of MM-DD-YY
            const day = lastRunDate.getDate().toString().padStart(2, '0');
            const month = (lastRunDate.getMonth() + 1).toString().padStart(2, '0');
            const year = lastRunDate.getFullYear().toString().slice(-2);
            lastRunInfo = `${day}-${month}-${year}`;
            console.log(` DISPLAYING: Customer "${customer.name}" - "${lastRunDateStr}" -> ${lastRunInfo}`);
        } else {
            console.log(` PARSE FAILED: Customer "${customer.name}" - Could not parse "${lastRunDateStr}"`);
            lastRunInfo = lastRunDateStr; // Show original string if parsing fails
        }
    } else {
        console.log(` NO DATE: Customer "${customer.name}" has no valid date information`);
        
        // Check if customer has runs but no date - this indicates missing date integration
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        if (totalRuns > 0) {
            lastRunInfo = 'Date missing'; // Clearly indicate missing date for customers with runs
            console.log(` DATE INTEGRATION ISSUE: Customer "${customer.name}" has ${totalRuns} runs but no date!`);
        }
    }
    
    // Customer Name with Source Indicator
    const customerCell = document.createElement('td');
    customerCell.className = 'customer-name-cell customer-summary';
    
    // Determine source badge
    let sourceBadge = '';
    let sourceIcon = ''; // Remove all icons - no need for them
    
    if (customer.excel_only || customer.excel_data) {
        // Excel customers: No badge, clean name only
        sourceBadge = '';
        sourceIcon = '';
    } else {
        // Live DB customers: Keep the badge
        sourceBadge = '<span style="font-size: 0.6rem; background: #10b981; color: white; padding: 1px 4px; border-radius: 3px; margin-left: 4px;">Live DB</span>';
        sourceIcon = ''; // Remove disk icon - not needed
    }
    
    customerCell.innerHTML = `
        <div class="customer-name-container">
            <div class="customer-name-main">${sourceIcon} ${customer.name || 'Unknown Customer'}${sourceBadge}</div>
            <div class="customer-last-run">Last run: ${lastRunInfo}</div>
        </div>
    `;
    row.appendChild(customerCell);
    
    // Country - Fix field mapping
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col customer-summary';
    const country = customer.country || customer.location || customer.region || 'Unknown';
    countryCell.textContent = country;
    countryCell.style.color = country === 'Unknown' ? '#9ca3af' : '#374151';
    row.appendChild(countryCell);
    
    // Networks Summary - Compact with collapsible view
    const networksCell = document.createElement('td');
    networksCell.className = 'networks-cell customer-summary';
    let networkCount = 0;
    let networksList = [];
    
    if (customer.networks_count) {
        networkCount = customer.networks_count;
    } else if (customer.networks && customer.networks.length > 0) {
        networkCount = customer.networks.length;
        networksList = customer.networks;
    } else if (customer.excel_source && customer.runs > 0) {
        // For Excel customers without networks array, estimate from runs
        networkCount = Math.max(1, Math.floor(customer.runs / 5)); // Rough estimate
    }
    
    // Create compact network display
    const customerKey = customer.name.replace(/[^a-zA-Z0-9]/g, '_');
    const networkButtonId = `networks_${customerKey}`;
    
    let networksContent = '';
    if (networkCount > 1) {
        // Multiple networks - show compact button
        networksContent = `
            <div class="networks-compact">
                <button class="network-toggle-btn" onclick="toggleNetworks('${networkButtonId}')">
                    <span class="network-count">${networkCount} NETWORKS</span>
                    <svg class="toggle-icon" width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 10l5 5 5-5z"/>
                    </svg>
                </button>
                <div class="networks-dropdown" id="${networkButtonId}" style="display: none;">
                    ${networksList.map((network, idx) => `
                        <div class="network-item">
                            <span class="network-name">${network.network_name || network.name || `Network ${idx + 1}`}</span>
                            <span class="network-runs">${network.runs || network.total_runs || 0} runs</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    } else if (networkCount === 1) {
        // Single network - show simple badge
        const networkName = networksList[0]?.network_name || networksList[0]?.name || 'Default Network';
        networksContent = `
            <div class="single-network">
                <span class="network-badge">1 NETWORK</span>
                <div class="network-name-small">${networkName}</div>
            </div>
        `;
    } else {
        // No networks
        networksContent = `
            <div class="no-networks">
                <span class="network-badge">0 NETWORKS</span>
            </div>
        `;
    }
    
    networksCell.innerHTML = networksContent;
    row.appendChild(networksCell);
    
    // Node Qty - Enhanced logic to fetch from multiple sources
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col customer-summary';
    
    let nodeQty = 0;
    
    // Debug: Log available customer data fields
    console.log(` DEBUG: Customer "${customer.name}" available fields:`, Object.keys(customer));
    console.log(` DEBUG: Customer "${customer.name}" full data:`, customer);
    console.log(` DEBUG: node_count = ${customer.node_count}, country = ${customer.country}`);
    console.log(` DEBUG: runs = ${customer.runs}, networks = ${customer.networks_count}`);
    
    // Force update for testing
    if (customer.name && customer.name.toUpperCase().includes('BSNL')) {
        console.log(` BSNL CUSTOMER DETECTED: ${customer.name}`);
        console.log(' Available fields:', Object.keys(customer));
        console.log(' Field values:', {
            node_count: customer.node_count,
            country: customer.country,
            runs: customer.runs,
            networks_count: customer.networks_count
        });
    }
    
    // Fix: Try multiple data sources for node quantity with Excel mapping
    nodeQty = customer.node_count || customer.node_qty || customer.total_nodes || 0;
    
    // Special handling for Excel data
    if (!nodeQty && customer.excel_source) {
        console.log(`Excel customer ${customer.name} - checking all fields:`, Object.keys(customer));
    }
    
    // If still no data, try to calculate from networks
    if (!nodeQty && customer.networks && customer.networks.length > 0) {
        nodeQty = customer.networks.reduce((total, network) => {
            return total + (network.node_count || network.nodes || network.total_nodes || 0);
        }, 0);
    }
    
    // Debug: Log what we found
    console.log(` DEBUG: Customer "${customer.name}" - nodeQty found: ${nodeQty}, runs: ${customer.runs}, run_count: ${customer.run_count}`);
    
    // For now, show 0 instead of N/A to see the layout
    nodeQtyCell.textContent = nodeQty || '0';
    nodeQtyCell.style.fontWeight = '600';
    
    if (nodeQty > 0) {
        nodeQtyCell.style.color = '#059669'; // Green for real data
        nodeQtyCell.title = `${nodeQty} nodes from health check report`;
    } else if (customer.runs > 0 || customer.run_count > 0) {
        nodeQtyCell.style.color = '#f59e0b'; // Orange for missing data
        nodeQtyCell.title = 'Node count not found in API data - check available fields in console';
    } else {
        nodeQtyCell.style.color = '#9ca3af'; // Gray for no runs
        nodeQtyCell.title = 'No runs available';
    }
    
    row.appendChild(nodeQtyCell);
    
    // NE Type - Fix to use Excel data properly
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col customer-summary';
    neTypeCell.textContent = customer.nw_type || customer.ne_type || customer.network_type || '1830 PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#6b7280';
    row.appendChild(neTypeCell);
    
    // GTAC - Fix to use Excel data properly
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col customer-summary';
    const gtacType = customer.gtac_team || customer.gtac || customer.gtac_type || 'PSS';
    gtacCell.innerHTML = `<span style="background: ${gtacType.toLowerCase() === 'classic' ? '#dc2626' : '#059669'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${gtacType}</span>`;
    row.appendChild(gtacCell);
    
    // Monthly data (Customer total) - ALWAYS show ALL 12 months for alignment
    let totalRuns = 0;
    
    months.forEach((month, monthIndex) => {
        const monthCell = document.createElement('td');
        monthCell.className = 'run-count customer-summary';
        
        let shouldShowData = true;
        let latestDate = '-';
        let totalRunsThisMonth = 0;
        
        // Check if this month should be filtered out
        if (window.isMonthFilterActive) {
            shouldShowData = isMonthFiltered(monthIndex);
        }
        
        if (shouldShowData) {
            // Show data for filtered months
            // Check all networks for this month and find the latest date
            if (customer.networks && Array.isArray(customer.networks)) {
                let latestDateObj = null;
                
                customer.networks.forEach(network => {
                    if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                        const monthValue = network.monthly_runs[monthIndex];
                        if (monthValue && monthValue !== '-' && !monthValue.includes('Not') && !monthValue.includes('No')) {
                            totalRunsThisMonth++;
                            
                            // Try to parse the date to compare
                            if (monthValue.includes('-')) {
                                try {
                                    const parts = monthValue.split('-');
                                    if (parts.length >= 2) {
                                        // Assume DD-MM format
                                        const day = parseInt(parts[0]);
                                        const monthNum = parseInt(parts[1]) || (monthIndex + 1);
                                        const year = currentYear;
                                        const dateObj = new Date(year, monthNum - 1, day);
                                        
                                        if (!latestDateObj || dateObj > latestDateObj) {
                                            latestDateObj = dateObj;
                                            latestDate = monthValue;
                                        }
                                    }
                                } catch (e) {
                                    // If parsing fails, just use first valid date found
                                    if (latestDate === '-') {
                                        latestDate = monthValue;
                                    }
                                }
                            }
                        } else if (monthValue && (monthValue.includes('Not') || monthValue.includes('No')) && latestDate === '-') {
                            // If no real dates found, show status message
                            latestDate = monthValue;
                        }
                    }
                });
            }
        } else {
            // Filtered out month
            latestDate = '-';
        }
        
        totalRuns += totalRunsThisMonth;
        
        if (latestDate && latestDate !== '-' && shouldShowData) {
            // Replace long status messages with shorter versions for display
            let displayText = latestDate;
            if (latestDate === 'Not Started') {
                displayText = 'N/S';
            } else if (latestDate === 'Not Run') {
                displayText = 'N/R';
            } else if (latestDate === 'No Report') {
                displayText = 'N/Rpt';
            }
            
            monthCell.textContent = displayText;
            monthCell.style.color = '#374151';
            monthCell.title = `${customer.name} - ${month}: Latest date from ${totalRunsThisMonth} network(s)`;
            
            // Bold for actual dates vs status messages
            if (latestDate.includes('-') && !latestDate.includes('Not') && !latestDate.includes('No')) {
                monthCell.style.fontWeight = '700';
            }
            
            // Highlight filtered months
            if (window.isMonthFilterActive) {
                monthCell.style.backgroundColor = '#ecfdf5';
                monthCell.style.borderLeft = '3px solid #10b981';
            }
        } else {
            monthCell.textContent = '-';
            monthCell.title = shouldShowData ? `No runs in ${month}` : 'Filtered out';
            monthCell.style.color = shouldShowData ? '#9ca3af' : '#f3f4f6';
            
            if (!shouldShowData && window.isMonthFilterActive) {
                monthCell.style.backgroundColor = '#f9fafb';
            }
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs - Use calculated runs that exclude status strings
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell customer-summary';
    
    // ULTRA STRICT: Only recalculate if THIS specific customer has actual edited networks
    let thisCustomerHasEdits = false;
    
    // Very strict check - only for this customer's networks
    if (customer.networks && customer.networks.length > 0) {
        thisCustomerHasEdits = customer.networks.some(network => 
            network.editedData === true && network.months && Array.isArray(network.months)
        );
    }
    
    let displayRuns = 0;
    
    // CORRECTED: Use network-level runs directly instead of monthly counting
    if (window.isMonthFilterActive) {
        // Filter is active - count only runs from filtered months (monthly data method)
        console.log(` FILTER ACTIVE: Calculating runs for ${customer.name} only from filtered months`);
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                    network.monthly_runs.forEach((monthValue, monthIndex) => {
                        // Only count runs from filtered months
                        if (isMonthFiltered(monthIndex)) {
                            if (monthValue && monthValue !== '-' && 
                                !monthValue.toLowerCase().includes('not') && 
                                !monthValue.toLowerCase().includes('never') &&
                                !monthValue.toLowerCase().includes('no') &&
                                monthValue.includes('-') && // Must be a date format
                                monthValue.match(/^\d{2}-\d{2}$/)) { // Must be DD-MM format
                                displayRuns += 1; // Each valid date = 1 run
                            }
                        }
                    });
                }
            });
        } else {
            // Customer without networks - check customer-level data
            if (customer.monthly_runs && Array.isArray(customer.monthly_runs)) {
                customer.monthly_runs.forEach((monthValue, monthIndex) => {
                    if (isMonthFiltered(monthIndex)) {
                        if (monthValue && monthValue !== '-' && 
                            !monthValue.toLowerCase().includes('not') && 
                            !monthValue.toLowerCase().includes('never') &&
                            !monthValue.toLowerCase().includes('no') &&
                            monthValue.includes('-') && // Must be a date format
                            monthValue.match(/^\d{2}-\d{2}$/)) { // Must be DD-MM format
                            displayRuns += 1;
                        }
                    }
                });
            }
        }
        console.log(` FILTERED TOTAL: ${customer.name} = ${displayRuns} runs (from filtered months only)`);
    } else if (thisCustomerHasEdits) {
        // No filter, but customer was edited: Recalculate total
        customer.networks.forEach(network => {
            if (network.editedData && network.months) {
                // Count valid dates from edited months (strict date format)
                const validDates = network.months.filter(monthValue => {
                    return monthValue && monthValue !== '-' && 
                           !monthValue.toLowerCase().includes('not') && 
                           !monthValue.toLowerCase().includes('never') &&
                           !monthValue.toLowerCase().includes('no') &&
                           monthValue.includes('-') && // Must be a date format
                           monthValue.match(/^\d{2}-\d{2}$/); // Must be DD-MM format
                }).length;
                displayRuns += validDates;
            } else {
                // Non-edited network in this customer - use original
                displayRuns += (network.runs || network.total_runs || 0);
            }
        });
        console.log(` RECALCULATED: ${customer.name} = ${displayRuns} runs (has edited networks)`);
    } else {
        // No filter, no edits: Use getNetworkRuns for consistency with network rows
        if (customer.networks && customer.networks.length > 0) {
            // Sum runs from all networks using the same getNetworkRuns function
            customer.networks.forEach(network => {
                let networkName = network.network_name || network.name || network;
                // Clean network name like in createNetworkDetailRow
                if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
                    networkName = network.network_name;
                } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
                    const cleanName = networkName.split(' - ').slice(1).join(' - ');
                    if (cleanName) {
                        networkName = cleanName;
                    }
                }
                const networkRuns = getNetworkRuns(customer, networkName) || 0;
                displayRuns += networkRuns;
            });
            console.log(` CONSISTENT NETWORK-BASED: ${customer.name} = ${displayRuns} runs (using getNetworkRuns for ${customer.networks.length} networks)`);
        } else {
            // Fallback to customer-level runs if no networks array
            displayRuns = customer.total_runs || customer.runs || customer.run_count || 0;
            console.log(` CUSTOMER-LEVEL: ${customer.name} = ${displayRuns} runs (no networks array)`);
        }
    }
    
    console.log(` CUSTOMER TOTAL DEBUG: ${customer.name}`);
    console.log(`   customer.total_runs: ${customer.total_runs}`);
    console.log(`   customer.runs: ${customer.runs}`);
    console.log(`   customer.run_count: ${customer.run_count}`);
    console.log(`   totalRuns (calculated): ${totalRuns}`);
    console.log(`   final displayRuns: ${displayRuns}`);
    
    totalCell.textContent = displayRuns;
    row.appendChild(totalCell);
    
    
    return row;
}

// CREATE NETWORK DETAIL ROW
function createNetworkDetailRow(customer, network, networkIndex, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'network-detail-row';
    
    // Clean network name - remove customer prefix like "Bsnl - "
    let networkName = network.network_name || network.name || network;
    
    // If network name is from network.name and has customer prefix, use network_name instead
    if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
        networkName = network.network_name;
        console.log(` CLEANED: "${network.name}" -> "${networkName}"`);
    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
        // Remove any prefix before " - " (like "Bsnl - Timedotcom Default" -> "Timedotcom Default")
        const cleanName = networkName.split(' - ').slice(1).join(' - ');
        if (cleanName) {
            console.log(` CLEANED PREFIX: "${networkName}" -> "${cleanName}"`);
            networkName = cleanName;
        }
    }
    
    const networkRuns = getNetworkRuns(customer, networkName) || 0;
    
    // Network Name (indented)
    const networkCell = document.createElement('td');
    networkCell.className = 'customer-name-cell network-detail';
    networkCell.innerHTML = `
        <div class="network-name-container">
            <div class="network-name-main">${networkName}</div>
            <div class="network-type">${network.network_type || 'Default Network'}</div>
        </div>
    `;
    row.appendChild(networkCell);
    
    // Country (empty for network rows)
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col network-detail';
    countryCell.textContent = '';
    row.appendChild(countryCell);
    
    // Network Status/Info
    const statusCell = document.createElement('td');
    statusCell.className = 'networks-cell network-detail';
    statusCell.innerHTML = `
        <div class="network-status">
            <span class="network-runs-badge">${networkRuns} runs</span>
        </div>
    `;
    row.appendChild(statusCell);
    
    // Node Qty for this network - Enhanced logic
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col network-detail';
    
    const networkNodeQty = network.node_count || 
                           network.nodes || 
                           network.total_nodes ||
                           network.node_quantity ||
                           (network.report_data && network.report_data.node_count) ||
                           0;
    
    if (networkNodeQty > 0) {
        nodeQtyCell.textContent = networkNodeQty;
        nodeQtyCell.style.color = '#6b7280';
        nodeQtyCell.title = `${networkNodeQty} nodes in this network`;
    } else {
        nodeQtyCell.textContent = '-';
        nodeQtyCell.style.color = '#9ca3af';
    }
    
    nodeQtyCell.style.fontSize = '0.75rem';
    row.appendChild(nodeQtyCell);
    
    // NE Type for this network
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col network-detail';
    neTypeCell.textContent = network.ne_type || network.equipment_type || 'PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#9ca3af';
    row.appendChild(neTypeCell);
    
    // GTAC (empty for network rows)
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col network-detail';
    gtacCell.textContent = '';
    row.appendChild(gtacCell);
    
    // Monthly data for this specific network - ALWAYS show ALL 12 months for alignment
    months.forEach((month, monthIndex) => {
        const monthCell = document.createElement('td');
        monthCell.className = 'run-count network-detail';
        
        let monthValue = '-';
        let shouldShowData = true;
        
        // Check if this month should be filtered out
        if (window.isMonthFilterActive) {
            shouldShowData = isMonthFiltered(monthIndex);
        }
        
        if (shouldShowData) {
            // Show data for this month
            if (network.monthly_runs && Array.isArray(network.monthly_runs) && network.monthly_runs[monthIndex]) {
                monthValue = network.monthly_runs[monthIndex];
                console.log(` DIRECT API: ${networkName} month ${monthIndex + 1} = "${monthValue}"`);
            } else {
                // Fallback to complex function
                const monthRunData = getNetworkMonthRunDates(customer, networkName, currentYear, monthIndex + 1);
                if (monthRunData && monthRunData.date && monthRunData.date !== '-' && monthRunData.date !== '0') {
                    monthValue = monthRunData.date;
                    console.log(` FALLBACK: ${networkName} month ${monthIndex + 1} = "${monthValue}"`);
                }
            }
        } else {
            // Filtered out month - show blank
            monthValue = '-';
        }
        
        // Display the month value
        if (monthValue && monthValue !== '-') {
            // Replace long status messages with shorter versions for display
            let displayText = monthValue;
            if (monthValue === 'Not Started') {
                displayText = 'N/S';
            } else if (monthValue === 'Not Run') {
                displayText = 'N/R';
            } else if (monthValue === 'No Report') {
                displayText = 'N/Rpt';
            }
            
            monthCell.textContent = displayText;
            monthCell.style.color = shouldShowData ? '#374151' : '#e5e7eb';
            monthCell.title = `${networkName} - ${month}: ${monthValue}`;
            
            // Bold for actual dates vs status messages
            if (monthValue.includes('-') && !monthValue.includes('Not') && !monthValue.includes('No')) {
                monthCell.style.fontWeight = '600';
            }
            
            // Highlight filtered months
            if (shouldShowData && window.isMonthFilterActive) {
                monthCell.style.backgroundColor = '#ecfdf5';
                monthCell.style.borderLeft = '3px solid #10b981';
            }
        } else {
            monthCell.textContent = '-';
            monthCell.title = shouldShowData ? `No runs from ${networkName} in ${month}` : 'Filtered out';
            monthCell.style.color = shouldShowData ? '#9ca3af' : '#f3f4f6';
            
            if (!shouldShowData && window.isMonthFilterActive) {
                monthCell.style.backgroundColor = '#f9fafb';
            }
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs for this network - FILTER-AWARE CALCULATION
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell network-detail';
    
    let displayNetworkRuns = networkRuns; // Default to original
    
    if (window.isMonthFilterActive) {
        // Filter is active - count only runs from filtered months
        displayNetworkRuns = 0;
        
        if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
            network.monthly_runs.forEach((monthValue, monthIndex) => {
                // Only count runs from filtered months
                if (isMonthFiltered(monthIndex)) {
                    if (monthValue && monthValue !== '-' && 
                        !monthValue.toLowerCase().includes('not') && 
                        !monthValue.toLowerCase().includes('never') &&
                        !monthValue.toLowerCase().includes('no') &&
                        monthValue.includes('-') && // Must be a date format
                        monthValue.match(/^\d{2}-\d{2}$/)) { // Must be DD-MM format
                        displayNetworkRuns += 1; // Each valid date = 1 run
                    }
                }
            });
        }
        
        console.log(` FILTERED NETWORK: ${networkName} = ${displayNetworkRuns} runs (from filtered months)`);
    }
    
    totalCell.textContent = displayNetworkRuns;
    
    // Style based on filter status
    if (window.isMonthFilterActive && displayNetworkRuns !== networkRuns) {
        totalCell.style.backgroundColor = '#ecfdf5';
        totalCell.style.borderLeft = '3px solid #10b981';
        totalCell.title = `Filtered: ${displayNetworkRuns} runs (Original: ${networkRuns} runs)`;
    } else {
        totalCell.title = `${displayNetworkRuns} total runs`;
    }
    
    row.appendChild(totalCell);
    
    
    return row;
}

// Get run counts for a specific network of a customer
function getNetworkRuns(customer, networkName) {
    console.log(` Getting runs for network "${networkName}" of customer "${customer.name}"`);
    
    // ULTRA STRICT VALIDATION: First check if ANY customer has edits - if yes, be extra careful
    const allCustomers = Object.values(dashboardData.customers || {});
    const hasAnyEdits = allCustomers.some(cust => 
        cust.networks && cust.networks.some(net => net.editedData)
    );
    
    if (hasAnyEdits) {
        console.log(` EDIT MODE DETECTED: Extra strict validation for ${customer.name} - ${networkName}`);
        
        // In edit mode, ONLY process networks that belong to customers with actual edits
        const thisCustomerHasEdits = customer.networks && customer.networks.some(net => net.editedData);
        
        if (!thisCustomerHasEdits) {
            // This customer has NO edits - restore original API data logic
            console.log(` PROTECTED CUSTOMER MODE: ${customer.name} - ${networkName}`);
            
            // Check network_runs first (most accurate)
            if (customer.network_runs && customer.network_runs[networkName] !== undefined) {
                const runs = customer.network_runs[networkName];
                console.log(` PROTECTED NETWORK_RUNS: ${networkName} = ${runs} runs`);
                return runs;
            }
            
            // For DB customers without network_runs, use original working logic from before edits were introduced
            if (customer.networks && Array.isArray(customer.networks)) {
                for (const network of customer.networks) {
                    const originalName = network.name;
                    const networkNameField = network.network_name;
                    const cleanedName = originalName && originalName.includes(' - ') ? 
                                        originalName.split(' - ').slice(1).join(' - ') : originalName;
                    
                    if ((originalName === networkName) || 
                        (networkNameField === networkName) || 
                        (cleanedName === networkName)) {
                        
                        // Check if individual network has run data
                        const individualRuns = network.runs || network.total_runs;
                        if (individualRuns && individualRuns > 0) {
                            console.log(` PROTECTED INDIVIDUAL: ${networkName} = ${individualRuns} runs`);
                            return individualRuns;
                        }
                        
                        // For DB networks, use the original pre-edit logic
                        if (network.last_run_date && 
                            network.last_run_date !== 'Never' && 
                            network.last_run_date !== '-') {
                            
                            // This network has real data - return reasonable count based on presence of date
                            // Use the customer's total runs distributed among networks that have data
                            const customerTotalRuns = customer.total_runs || customer.runs || customer.run_count || 0;
                            const networksWithData = customer.networks.filter(net => 
                                net.last_run_date && net.last_run_date !== 'Never' && net.last_run_date !== '-'
                            ).length;
                            
                            if (networksWithData > 0 && customerTotalRuns > 0) {
                                const distributedRuns = Math.max(1, Math.floor(customerTotalRuns / networksWithData));
                                console.log(` PROTECTED DISTRIBUTED: ${networkName} = ${distributedRuns} runs (${customerTotalRuns}/${networksWithData})`);
                                return distributedRuns;
                            } else {
                                console.log(` PROTECTED DEFAULT: ${networkName} = 1 run (has date)`);
                                return 1;
                            }
                        } else {
                            console.log(` PROTECTED NO DATA: ${networkName} = 0 runs (no date)`);
                            return 0;
                        }
                    }
                }
            }
            
            console.log(` PROTECTED: ${networkName} not found, returning 0`);
            return 0;
        }
    }
    
    // ULTRA STRICT: Only check for edited months if EXACTLY this network was edited
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            const originalName = network.name;
            const networkNameField = network.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            return (originalName === networkName) || 
                   (networkNameField === networkName) || 
                   (cleanedName === networkName);
        });
        
        // CRITICAL CHECK: Only proceed with months logic if this SPECIFIC network has months array
        if (targetNetwork && targetNetwork.months && Array.isArray(targetNetwork.months)) {
            console.log(` EDITED CHECK: Network "${networkName}" has editedData flag: ${targetNetwork.editedData}`);
            
            if (customer.excel_source || customer.excel_data) {
                // Excel customers: Recalculate runs from months array
                const calculatedRuns = targetNetwork.months.filter(monthValue => {
                    return monthValue && 
                           monthValue !== '-' && 
                           monthValue !== 'Not Started' && 
                           monthValue !== 'Not Run' && 
                           monthValue !== 'No Report' &&
                           !monthValue.toLowerCase().includes('not');
                }).length;
                
                console.log(` Excel EDITED: Calculated ${calculatedRuns} runs for "${networkName}"`);
                return calculatedRuns;
            } else {
                // DB customers: CRITICAL FIX - NO DOUBLE COUNTING, JUST RETURN ORIGINAL + SINGLE ADJUSTMENT
                if (targetNetwork.originalMonths) {
                    
                    // SIMPLE FIX: Just count how many valid dates exist in edited months
                    const editedValidDates = targetNetwork.months.filter(monthValue => {
                        return monthValue && monthValue !== '-' && 
                               !monthValue.toLowerCase().includes('not') && 
                               !monthValue.toLowerCase().includes('never');
                    }).length;
                    
                    // Count how many valid dates existed originally  
                    const originalValidDates = targetNetwork.originalMonths.filter(monthValue => {
                        return monthValue && monthValue !== '-' && 
                               !monthValue.toLowerCase().includes('not') && 
                               !monthValue.toLowerCase().includes('never');
                    }).length;
                    
                    const originalNetworkRuns = targetNetwork.runs || targetNetwork.total_runs || 0;
                    
                    // SINGLE COUNTING: Original runs + ONLY the net difference
                    const netDifference = editedValidDates - originalValidDates;
                    const finalRuns = Math.max(0, originalNetworkRuns + netDifference);
                    
                    console.log(` DB SINGLE COUNT: "${networkName}" original:${originalNetworkRuns} + diff:(${editedValidDates}-${originalValidDates}) = ${finalRuns} runs`);
                    return finalRuns;
                }
            }
        }
        
        // FALLBACK: If network has monthly_runs array but no months, calculate from monthly_runs
        if (targetNetwork && targetNetwork.monthly_runs && Array.isArray(targetNetwork.monthly_runs)) {
            const calculatedRuns = targetNetwork.monthly_runs.filter(monthValue => {
                return monthValue && monthValue !== '-' && 
                       !monthValue.toLowerCase().includes('not') && 
                       !monthValue.toLowerCase().includes('never') &&
                       !monthValue.toLowerCase().includes('no') &&
                       monthValue.includes('-') && // Must be a date format
                       monthValue.match(/^\d{2}-\d{2}$/); // Must be DD-MM format
            }).length;
            
            console.log(` MONTHLY_RUNS CALCULATION: "${networkName}" = ${calculatedRuns} runs`);
            return calculatedRuns;
        }
    }
    
    // PRIORITY 2: For non-edited networks, return EXACT original runs
    if (customer.networks && Array.isArray(customer.networks)) {
        for (const network of customer.networks) {
            // Try multiple matching strategies for cleaned names
            const originalName = network.name;
            const networkNameField = network.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            // Match against all possible name variations
            if ((originalName === networkName) || 
                (networkNameField === networkName) || 
                (cleanedName === networkName)) {
                
                // STRICT: If this network was NOT edited, return EXACT original
                if (!network.editedData) {
                    const originalRuns = network.runs || network.total_runs || 0;
                    console.log(` DB UNTOUCHED: "${networkName}" keeping EXACT ${originalRuns} runs (never edited)`);
                    return originalRuns;
                } else {
                    // This should not happen - edited networks should be handled above
                    console.log(` DB EDITED FALLBACK: "${networkName}" was edited but handled here`);
                    const originalRuns = network.runs || network.total_runs || 0;
                    return originalRuns;
                }
            }
        }
    }
    
    // PRIORITY 3: Check network_runs data
    if (customer.network_runs && customer.network_runs[networkName] !== undefined) {
        const runs = customer.network_runs[networkName];
        console.log(` Found ${runs} runs for network "${networkName}" from network_runs data`);
        return runs;
    }
    
    // CRITICAL FIX: NO FALLBACK DISTRIBUTION for DB customers - causes cross-contamination
    // Return 0 instead of trying to distribute runs, which affects other networks
    console.log(` Network "${networkName}" not found in customer "${customer.name}" - returning 0 to prevent cross-contamination`);
    return 0;
}

// Get network-specific monthly runs
function getNetworkMonthRuns(customer, networkName, year, month) {
    console.log(` Getting monthly runs for network "${networkName}" in month ${month}`);
    
    // Check if customer has network-specific monthly data
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        const runs = customer.network_monthly_runs[networkName][month];
        console.log(` Found ${runs} runs for ${networkName} in month ${month}`);
        return runs;
    }
    
    // CRITICAL FIX: NO FALLBACK DISTRIBUTION for monthly runs - causes cross-contamination
    // Return 0 instead of trying to distribute monthly runs among networks
    
    console.log(` No monthly runs found for network "${networkName}" in month ${month}`);
    return 0;
}

// Get monthly run counts for a customer with smart distribution
function getCustomerMonthRuns(customer, year, month) {
    console.log(` BACKEND-MATCHED: Getting runs for ${customer.name} for month ${month}/${year}`);
    
    // MATCH BACKEND LOGIC: DB Sessions Priority + Excel Fallback
    
    // Skip Excel customers from graph calculations (same as backend stats)
    if (customer.excel_source || customer.excel_only || customer.excel_data) {
        console.log(` SKIPPING Excel customer: ${customer.name}`);
        return 0;
    }
    
    // PRIORITY 1: Use actual DB sessions count - ONLY FOR OCTOBER
    if (customer.networks && customer.networks.length > 0 && month === 10) {
        let monthTotalFromSessions = 0;
        
        console.log(`   OCTOBER ONLY: Processing ${customer.networks.length} networks for DB customer: ${customer.name}`);
        
        customer.networks.forEach((network, netIndex) => {
            // BACKEND MATCH: Check if network has actual sessions
            const networkSessions = network.runs || network.total_runs || 0;
            console.log(`    OCTOBER Network ${netIndex + 1}: ${network.network_name || network.name}, sessions: ${networkSessions}`);
            
            if (networkSessions > 0) {
                // BACKEND LOGIC: Network has actual sessions - use network's total runs for this month
                const monthlyArray = network.monthly_runs || network.months || [];
                
                if (Array.isArray(monthlyArray)) {
                    const monthIndex = month - 1;
                    if (monthIndex >= 0 && monthIndex < monthlyArray.length) {
                        const monthValue = monthlyArray[monthIndex];
                        
                        // DB SESSION PRIORITY: If session data exists for this month, use network's total sessions
                        if (monthValue && monthValue !== '-' && 
                            !monthValue.toLowerCase().includes('not') && 
                            !monthValue.toLowerCase().includes('never')) {
                            
                            // Use actual network session count (not just 1)
                            monthTotalFromSessions += networkSessions;
                            console.log(`       OCTOBER DB SESSION COUNT: ${network.network_name || network.name} contributes ${networkSessions} runs in month ${month}`);
                        }
                    }
                }
            } else {
                // BACKEND LOGIC: No sessions, fallback to migrated data count
                const monthlyArray = network.monthly_runs || network.months || [];
                
                if (Array.isArray(monthlyArray)) {
                    const monthIndex = month - 1;
                    if (monthIndex >= 0 && monthIndex < monthlyArray.length) {
                        const monthValue = monthlyArray[monthIndex];
                        
                        // MIGRATED DATA FALLBACK: Count runs from migrated data
                        if (monthValue && monthValue !== '-' && 
                            !monthValue.toLowerCase().includes('not') && 
                            !monthValue.toLowerCase().includes('never')) {
                            
                            // For migrated data: if valid date exists, use 1 as fallback run count
                            monthTotalFromSessions += 1;
                            console.log(`       OCTOBER EXCEL FALLBACK: ${network.network_name || network.name} contributes 1 run (migrated) in month ${month}`);
                        }
                    }
                }
            }
        });
        
        console.log(`   OCTOBER BACKEND-MATCHED TOTAL: ${monthTotalFromSessions} activities for ${customer.name} in month ${month}`);
        return monthTotalFromSessions;
    } else if (customer.networks && customer.networks.length > 0 && month !== 10) {
        // FOR MAY-SEP: Only count networks that have actual activity in that specific month
        let monthTotalFromNetworkData = 0;
        
        console.log(`   MAY-SEP: Checking actual monthly activity for ${customer.name} in month ${month}`);
        
        customer.networks.forEach((network, netIndex) => {
            const monthlyArray = network.monthly_runs || network.months || [];
            
            if (Array.isArray(monthlyArray)) {
                const monthIndex = month - 1;
                if (monthIndex >= 0 && monthIndex < monthlyArray.length) {
                    const monthValue = monthlyArray[monthIndex];
                    
                    // Only count if network has actual activity in this specific month
                    if (monthValue && monthValue !== '-' && 
                        !monthValue.toLowerCase().includes('not') && 
                        !monthValue.toLowerCase().includes('never')) {
                        
                        // Count as 1 activity per network per month (not total network sessions)
                        monthTotalFromNetworkData += 1;
                        console.log(`       MAY-SEP ACTIVITY: ${network.network_name || network.name} has activity in month ${month}`);
                    }
                }
            }
        });
        
        console.log(`   MAY-SEP TOTAL: ${monthTotalFromNetworkData} activities for ${customer.name} in month ${month}`);
        return monthTotalFromNetworkData;
    }
    
    // ONLY FOR OCTOBER: Enable fallback logics, for May-Sep: skip
    if (month === 10) {
        // PRIORITY 2: Check customer-level monthly_runs array as fallback
        if (customer.monthly_runs && Array.isArray(customer.monthly_runs)) {
            const monthIndex = month - 1; // Convert 1-based month to 0-based index
            if (monthIndex >= 0 && monthIndex < customer.monthly_runs.length) {
                const monthValue = customer.monthly_runs[monthIndex];
                
                // If it's a number, use it directly
                if (typeof monthValue === 'number' && monthValue > 0) {
                    console.log(` OCTOBER CUSTOMER EXACT: ${customer.name} has ${monthValue} runs in month ${month}`);
                    return monthValue;
                }
            }
        }
        
        // PRIORITY 3: Check if customer has monthly_runs object data (API format)
        if (customer.monthly_runs && typeof customer.monthly_runs === 'object' && !Array.isArray(customer.monthly_runs)) {
            if (customer.monthly_runs[month] !== undefined) {
                const monthValue = customer.monthly_runs[month];
                console.log(` OCTOBER Found API monthly data for month ${month}: ${monthValue}`);
                // If API gives real data > 0, use it
                if (monthValue > 0) {
                    return monthValue;
                }
            }
        }
        
        // Check for month-specific fields like oct_runs
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        const monthField = `${monthNames[month-1]}_runs`;
        if (customer[monthField] !== undefined) {
            console.log(` OCTOBER Found ${monthField}: ${customer[monthField]}`);
            return customer[monthField];
        }
        
        // Check monthlyStats array (old format)
        if (customer.monthlyStats && Array.isArray(customer.monthlyStats)) {
            const monthData = customer.monthlyStats.find(m => {
                // Match by month name or index
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return m.month === monthNames[month-1] || m.monthIndex === month-1;
            });
            if (monthData) {
                console.log(` OCTOBER Found monthlyStats for month ${month}: ${monthData.runs}`);
                return monthData.runs || 0;
            }
        }
        
        // PRIORITY 4: USE REAL SESSION DATES: Check if customer has actual session dates
        if (customer.sessions || customer.run_history || customer.session_dates) {
            const sessions = customer.sessions || customer.run_history || customer.session_dates || [];
            let realMonthRuns = 0;
            
            console.log(` OCTOBER Checking REAL session dates for ${customer.name}:`, sessions);
            
            if (Array.isArray(sessions)) {
                sessions.forEach(session => {
                    const sessionDate = new Date(session.date || session.created_at || session.timestamp || session);
                    if (!isNaN(sessionDate.getTime())) {
                        const sessionYear = sessionDate.getFullYear();
                        const sessionMonth = sessionDate.getMonth() + 1;
                        
                        if (sessionYear === year && sessionMonth === month) {
                            realMonthRuns++;
                            console.log(` OCTOBER REAL session found in ${month}/${year}: ${sessionDate.toDateString()}`);
                        }
                    }
                });
            }
            
            if (realMonthRuns > 0) {
                console.log(` OCTOBER REAL monthly data: ${customer.name} has ${realMonthRuns} runs in ${month}/${year}`);
                return realMonthRuns;
            }
        }
    } else {
        console.log(` SKIPPING fallbacks for month ${month} (${customer.name}) - only using network data`);
    }
    
    // MODIFIED: Only use last_run_date for current month (October), not for old months
    if (customer.last_run_date && month === 10) { // Only October
        try {
            const lastRunDate = new Date(customer.last_run_date);
            const lastRunYear = lastRunDate.getFullYear();
            const lastRunMonth = lastRunDate.getMonth() + 1;
            
            // Only show runs for October if last run was in October
            if (year === lastRunYear && lastRunMonth === 10) {
                const totalRuns = customer.runs || customer.run_count || 0;
                console.log(` OCTOBER FALLBACK: Using last_run_date: ${totalRuns} runs in October`);
                return totalRuns;
            }
        } catch (error) {
            console.log(` Invalid last_run_date format: ${customer.last_run_date}`);
        }
    }
    
    console.log(` No runs for ${customer.name} in month ${month}`);
    return 0;
    
    console.log(` No runs for ${customer.name} in month ${month}`);
    return 0;
}

// ENHANCED: Get monthly run dates for a customer with REAL session dates
function getCustomerMonthRunDates(customer, year, month) {
    console.log(` ENHANCED: Getting REAL run dates for ${customer.name} for month ${month}/${year}`);
    
    // NEW PRIORITY 1: Extract dates directly from API response networks array
    if (customer.networks && Array.isArray(customer.networks)) {
        let totalRunsThisMonth = 0;
        let latestDate = null;
        let latestDateTime = null;
        
        // Check each network for runs in this month
        customer.networks.forEach(network => {
            // STRICT VALIDATION: Only process networks that actually have runs and valid dates
            if (network.last_run_date && 
                network.last_run_date !== 'Never' && 
                network.last_run_date !== '-' && 
                network.runs > 0) {
                
                const networkDate = fixDateParsing(network.last_run_date);
                if (networkDate) {
                    const networkYear = networkDate.getFullYear();
                    const networkMonth = networkDate.getMonth() + 1;
                    
                    // If this network's last run was in the requested month/year
                    if (networkYear === year && networkMonth === month) {
                        totalRunsThisMonth += network.runs;
                        
                        // Keep track of the latest date from all networks in this month
                        if (!latestDateTime || networkDate > latestDateTime) {
                            latestDateTime = networkDate;
                            const day = networkDate.getDate();
                            const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                            const yearShort = networkDate.getFullYear().toString().slice(-2);
                            latestDate = `${day}-${monthName}-${yearShort}`;
                        }
                        
                        console.log(` NETWORK DATE MATCH: ${network.name} - ${network.runs} runs on ${network.last_run_date} -> formatted as ${latestDate}`);
                    }
                }
            } else {
                // Only log for networks that have 0 runs (to track Nokia East fix)
                if (network.runs === 0) {
                    console.log(` SKIPPED: ${network.name} - 0 runs (correctly showing no date)`);
                }
            }
        });
        
        if (totalRunsThisMonth > 0 && latestDate) {
            console.log(` API DATE SUCCESS: ${customer.name} has ${totalRunsThisMonth} runs in ${month}/${year} with latest date: ${latestDate}`);
            return {
                count: totalRunsThisMonth,
                date: latestDate,
                fullDate: latestDateTime.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                })
            };
        }
    }
    
    // EXCEL PRIORITY: Check Excel networks monthly data (months array)
    if (customer.excel_source || customer.excel_data) {
        console.log(` EXCEL DATA: Processing monthly data for Excel customer: ${customer.name}`);
        
        if (customer.networks && Array.isArray(customer.networks)) {
            let totalRunsThisMonth = 0;
            let latestDate = null;
            
            // Check each Excel network for data in this month
            customer.networks.forEach(network => {
                const months = network.months || network.monthly_runs || [];
                const monthIndex = month - 1; // Convert to 0-based index (Jan=0)
                const monthValue = months[monthIndex];
                
                console.log(`    Network ${network.name}: month ${month} (index ${monthIndex}) = "${monthValue}"`);
                
                // Show EXACT Excel data - whatever is in Excel file
                if (monthValue) {
                    // Count only actual date runs for statistics
                    if (monthValue !== '-' && 
                        monthValue !== 'Not Started' && 
                        monthValue !== 'Not Run' &&
                        monthValue !== 'No Report' &&
                        monthValue.includes('-') && 
                        !monthValue.toLowerCase().includes('not')) {
                        totalRunsThisMonth++;
                    }
                    
                    // Always show whatever is in Excel - dates, status, everything
                    latestDate = monthValue;
                    console.log(`      Excel shows: ${monthValue}`);
                }
            });
            
            if (latestDate) {
                console.log(` EXCEL SUCCESS: ${customer.name} shows "${latestDate}" for month ${month} (${totalRunsThisMonth} actual runs)`);
                return {
                    count: totalRunsThisMonth, // Only count actual runs for stats
                    date: latestDate, // Show date OR status string
                    fullDate: latestDate
                };
            }
        }
        
        console.log(`    No Excel data found for ${customer.name} in month ${month}`);
    }
    
    // PRIORITY 1: Check Excel monthly_runs array (index 0-11 for Jan-Dec)
    if (customer.monthly_runs && Array.isArray(customer.monthly_runs)) {
        const monthIndex = month - 1; // Convert to 0-based index
        const monthValue = customer.monthly_runs[monthIndex];
        if (monthValue && monthValue !== '-' && monthValue !== 'Not Started') {
            return {
                count: 1,
                date: monthValue,
                fullDate: monthValue
            };
        }
    }
    
    // PRIORITY 2: Check if we have monthly_runs object format
    if (customer.monthly_runs && customer.monthly_runs[month]) {
        const monthData = customer.monthly_runs[month];
        
        // If it's an object with count and date (enhanced format)
        if (typeof monthData === 'object' && monthData.count !== undefined) {
            if (monthData.count > 0 && monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(` REAL DATA: ${customer.name} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,
                    fullDate: monthData.fullDate || monthData.date
                };
            } else if (monthData.count > 0) {
                // Has count but no date - this is the issue we're fixing!
                console.log(` MISSING DATE: ${customer.name} has ${monthData.count} runs but no date for month ${month}`);
                // Try to get actual last run date
                const actualDate = getActualDateForCustomerMonth(customer, year, month);
                if (actualDate) {
                    return {
                        count: monthData.count,
                        date: actualDate,
                        fullDate: actualDate
                    };
                }
            }
        } else if (typeof monthData === 'number' && monthData > 0) {
            // Simple number format
            console.log(` NUMERIC DATA: ${customer.name} has ${monthData} runs in month ${month}`);
            const actualDate = getActualDateForCustomerMonth(customer, year, month);
            if (actualDate) {
                return {
                    count: monthData,
                    date: actualDate,
                    fullDate: actualDate
                };
            }
        }
    }
    
    // SECOND PRIORITY: Check network monthly data for actual dates
    if (customer.network_monthly_runs) {
        for (const [networkName, networkMonthly] of Object.entries(customer.network_monthly_runs)) {
            if (networkMonthly[month] && networkMonthly[month].count > 0 && networkMonthly[month].date) {
                console.log(` NETWORK DATE: Found date from network ${networkName}: ${networkMonthly[month].date}`);
                return {
                    count: networkMonthly[month].count,
                    date: networkMonthly[month].date,
                    fullDate: networkMonthly[month].fullDate || networkMonthly[month].date
                };
            }
        }
    }
    
    // THIRD PRIORITY: Check if this customer's last run was in this specific month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate) {
            const lastRunYear = lastRunDate.getFullYear();
            const lastRunMonth = lastRunDate.getMonth() + 1;
            
            if (year === lastRunYear && month === lastRunMonth) {
                const totalRuns = customer.runs || customer.run_count || 0;
                if (totalRuns > 0) {
                    const day = lastRunDate.getDate();
                    const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = lastRunDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(` LAST RUN DATE MATCH: ${customer.name} - ${totalRuns} runs in ${month}/${year} on ${formattedDate}`);
                    return {
                        count: totalRuns,
                        date: formattedDate,
                        fullDate: lastRunDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        }
    }
    
    // FOURTH PRIORITY: Check if we have actual runs but no monthly breakdown
    const totalRuns = customer.runs || customer.run_count || 0;
    if (totalRuns > 0) {
        console.log(` DATE INTEGRATION ISSUE: ${customer.name} has ${totalRuns} total runs but no monthly date data for month ${month}`);
    }
    
    // NO RUNS OR NO DATE DATA
    return { count: 0, date: '-', fullDate: 'No runs' };
}

// NEW HELPER FUNCTION: Get actual date for a specific customer month
function getActualDateForCustomerMonth(customer, year, month) {
    console.log(` Getting actual date for ${customer.name} in ${month}/${year}`);
    
    // Try customer's actual_last_run field first
    if (customer.actual_last_run) {
        const actualDate = fixDateParsing(customer.actual_last_run);
        if (actualDate && actualDate.getFullYear() === year && (actualDate.getMonth() + 1) === month) {
            const day = actualDate.getDate();
            const monthName = actualDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = actualDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    // Try last_run_date
    if (customer.last_run_date && customer.last_run_date !== 'Never') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    console.log(` No actual date found for ${customer.name} in ${month}/${year}`);
    return null;
}

// ENHANCED: Get monthly run dates for a specific network with REAL session dates
function getNetworkMonthRunDates(customer, networkName, year, month) {
    console.log(` ENHANCED: Getting REAL run dates for network "${networkName}" in month ${month}`);
    
    // EDITED DATA PRIORITY: Check if network has edited months data (from edit modal)
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.Network === networkName ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.months && Array.isArray(targetNetwork.months)) {
            const monthIndex = month - 1; // Convert to 0-based index
            const monthValue = targetNetwork.months[monthIndex];
            
            if (monthValue && monthValue !== '-') {
                console.log(`    Using EDITED data for ${networkName}: ${monthValue}`);
                return {
                    count: monthValue === 'Not Started' || monthValue === 'Not Run' ? 0 : 1,
                    date: monthValue,
                    fullDate: monthValue
                };
            }
        }
    }
    
    // EXCEL PRIORITY: Check Excel network monthly data first
    if (customer.excel_source || customer.excel_data) {
        console.log(` EXCEL NETWORK: Processing Excel network "${networkName}"`);
        
        if (customer.networks && Array.isArray(customer.networks)) {
            const targetNetwork = customer.networks.find(network => {
                return network.network_name === networkName || 
                       network.name === networkName ||
                       network.Network === networkName ||
                       network.name.includes(networkName);
            });
            
            if (targetNetwork) {
                console.log(`    Found Excel network: ${targetNetwork.name}`);
                
                // Check if this network has 0 runs
                if (targetNetwork.runs === 0) {
                    console.log(`    Excel network has 0 runs - returning no date`);
                    return { count: 0, date: '-', fullDate: 'No runs' };
                }
                
                // Get Excel monthly data from months array
                const months = targetNetwork.months || targetNetwork.monthly_runs || [];
                const monthIndex = month - 1; // Convert to 0-based index
                const monthValue = months[monthIndex];
                
                console.log(`    Excel network month ${month} (index ${monthIndex}) = "${monthValue}"`);
                
                // Show EXACT Excel data for this network - whatever is in Excel
                if (monthValue) {
                    // Count runs only for actual dates for statistics
                    let runCount = 0;
                    if (monthValue !== '-' && 
                        monthValue !== 'Not Started' && 
                        monthValue !== 'Not Run' &&
                        monthValue !== 'No Report' &&
                        monthValue.includes('-') && 
                        !monthValue.toLowerCase().includes('not')) {
                        runCount = 1;
                    }
                    
                    console.log(`    Excel network shows: ${monthValue}`);
                    return {
                        count: runCount, // Count for statistics
                        date: monthValue, // Show EXACT Excel data
                        fullDate: monthValue
                    };
                } else {
                    console.log(`    Excel network no data for month ${month}`);
                    return { count: 0, date: '-', fullDate: 'No data' };
                }
            }
        }
    }
    
    // CRITICAL FIRST CHECK: If network has 0 runs, return immediately with no date
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(` ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(` ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && 
            targetNetwork.last_run_date && 
            targetNetwork.last_run_date !== 'Never' && 
            targetNetwork.last_run_date !== '-' && 
            targetNetwork.runs > 0) {
            
            const networkDate = fixDateParsing(targetNetwork.last_run_date);
            if (networkDate) {
                const networkYear = networkDate.getFullYear();
                const networkMonth = networkDate.getMonth() + 1;
                
                // If this network's last run was in the requested month/year
                if (networkYear === year && networkMonth === month) {
                    const day = networkDate.getDate();
                    const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = networkDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(` API NETWORK DATE: ${networkName} - ${targetNetwork.runs} runs on ${targetNetwork.last_run_date} -> formatted as ${formattedDate}`);
                    return {
                        count: targetNetwork.runs,
                        date: formattedDate,
                        fullDate: networkDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        } else {
            // Only log for debugging Nokia East (0 runs case)
            if (targetNetwork && targetNetwork.runs === 0) {
                console.log(` NETWORK SKIPPED: ${networkName} - 0 runs (correctly showing no date)`);
            }
        }
    }
    
    // PRIORITY 2: Check if we have enhanced network monthly data with actual dates
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        
        const monthData = customer.network_monthly_runs[networkName][month];
        console.log(` Network monthly data for ${networkName} month ${month}:`, monthData);
        
        // Enhanced format with actual session dates
        if (typeof monthData === 'object' && monthData.hasData && monthData.count > 0) {
            if (monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(` REAL NETWORK DATE: ${networkName} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,  // Real date like "09-Sep-25" from session
                    fullDate: monthData.fullDate || monthData.date
                };
            } else {
                console.log(` NETWORK MISSING DATE: ${networkName} has ${monthData.count} runs but no date for month ${month}`);
            }
        }
    }
    
    // PRIORITY 3: Check if customer has data for this network in this month
    const customerRunData = getCustomerMonthRunDates(customer, year, month);
    if (customerRunData && customerRunData.count > 0 && customerRunData.date !== '-') {
        // Get network-specific run count
        const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
        
        if (networkRuns > 0) {
            // FIXED: All networks with runs can inherit customer's actual run date
            // This fixes the issue where only primary networks showed dates
            console.log(` NETWORK INHERITS DATE: ${networkName} (${networkRuns} runs) inherits customer date: ${customerRunData.date}`);
            return {
                count: networkRuns,
                date: customerRunData.date,
                fullDate: customerRunData.fullDate
            };
        }
    }
    
    // PRIORITY 4: Get network-specific runs using old method
    const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
    
    // If no runs, return early
    if (networkRuns === 0) {
        return { count: 0, date: '-', fullDate: 'No runs' };
    }
    
    // PRIORITY 5: Check if customer has actual last run date for this month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            const formattedDate = `${day}-${monthName}-${yearShort}`;
            
            console.log(` NETWORK USING CUSTOMER DATE: ${networkName} - ${networkRuns} runs on ${formattedDate}`);
            return {
                count: networkRuns,
                date: formattedDate,
                fullDate: lastRunDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                })
            };
        }
    }
    
    // FALLBACK: Network has runs but no date information available
    console.log(` NETWORK DATE INTEGRATION ISSUE: ${networkName} has ${networkRuns} runs but no date information`);
    return {
        count: networkRuns,
        date: 'Date missing',  // Clear indication of missing date
        fullDate: `${networkRuns} runs but date information missing`
    };
}

// Generate month-wise data for a customer (for backward compatibility)
function generateMonthlyData(customer) {
    const months = [];
    const now = new Date();
    
    // Generate last 12 months
    for (let i = 11; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const monthShort = date.toLocaleDateString('en-US', { month: 'short' });
        
        // Calculate runs for this month (simulate based on total runs)
        const totalRuns = customer.runs || 0;
       
        const monthRuns = Math.floor((totalRuns * Math.random() * 0.3) + (totalRuns * 0.05)); // Distribute runs
        
        months.push({
            name: monthName,
            short: monthShort,
            runs: monthRuns,
            date: date
        });
    }
    
    return months;
}

// REFRESH FUNCTIONALITY - COMMENTED OUT FOR NOW
/* function refreshDashboard() {
    console.log(' Manual refresh triggered');
    const refreshBtn = document.querySelector('.refresh-btn');
    const originalText = refreshBtn.innerHTML;
    
    refreshBtn.innerHTML = '<div class="spinner white"></div> Refreshing...';
    refreshBtn.disabled = true;
    
    showLoadingState();
    
    loadDashboardData(currentStartDate, currentEndDate).finally(() => {
        setTimeout(() => {
            refreshBtn.innerHTML = originalText;
            refreshBtn.disabled = false;
        }, 1000);
    });
} */

// EXPORT MODAL FUNCTIONALITY
function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
}

function openExportModal() {
    // ALWAYS pre-fill with current filter dates if available
    if (currentStartDate && currentEndDate) {
        document.getElementById('start-date').value = currentStartDate;
        document.getElementById('end-date').value = currentEndDate;
        console.log(` Export modal opened with filter dates: ${currentStartDate} to ${currentEndDate}`);
    } else {
        // If no filter dates, set default dates
        setDefaultDates();
        console.log(' Export modal opened with default dates');
    }
    document.getElementById('export-modal').style.display = 'block';
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

//  FIXED EXPORT FUNCTIONALITY - Uses filtered data like downloadFilteredData
async function exportToExcel() {
    console.log(" Starting FILTERED DASHBOARD export...");
    
    const exportBtn = document.querySelector('.btn-export');
    if (exportBtn) {
        exportBtn.innerHTML = '<div class="spinner white"></div> Exporting...';
        exportBtn.disabled = true;
    }
    
    try {
        //  Use SAME logic as downloadFilteredData() to respect filters
        let exportUrl = '/api/export-excel/';
        let exportType = 'all';
        
        // Check if filter is currently active
        if (isFilterActive && currentStartDate && currentEndDate) {
            // Filter is active - get filtered data
            exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
            exportType = 'filtered';
            console.log(' Exporting FILTERED data:', { start: currentStartDate, end: currentEndDate });
        } else {
            // No filter active - get ALL data
            console.log(' Exporting ALL data (no filter applied)');
        }
        
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log(' Export URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log(' Export response status:', response.status);
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                let filename;
                if (exportType === 'filtered') {
                    filename = `dashboard_export_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                } else {
                    filename = `dashboard_export_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                }
                
                const contentDisposition = response.headers.get('content-disposition');
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);
            
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log(' Downloading export file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                const message = exportType === 'filtered' 
                    ? ` Successfully exported filtered data (${currentStartDate} to ${currentEndDate})!`
                    : ' Successfully exported all data!';
                showNotification(message, 'success');
            } else {
                throw new Error('Empty file received');
            }
        } else {
            throw new Error(`Export failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error(' Export error:', error);
        showNotification(' Export failed. Please try again.', 'error');
    } finally {
        // Reset button
        if (exportBtn) {
            exportBtn.innerHTML = 'Export';
            exportBtn.disabled = false;
        }
    }
}

//  CSV Conversion Function
function convertToCSV(data) {
    if (!data || data.length === 0) return '';
    
    // Get headers from first row
    const headers = Object.keys(data[0]);
    
    // Create CSV content
    let csvContent = headers.join(',') + '\n';
    
    // Add data rows
    data.forEach(row => {
        const values = headers.map(header => {
            let value = row[header] || '';
            // Escape commas and quotes
            if (value.toString().includes(',') || value.toString().includes('"')) {
                value = `"${value.toString().replace(/"/g, '""')}"`;
            }
            return value;
        });
        csvContent += values.join(',') + '\n';
    });
    
    console.log(` CSV prepared: ${data.length} rows, ${headers.length} columns`);
    return csvContent;
}

//  Download CSV Function
function downloadCSV(csvContent, filename) {
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log(` Downloaded: ${filename}`);
    } else {
        console.error(' Browser does not support file download');
        showNotification(' Browser does not support file download', 'error');
    }
}

//  Direct Excel Download (Enhanced)
async function directExcelDownload() {
    console.log(' Starting direct Excel download...');
    
    // Use the same export function but ensure it works
    try {
        await exportToExcel();
    } catch (error) {
        console.error(' Direct download failed:', error);
        showNotification(' Download failed. Please try again.', 'error');
    }
}


// UTILITY FUNCTIONS
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.warn(' CSRF token not found in DOM');
        return '';
    }
    console.log(' CSRF token found:', token.value ? 'Yes' : 'No');
    return token.value || '';
}

function showNotification(message, type = 'info') {
    // Very small professional notification (admin logout style)
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 15px;
        right: 15px;
        padding: 4px 8px;
        max-width: 200px;
        background: ${type === 'success' ? 'rgba(16, 185, 129, 0.95)' : type === 'warning' ? 'rgba(245, 158, 11, 0.95)' : type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(59, 130, 246, 0.95)'};
        color: white;
        border-radius: 4px;
        z-index: 9999;
        font-weight: 400;
        font-size: 11px;
        line-height: 1.2;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(8px);
        transform: translateY(-10px);
        opacity: 0;
        transition: all 0.2s ease;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateY(0)';
        notification.style.opacity = '1';
    }, 10);
    
    // Animate out after 2 seconds
    setTimeout(() => {
        notification.style.transform = 'translateY(-10px)';
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.remove();
        }, 200);
    }, 2000);
}

// MODAL CLOSE ON OUTSIDE CLICK
window.onclick = function(event) {
    const modal = document.getElementById('export-modal');
    if (event.target == modal) {
        closeExportModal();
    }
}

// EXPORT MODAL FUNCTIONS
function openExportModal() {
    document.getElementById('export-modal').style.display = 'block';
    setDefaultDates();
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            // Remove selected class from all options
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            this.classList.add('selected');
            // Update radio button
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
}


// DIRECT EXCEL DOWNLOAD - No modal, instant download with current filter dates
async function directExcelDownload() {
    console.log(' Direct Excel download triggered');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log(' Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log(' Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel export...' : 'Generating Excel export...';
    showNotification(` ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log(' Export URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                let filename;
                if (exportType === 'filtered') {
                    filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                } else {
                    filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                }
                
                const contentDisposition = response.headers.get('content-disposition');
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log(' Downloading file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
                
                if (exportType === 'filtered') {
                    showNotification(` Filtered Excel export completed (${currentStartDate} to ${currentEndDate})!`, 'success');
                } else {
                    showNotification(` Excel export completed (All data)!`, 'success');
                }
            } else {
                showNotification(' Export file was empty', 'warning');
            }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error(' Export error:', error);
        showNotification(` Export failed: ${error.message}`, 'error');
    }
}

// Toggle networks dropdown in compact view
function toggleNetworks(networkButtonId) {
    const dropdown = document.getElementById(networkButtonId);
    const button = dropdown.previousElementSibling;
    
    if (!dropdown || !button) return;
    
    // Close all other open dropdowns
    document.querySelectorAll('.networks-dropdown').forEach(otherDropdown => {
        if (otherDropdown.id !== networkButtonId && otherDropdown.style.display === 'block') {
            otherDropdown.style.display = 'none';
            const otherButton = otherDropdown.previousElementSibling;
            if (otherButton) {
                otherButton.classList.remove('active');
            }
        }
    });
    
    // Toggle current dropdown
    const isOpen = dropdown.style.display === 'block';
    
    if (isOpen) {
        dropdown.style.display = 'none';
        button.classList.remove('active');
    } else {
        dropdown.style.display = 'block';
        button.classList.add('active');
    }
}

// Close dropdowns when clicking outside
document.addEventListener('click', function(event) {
    if (!event.target.closest('.networks-compact')) {
        document.querySelectorAll('.networks-dropdown').forEach(dropdown => {
            dropdown.style.display = 'none';
            const button = dropdown.previousElementSibling;
            if (button) {
                button.classList.remove('active');
            }
        });
    }
});

// APPLY CUSTOMER FILTER - Filter dashboard by date range
// MONTH-SPECIFIC FILTERING - Show only filtered month dates, blank others
function applyMonthFiltering(startDate, endDate) {
    console.log(` Applying month-specific filtering: ${startDate} to ${endDate}`);
    
    const filterStart = new Date(startDate);
    const filterEnd = new Date(endDate);
    
    const filterStartMonth = filterStart.getMonth() + 1; // 1-12
    const filterEndMonth = filterEnd.getMonth() + 1;     // 1-12
    const filterStartYear = filterStart.getFullYear();
    const filterEndYear = filterEnd.getFullYear();
    
    console.log(` Filter range: Month ${filterStartMonth}/${filterStartYear} to ${filterEndMonth}/${filterEndYear}`);
    
    // Apply filtering to all customers
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip Excel customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return;
        }
        
        // Filter customer-level months
        if (customer.months && Array.isArray(customer.months)) {
            customer.filteredMonths = customer.months.map((monthValue, monthIndex) => {
                const monthNumber = monthIndex + 1; // 1-12
                
                if (isMonthInFilterRange(monthNumber, filterStartMonth, filterEndMonth, filterStartYear, filterEndYear)) {
                    return monthValue; // Keep original value
                } else {
                    return '-'; // Blank out
                }
            });
            
            console.log(` Filtered ${customer.name} months:`, customer.filteredMonths);
        }
        
        // Filter network-level months
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                if (network.months && Array.isArray(network.months)) {
                    network.filteredMonths = network.months.map((monthValue, monthIndex) => {
                        const monthNumber = monthIndex + 1; // 1-12
                        
                        if (isMonthInFilterRange(monthNumber, filterStartMonth, filterEndMonth, filterStartYear, filterEndYear)) {
                            return monthValue; // Keep original value
                        } else {
                            return '-'; // Blank out
                        }
                    });
                    
                    console.log(` Filtered ${customer.name} - ${network.name}:`, network.filteredMonths);
                }
                
                if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                    network.filteredMonthlyRuns = network.monthly_runs.map((monthValue, monthIndex) => {
                        const monthNumber = monthIndex + 1; // 1-12
                        
                        if (isMonthInFilterRange(monthNumber, filterStartMonth, filterEndMonth, filterStartYear, filterEndYear)) {
                            return monthValue; // Keep original value
                        } else {
                            return '-'; // Blank out
                        }
                    });
                }
            });
        }
    });
    
    // Set global filter state for other functions to use
    window.isMonthFilterActive = true;
    window.filterStartMonth = filterStartMonth;
    window.filterEndMonth = filterEndMonth;
    window.filterStartYear = filterStartYear;
    window.filterEndYear = filterEndYear;
    
    console.log(` Month filtering applied - blanked non-filtered months`);
}

// Helper function to check if a month is in filter range
function isMonthInFilterRange(monthNumber, filterStartMonth, filterEndMonth, filterStartYear, filterEndYear) {
    // For now, simple month range check (can be enhanced for year ranges)
    return monthNumber >= filterStartMonth && monthNumber <= filterEndMonth;
}

// Helper function to check if a month column should be highlighted (filtered)
function isMonthFiltered(monthIndex) {
    if (!window.isMonthFilterActive) return false;
    
    const monthNumber = monthIndex + 1; // Convert 0-11 to 1-12
    return isMonthInFilterRange(monthNumber, window.filterStartMonth, window.filterEndMonth, window.filterStartYear, window.filterEndYear);
}

// Get month data with filter consideration
function getFilteredMonthData(customer, network, monthIndex) {
    if (!window.isMonthFilterActive) {
        // No filter active - return normal data
        if (network) {
            const monthData = getNetworkMonthRunDates(customer, network.name, new Date().getFullYear(), monthIndex + 1);
            return monthData && monthData.date ? monthData.date : '-';
        } else {
            const monthData = getCustomerMonthRunDates(customer, new Date().getFullYear(), monthIndex + 1);
            return monthData && monthData.date ? monthData.date : '-';
        }
    } else {
        // Filter active - check if this month should be shown
        if (isMonthFiltered(monthIndex)) {
            // Show data for filtered month
            if (network) {
                const monthData = getNetworkMonthRunDates(customer, network.name, new Date().getFullYear(), monthIndex + 1);
                return monthData && monthData.date ? monthData.date : '-';
            } else {
                const monthData = getCustomerMonthRunDates(customer, new Date().getFullYear(), monthIndex + 1);
                return monthData && monthData.date ? monthData.date : '-';
            }
        } else {
            // Blank out non-filtered months
            return '-';
        }
    }
}

// Clear month filtering
function clearMonthFiltering() {
    console.log(` Clearing month-specific filtering`);
    
    // Remove filtered data from all customers
    Object.values(dashboardData.customers).forEach(customer => {
        // Remove customer-level filtered data
        delete customer.filteredMonths;
        
        // Remove network-level filtered data
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                delete network.filteredMonths;
                delete network.filteredMonthlyRuns;
            });
        }
    });
    
    // Clear global filter state
    window.isMonthFilterActive = false;
    delete window.filterStartMonth;
    delete window.filterEndMonth;
    delete window.filterStartYear;
    delete window.filterEndYear;
    
    console.log(` Month filtering cleared - restored all months`);
}

async function applyCustomerFilter() {
    const startDateInput = document.getElementById('customer-start-date');
    const endDateInput = document.getElementById('customer-end-date');
    
    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    
    // Validation
    if (!startDate || !endDate) {
        showNotification(' Please select both start and end dates', 'error');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        showNotification(' Start date must be before end date', 'error');
        return;
    }
    
    console.log(` Applying date filter: ${startDate} to ${endDate}`);
    showNotification(` Filtering data: ${startDate} to ${endDate}`, 'info');
    
    // Update global filter state
    currentStartDate = startDate;
    currentEndDate = endDate;
    isFilterActive = true; // Mark filter as active
    
    // Also set window-level filter state for consistency
    window.isFilterActive = true;
    window.currentStartDate = startDate;
    window.currentEndDate = endDate;
    
    // UPDATE EXPORT MODAL DATES AUTOMATICALLY
    document.getElementById('start-date').value = startDate;
    document.getElementById('end-date').value = endDate;
    console.log(` Export modal updated with filter dates: ${startDate} to ${endDate}`);
    
    // UPDATE EXPORT BUTTON TEXT TO SHOW DATES
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        const startFormatted = new Date(startDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const endFormatted = new Date(endDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export (${startFormatted} - ${endFormatted})
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #059669 0%, #047857 100%)';
        exportBtn.title = `Click to download Excel file for ${startDate} to ${endDate}`;
    }
    
    // Apply month-specific filtering
    applyMonthFiltering(startDate, endDate);
    
    // Reload dashboard with date filters
    showLoadingState();
    await loadDashboardData(startDate, endDate);
    
    // Update month headers with the filtered year
    updateMonthHeadersWithYear(startDate, endDate);
    
    // Update graphs and statistics with filtered data
    setTimeout(() => {
        updateTrackingGraph();
        updateCustomerMonthChart();
        updateStatistics();
    }, 500);
    
    showNotification(` Dashboard filtered: ${startDate} to ${endDate}`, 'success');
}

// SMART DOWNLOAD - Downloads filtered data if filter active, otherwise all data
async function downloadFilteredData() {
    console.log(' Download button clicked');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log(' Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log(' Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel download...' : 'Generating Excel download...';
    showNotification(` ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log(' Download URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log(' Filtered export response status:', response.status);
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                    let filename;
                    if (exportType === 'filtered') {
                        filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                    } else {
                        filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                    }
                    
                    const contentDisposition = response.headers.get('content-disposition');
                    if (contentDisposition) {
                        const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                        if (filenameMatch) {
                            filename = filenameMatch[1];
                        }
                    }
                    
                    console.log(' Downloading filtered file:', filename);
                    
                    // Create download link
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = filename;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    }, 100);
                    
                    if (exportType === 'filtered') {
                        showNotification(` Filtered dashboard data (${currentStartDate} to ${currentEndDate}) downloaded successfully!`, 'success');
                    } else {
                        showNotification(' All dashboard data downloaded successfully!', 'success');
                    }
                } else {
                    showNotification(' Export file was empty', 'warning');
                }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error(' Filtered export error:', error);
        showNotification(` Filtered export failed: ${error.message}`, 'error');
    }
}

// CLEAR FILTER - Reset to show all data
async function clearFilter() {
    console.log(' Clearing date filter...');
    
    // Reset global filter state
    currentStartDate = null;
    currentEndDate = null;
    isFilterActive = false; // Reset filter flag
    
    // Also clear window-level filter state for consistency
    window.isFilterActive = false;
    window.currentStartDate = null;
    window.currentEndDate = null;
    
    // Clear input fields
    document.getElementById('customer-start-date').value = '';
    document.getElementById('customer-end-date').value = '';
    
    // CLEAR EXPORT MODAL DATES TOO
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    console.log(' Export modal dates cleared');
    
    // RESET EXPORT BUTTON TO ORIGINAL STATE
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
        exportBtn.title = 'Click to download Excel file (All data)';
    }
    
    // Clear month-specific filtering
    clearMonthFiltering();
    
    // Reload dashboard without filters
    showLoadingState();
    await loadDashboardData();
    
    // Reset month headers to current year
    updateMonthHeadersWithYear();
    
    // Update graphs and statistics without filters
    setTimeout(() => {
        updateTrackingGraph();
        updateCustomerMonthChart();
        updateStatistics();
    }, 500);
    
    showNotification(' Filter cleared - showing all data', 'success');
}

// REVERT ALL CHANGES FUNCTIONALITY
function revertAllChanges() {
    console.log(' Revert all changes requested');
    
    // Count how many edited networks exist
    let editedNetworksCount = 0;
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip Excel customers - only count Live DB customer edits
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.editedData) {
                    editedNetworksCount++;
                }
            });
        }
    });
    
    if (editedNetworksCount === 0) {
        showNotification(' No edited data found to revert', 'info');
        return;
    }
    
    // Confirmation dialog
    const confirmed = confirm(` Revert Changes\n\nThis will restore original data for ${editedNetworksCount} edited networks.\n\nAll your edits will be lost!\n\nContinue?`);
    
    if (!confirmed) {
        console.log(' Revert cancelled by user');
        return;
    }
    
    revertChangesConfirmed();
}

function revertChangesConfirmed() {
    console.log(' Starting revert process...');
    
    let revertedCount = 0;
    let clearedStorageCount = 0;
    
    // Revert all edited networks
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip Excel customers from revert - only revert Live DB customer edits
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return; // Skip Excel customers
        }
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.editedData && network.originalMonths) {
                    console.log(` Reverting ${customer.name} - ${network.name}`);
                    
                    // Restore original months data
                    network.months = [...network.originalMonths];
                    network.monthly_runs = [...network.originalMonths];
                    
                    // Remove edit flags
                    delete network.editedData;
                    delete network.originalMonths;
                    
                    revertedCount++;
                    
                    // Clear from localStorage
                    const isExcel = customer.excel_source || customer.excel_data;
                    const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                    
                    if (localStorage.getItem(storageKey)) {
                        localStorage.removeItem(storageKey);
                        clearedStorageCount++;
                        console.log(` Cleared localStorage: ${storageKey}`);
                    }
                }
            });
        }
    });
    
    // Recalculate statistics after revert
    if (revertedCount > 0) {
        // Recalculate total runs from all customers
        let totalRuns = 0;
        
        Object.values(dashboardData.customers).forEach(customer => {
            // Skip Excel customers from statistics recalculation - only count Live DB customers
            if (customer.excel_source || customer.excel_only || customer.excel_data) {
                return; // Skip Excel customers
            }
            
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach(network => {
                    totalRuns += getNetworkRuns(customer, network.name);
                });
            } else {
                totalRuns += customer.runs || customer.total_runs || 0;
            }
        });
        
        // Update statistics
        dashboardData.statistics.total_runs = totalRuns;
        dashboardData.statistics.filtered_runs = totalRuns;
        
        // Update UI
        updateDashboard();
        
        console.log(` Reverted ${revertedCount} networks, cleared ${clearedStorageCount} localStorage entries`);
        showNotification(` Successfully reverted ${revertedCount} edited networks to original state`, 'success');
    } else {
        showNotification(' No changes were found to revert', 'info');
    }
}

// REVERT SPECIFIC NETWORK (for individual revert)
function revertNetwork(customerName, networkName) {
    console.log(` Reverting specific network: ${customerName} - ${networkName}`);
    
    // Find the customer and network
    const customer = Object.values(dashboardData.customers).find(c => c.name === customerName);
    if (!customer) {
        showNotification(' Customer not found', 'error');
        return;
    }
    
    const network = customer.networks.find(n => 
        n.name === networkName || n.network_name === networkName
    );
    
    if (!network) {
        showNotification(' Network not found', 'error');
        return;
    }
    
    if (!network.editedData || !network.originalMonths) {
        showNotification(' Network has not been edited', 'info');
        return;
    }
    
    // Revert this specific network
    network.months = [...network.originalMonths];
    network.monthly_runs = [...network.originalMonths];
    
    // Remove edit flags
    delete network.editedData;
    delete network.originalMonths;
    
    // Clear from localStorage
    const isExcel = customer.excel_source || customer.excel_data;
    const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customerName}_${networkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
    localStorage.removeItem(storageKey);
    
    // Update UI
    updateDashboard();
    
    console.log(` Reverted network: ${networkName}`);
    showNotification(` Reverted ${networkName} to original state`, 'success');
}

// CLEANUP ON PAGE UNLOAD - COMMENTED OUT FOR NOW
/* window.addEventListener('beforeunload', function() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
}); */

//  REAL-TIME GRAPH AUTO-UPDATE SYSTEM
// This will make graphs update automatically when tracker is generated

window.dashboardRealTimeData = {};

// Enhanced real-time data fetching with cache bypass
function fetchRealTimeData(forceRefresh = false) {
    const timestamp = new Date().getTime();
    const url = forceRefresh ? 
        `/api/customer-dashboard/customers/?refresh=${timestamp}` : 
        `/api/customer-dashboard/customers/?t=${timestamp}`;
    
    console.log(" Fetching REAL-TIME dashboard data...");
    
    return fetch(url, {
        method: 'GET',
        headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return response.json();
    })
    .then(data => {
        if (data.success) {
            window.dashboardRealTimeData = data.customers;
            console.log(" Real-time data loaded:", Object.keys(data.customers).length, "customers");
            return data.customers;
        } else {
            throw new Error(data.error || 'API returned success=false');
        }
    })
    .catch(error => {
        console.error(" Real-time data fetch error:", error);
        return null;
    });
}

// Real-time month runs calculation using session counting
function getCustomerMonthRuns_REALTIME(customerName, targetMonth, targetYear) {
    console.log(` Getting REAL-TIME runs for ${customerName} - ${targetMonth}/${targetYear}`);
    
    // Find customer in real-time data
    const customer = Object.values(window.dashboardRealTimeData || {}).find(c => 
        c.name.toLowerCase().includes(customerName.toLowerCase()) ||
        customerName.toLowerCase().includes(c.name.toLowerCase())
    );
    
    if (!customer) {
        console.log(` Customer ${customerName} not found in real-time data`);
        return 0;
    }
    
    // Use real-time monthly counts if available
    if (customer.monthly_counts) {
        const monthKey = `${targetYear}-${targetMonth.toString().padStart(2, '0')}`;
        const count = customer.monthly_counts[monthKey] || 0;
        console.log(` REAL-TIME count for ${customerName} ${monthKey}: ${count}`);
        return count;
    }
    
    // Fallback to network counting
    let totalRuns = 0;
    if (customer.networks) {
        customer.networks.forEach(network => {
            if (network.monthly_counts) {
                const monthKey = `${targetYear}-${targetMonth.toString().padStart(2, '0')}`;
                if (network.monthly_counts[monthKey]) {
                    totalRuns += network.monthly_counts[monthKey];
                }
            }
        });
    }
    
    console.log(` Final REAL-TIME count for ${customerName} ${targetMonth}/${targetYear}: ${totalRuns}`);
    return totalRuns;
}

// Update activity graph with real-time data
function updateActivityGraph_REALTIME() {
    console.log(" Updating activity graph with REAL-TIME data...");
    
    const currentDate = new Date();
    const months = [];
    const data = [];
    
    // Get last 6 months
    for (let i = 5; i >= 0; i--) {
        const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthName = date.toLocaleString('default', { month: 'short' });
        months.push(monthName);
        
        // Count runs for this month across all customers using REAL-TIME data
        let monthTotal = 0;
        Object.values(window.dashboardRealTimeData || {}).forEach(customer => {
            const runs = getCustomerMonthRuns_REALTIME(customer.name, date.getMonth() + 1, date.getFullYear());
            monthTotal += runs;
        });
        
        data.push(monthTotal);
    }
    
    // Update the actual tracking graph
    const trackingGraph = document.getElementById('tracking-graph');
    if (trackingGraph) {
        // Simulate the updateTrackingGraph function with real-time data
        const monthsData = data.map((runs, index) => ({
            month: months[index],
            runs: runs,
            fullDate: new Date(currentDate.getFullYear(), currentDate.getMonth() - (5 - index), 1)
        }));
        
        // Call the existing graph update function with new data
        if (typeof updateTrackingGraph === 'function') {
            // Temporarily override data for the graph update
            const originalData = dashboardData;
            dashboardData = { customers: window.dashboardRealTimeData };
            updateTrackingGraph();
            dashboardData = originalData;
        }
    }
    
    console.log(' Activity graph updated with REAL-TIME data:', months, data);
}

// Update active customers chart with real-time data
function updateActiveCustomersChart_REALTIME() {
    console.log(" Updating active customers chart with REAL-TIME data...");
    
    const currentMonth = new Date().getMonth() + 1;
    const currentYear = new Date().getFullYear();
    
    const activeCustomers = [];
    const counts = [];
    
    Object.values(window.dashboardRealTimeData || {}).forEach(customer => {
        const runs = getCustomerMonthRuns_REALTIME(customer.name, currentMonth, currentYear);
        if (runs > 0) {
            activeCustomers.push(customer.name);
            counts.push(runs);
        }
    });
    
    // Update customer month chart
    const customerChart = document.getElementById('customer-month-chart');
    if (customerChart) {
        // Call the existing customer chart update function
        if (typeof updateCustomerMonthChart === 'function') {
            const originalData = dashboardData;
            dashboardData = { customers: window.dashboardRealTimeData };
            updateCustomerMonthChart();
            dashboardData = originalData;
        }
    }
    
    console.log(' Active customers chart updated with REAL-TIME data:', activeCustomers, counts);
}

// Update header statistics with real-time data
function updateHeaderStats_REALTIME() {
    const totalCustomers = Object.keys(window.dashboardRealTimeData || {}).length;
    let totalRuns = 0;
    let totalTrackers = 0;
    
    Object.values(window.dashboardRealTimeData || {}).forEach(customer => {
        totalRuns += customer.total_runs || 0;
        totalTrackers += 1; // Each customer represents a tracker
    });
    
    // Update header counts
    const customersCount = document.querySelector('.stat-value');
    const runsCount = document.querySelectorAll('.stat-value')[1];
    const trackersCount = document.querySelectorAll('.stat-value')[2];
    
    if (customersCount) customersCount.textContent = totalCustomers;
    if (runsCount) runsCount.textContent = totalRuns;
    if (trackersCount) trackersCount.textContent = totalTrackers;
    
    console.log(` Header stats updated: ${totalCustomers} customers, ${totalRuns} runs, ${totalTrackers} trackers`);
}

// Real-time refresh function removed for simplicity

// All auto-refresh removed - simple one-time load only

// Manual refresh functions removed

// Manual graph refresh removed

// All tracker and refresh callbacks removed

// All force updates and console messages removed

//  AUTO-DETECT TRACKER GENERATION (experimental)
// Monitor for new data and auto-refresh graphs
let lastDataChecksum = null;

function checkForNewData() {
    try {
        const currentData = JSON.stringify(dashboardData?.customers || {});
        const currentChecksum = currentData.length + (currentData.match(/run/g) || []).length;
        
        if (lastDataChecksum !== null && currentChecksum !== lastDataChecksum) {
            console.log(' New health check data detected! Auto-refreshing charts...');
            
            // Check if this is a new health check completion (look for new dates)
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth();
            const todayString = currentDate.getDate().toString().padStart(2, '0') + '-' + (currentDate.getMonth() + 1).toString().padStart(2, '0');
            
            // Check if any customer has new run today
            if (dashboardData && dashboardData.customers) {
                Object.values(dashboardData.customers).forEach(customer => {
                    if (customer.networks && Array.isArray(customer.networks)) {
                        customer.networks.forEach(network => {
                            if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                                const todayValue = network.monthly_runs[currentMonth];
                                if (todayValue === todayString) {
                                    console.log(` NEW RUN DETECTED: ${customer.name} - ${network.name} completed today!`);
                                    // Trigger increment if not already done
                                    updateMonthlyRunsAfterTool(customer.name, network.name || network.network_name, currentDate.toISOString());
                                }
                            }
                        });
                    }
                });
            }
            
            // Immediately update both charts
            if (typeof updateActivityChart === 'function') {
                updateActivityChart();
                console.log(' Activity chart updated with new run data');
            }
            if (typeof updateCurrentMonthCustomerChart === 'function') {
                updateCurrentMonthCustomerChart();
                console.log(' Customer chart updated with new run data');
            }
            
            // Also update statistics
            if (typeof updateStatistics === 'function') {
                updateStatistics();
            }
            
            // Show notification
            showNotification(' Charts updated with new health check data!', 'success');
        }
        
        lastDataChecksum = currentChecksum;
    } catch (error) {
        // Silent fail for checksum calculation
    }
}

// Auto data checking removed

//  ENHANCED FIX: Force graphs to use current year AND month data correctly
function fixGraphYearAndMonthIssue() {
    console.log(" ENHANCED FIX: Updating graphs for current year and month...");
    
    const currentYear = new Date().getFullYear();
    const currentMonth = new Date().getMonth() + 1; // 1-based month
    
    console.log(` Current date: ${currentYear}-${currentMonth} (${new Date().toLocaleDateString()})`);
    
    // Override getCustomerMonthRuns to always use current year
    if (typeof window.getCustomerMonthRuns === 'function') {
        const originalFunction = window.getCustomerMonthRuns;
        
        window.getCustomerMonthRuns = function(customer, year, month) {
            console.log(` Graph requesting data for: ${customer.name} - Year: ${year} -> ${currentYear}, Month: ${month}`);
            return originalFunction.call(this, customer, currentYear, month);
        };
        
        console.log(" getCustomerMonthRuns patched to use current year");
    }
    
    // Also fix getCustomerMonthRunDates to use current year
    if (typeof window.getCustomerMonthRunDates === 'function') {
        const originalDatesFunction = window.getCustomerMonthRunDates;
        
        window.getCustomerMonthRunDates = function(customer, year, month) {
            console.log(` Graph requesting dates for: ${customer.name} - Year: ${year} -> ${currentYear}, Month: ${month}`);
            return originalDatesFunction.call(this, customer, currentYear, month);
        };
        
        console.log(" getCustomerMonthRunDates patched to use current year");
    }
}

// Apply the enhanced fix immediately
fixGraphYearAndMonthIssue();

// Debug current month data
function debugCurrentMonthData() {
    const currentMonth = new Date().getMonth() + 1; // October = 10
    const currentYear = new Date().getFullYear();
    
    console.log(` DEBUGGING OCTOBER DATA:`);
    console.log(` Current Month: ${currentMonth} (${new Date().toLocaleDateString('en-US', { month: 'long' })})`);
    console.log(` Current Year: ${currentYear}`);
    
    if (dashboardData && dashboardData.customers) {
        Object.values(dashboardData.customers).forEach(customer => {
            const monthRuns = getCustomerMonthRuns(customer, currentYear, currentMonth);
            const monthDates = getCustomerMonthRunDates(customer, currentYear, currentMonth);
            
            if (monthRuns > 0 || monthDates?.count > 0) {
                console.log(` ${customer.name}:`);
                console.log(`   Runs in October: ${monthRuns}`);
                console.log(`   Date info:`, monthDates);
                
                // Check if customer has networks
                if (customer.networks && customer.networks.length > 0) {
                    customer.networks.forEach(network => {
                        if (network.last_run_date && !network.last_run_date.includes('Never')) {
                            console.log(`     Network ${network.name}: ${network.last_run_date} (${network.runs} runs)`);
                        }
                    });
                }
            }
        });
    }
}

window.debugCurrentMonthData = debugCurrentMonthData;

// Also fix the month calculation in graph functions
function updateTrackingGraph_FIXED() {
    if (typeof updateTrackingGraph === 'function') {
        updateTrackingGraph();
        console.log(" Activity graph updated with current year");
    }
}

function updateCustomerMonthChart_FIXED() {
    if (typeof updateCustomerMonthChart === 'function') {
        updateCustomerMonthChart();
        console.log(" Customer chart updated with current year");
    }
}

// Create comprehensive debug and refresh function
function debugAndRefreshGraphs() {
    console.log(' COMPREHENSIVE GRAPH DEBUG & REFRESH');
    console.log('=' .repeat(50));
    
    // Step 1: Debug current month data
    debugCurrentMonthData();
    
    // Step 2: Force data refresh
    console.log(' Step 2: Forcing data refresh...');
    loadDashboardData().then(() => {
        
        // Step 3: Debug again after refresh
        console.log(' Step 3: Data after refresh:');
        setTimeout(() => {
            debugCurrentMonthData();
            
            // Step 4: Update graphs with fresh data
            console.log(' Step 4: Updating graphs with fresh data...');
            updateTrackingGraph();
            updateCustomerMonthChart();
            updateStatistics();
            
            console.log(' Comprehensive refresh completed!');
            showNotification(' Graphs refreshed with latest data!', 'success');
        }, 1000);
    });
}

window.debugAndRefreshGraphs = debugAndRefreshGraphs;
window.debugOctober = debugCurrentMonthData;

// Auto-debug removed

// Auto-refresh removed for simplicity

console.log(" REAL-TIME GRAPH AUTO-UPDATE SYSTEM LOADED!");
console.log(" Graphs will now update every 30 seconds with CURRENT YEAR data");
console.log(" October 2025 runs should now show correctly!");
console.log(" Year issue fixed: graphs now use 2025 instead of 2024");

//  DEBUG DASHBOARD DATA FOR EXPORT
window.debugDashboardData = function() {
    console.log(' DEBUGGING DASHBOARD DATA FOR EXPORT');
    console.log('=' .repeat(60));
    
    if (!window.dashboardData || !window.dashboardData.customers) {
        console.error(' No dashboard data available!');
        return;
    }
    
    const customers = window.dashboardData.customers;
    console.log(` Total customers: ${Object.keys(customers).length}`);
    
    Object.values(customers).forEach(customer => {
        console.log(`\n CUSTOMER: ${customer.name}`);
        console.log(`    Total runs: ${customer.total_runs || customer.runs || 0}`);
        console.log(`    Country: ${customer.country || 'Unknown'}`);
        console.log(`    Networks: ${customer.networks?.length || 0}`);
        
        // Check customer-level months
        if (customer.months) {
            console.log(`    Customer months:`, customer.months);
        }
        
        // Check network-level data
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, i) => {
                console.log(`\n      Network ${i+1}: ${network.name || network.network_name}`);
                console.log(`        Runs: ${network.runs || network.total_runs || 0}`);
                console.log(`        Node Qty: ${network.node_count || network.node_qty || 0}`);
                
                if (network.months) {
                    console.log(`        Months:`, network.months);
                }
                if (network.monthly_runs) {
                    console.log(`        Monthly runs:`, network.monthly_runs);
                }
            });
        }
    });
};

//  CHECK RAW NETWORK DATA
window.checkNetworkMonthsData = function() {
    console.log(' CHECKING RAW NETWORK MONTHS DATA');
    console.log('=' .repeat(60));
    
    const customers = window.dashboardData?.customers;
    if (!customers) {
        console.error(' No customers data!');
        return;
    }
    
    Object.values(customers).forEach(customer => {
        if (customer.name === 'BSNL' || customer.name === 'Moratelindo' || customer.name === 'Tata') {
            console.log(`\n ${customer.name}:`);
            
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach(network => {
                    console.log(`   ${network.name}:`);
                    if (network.months) {
                        console.log(`    months array:`, network.months);
                    }
                    if (network.monthly_runs) {
                        console.log(`    monthly_runs array:`, network.monthly_runs);
                    }
                    if (!network.months && !network.monthly_runs) {
                        console.log(`     No monthly data arrays found`);
                    }
                });
            }
        }
    });
};

//  SPECIFIC BSNL DATA CHECK
window.checkBSNLData = function() {
    console.log(' CHECKING BSNL DATA SPECIFICALLY');
    
    const customers = window.dashboardData?.customers;
    if (!customers) {
        console.error(' No customers data!');
        return;
    }
    
    const bsnl = Object.values(customers).find(c => c.name === 'BSNL');
    if (!bsnl) {
        console.error(' BSNL not found!');
        return;
    }
    
    console.log(' BSNL FOUND:');
    console.log(`  Total runs: ${bsnl.total_runs || bsnl.runs}`);
    console.log(`  Networks: ${bsnl.networks?.length}`);
    
    if (bsnl.networks) {
        bsnl.networks.forEach(network => {
            console.log(`\n   ${network.name}:`);
            console.log(`    Runs: ${network.runs}`);
            if (network.months) {
                console.log(`    Monthly data:`, network.months);
            }
        });
    }
};

//  CHECK DASHBOARD DATA FOR MIGRATED DATES
window.checkDashboardMigratedData = function() {
    console.log(' CHECKING DASHBOARD DATA FOR MIGRATED DATES');
    console.log('=' .repeat(70));
    
    if (!window.dashboardData || !window.dashboardData.customers) {
        console.error(' No dashboard data!');
        return;
    }
    
    const customers = window.dashboardData.customers;
    console.log(` Found ${Object.keys(customers).length} customers in dashboard data`);
    
    // Check specific customers that should have migrated data
    const testCustomers = ['BSNL', 'Moratelindo', 'Tata', 'LTV', 'Maxix'];
    
    testCustomers.forEach(customerName => {
        const customer = Object.values(customers).find(c => c.name === customerName);
        if (customer) {
            console.log(`\n ${customerName}:`);
            console.log(`  Networks: ${customer.networks?.length || 0}`);
            
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, i) => {
                    console.log(`\n   Network ${i+1}: ${network.name}`);
                    
                    // Check for months array (migrated data)
                    if (network.months) {
                        const nonEmptyMonths = network.months.filter(m => m && m !== '-');
                        console.log(`     months array: [${network.months.slice(0, 6).join(', ')}...]`);
                        console.log(`     Non-empty months: ${nonEmptyMonths.length}`);
                        
                        // Show first few actual dates
                        nonEmptyMonths.slice(0, 3).forEach((date, idx) => {
                            console.log(`      ${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][network.months.indexOf(date)]}: ${date}`);
                        });
                    } else {
                        console.log(`     No months array found`);
                    }
                    
                    // Check for monthly_runs array
                    if (network.monthly_runs) {
                        console.log(`     monthly_runs array: [${network.monthly_runs.slice(0, 6).join(', ')}...]`);
                    }
                });
            } else {
                console.log(`   No networks found`);
            }
        } else {
            console.log(`\n ${customerName}: NOT FOUND in dashboard data`);
        }
    });
};

//  TEST EXPORT WITH DETAILED LOGGING
window.testExportData = function() {
    console.log(' TESTING EXPORT DATA GENERATION');
    console.log('=' .repeat(60));
    
    if (!window.dashboardData || !window.dashboardData.customers) {
        console.error(' No dashboard data available for export!');
        return;
    }
    
    const customers = window.dashboardData.customers;
    let exportData = [];
    
    Object.values(customers).forEach(customer => {
        console.log(`\n PROCESSING: ${customer.name}`);
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                console.log(`   Network: ${network.name}`);
                
                const rowData = {
                    'Customer': customer.name,
                    'Network': network.network_name || network.name,
                    'Total Runs': network.runs || 0
                };
                
                // Test monthly data extraction
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
                months.forEach((month, index) => {
                    const monthNumber = index + 1;
                    const currentYear = new Date().getFullYear();
                    
                    // Test the same function dashboard uses
                    const monthData = getNetworkMonthRunDates(customer, network.name || network.network_name, currentYear, monthNumber);
                    
                    let monthValue = '-';
                    if (monthData && monthData.date && monthData.date !== '-') {
                        monthValue = monthData.date;
                        console.log(`     ${month}: ${monthValue}`);
                    } else {
                        console.log(`     ${month}: No data`);
                    }
                    
                    rowData[month] = monthValue;
                });
                
                exportData.push(rowData);
            });
        }
    });
    
    console.log(`\n Export would contain ${exportData.length} rows`);
    return exportData;
};

console.log('');
console.log(' EXPORT DEBUG FUNCTIONS:');
console.log('  debugDashboardData() - Check all dashboard data');
console.log('  checkBSNLData() - Check BSNL specifically');
console.log('  checkNetworkMonthsData() - Check raw network monthly arrays');
console.log('  checkDashboardMigratedData() - Check for migrated Excel dates');
console.log('  testExportData() - Test export data generation');
console.log('\n MAIN ISSUE: If migrated data missing, dashboard API not loading Excel data');
console.log('  Use checkDashboardMigratedData() to verify what data is available');

// ===========================================
// NEW COMPLETE EXPORT/DOWNLOAD FUNCTIONS FOR CUSTOMER OVERVIEW BUTTONS
// ===========================================

/**
 * Export Complete Customer Overview to Excel
 * Exports all customer data exactly as shown in the Customer Overview table with live updates
 */
function exportCompleteOverview() {
    console.log(' Exporting COMPLETE Customer Overview to Excel...');
    
    try {
        // Show loading notification with better message
        showNotification(' Preparing Excel export with all customer data...', 'info');
        
        // Get all customer data from dashboard
        const customers = dashboardData?.customers || {};
        if (Object.keys(customers).length === 0) {
            // Don't show notification if data is still loading - just return silently
            console.log('Export: Waiting for dashboard data to load...');
            return;
        }
        
        // Prepare export data matching the dashboard table structure
        const exportData = [];
        const currentYear = new Date().getFullYear();
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // ENHANCED: Check for active date filters from dashboard
        let isFilterActive = false;
        let filterStartMonth = 0;
        let filterEndMonth = 11;
        let filteredMonths = months; // Default to all months
        
        // Check multiple filter sources
        if (window.isFilterActive || window.isMonthFilterActive || currentStartDate || currentEndDate) {
            const startDate = currentStartDate || window.currentStartDate;
            const endDate = currentEndDate || window.currentEndDate;
            
            if (startDate && endDate) {
                isFilterActive = true;
                filterStartMonth = new Date(startDate).getMonth();
                filterEndMonth = new Date(endDate).getMonth();
                
                // Create filtered months array - only include filtered months in headers
                filteredMonths = months.slice(filterStartMonth, filterEndMonth + 1);
                
                console.log(` FILTER DETECTED: Exporting only months ${filterStartMonth + 1} to ${filterEndMonth + 1}`);
                console.log(` Filtered months:`, filteredMonths);
            }
        }
        
        // If no filter detected, check if Filter Date Range header is visible (indicates active filter)
        const filterHeader = document.getElementById('filter-date-header');
        if (filterHeader && filterHeader.style.display !== 'none') {
            console.log(' VISUAL FILTER DETECTED: Table shows filtered view');
            // Extract visible month columns from table
            const visibleMonths = [];
            const monthHeaders = document.querySelectorAll('.month-col');
            monthHeaders.forEach((header, index) => {
                if (header.style.display !== 'none' && header.textContent && header.textContent !== 'Filter Date Range') {
                    visibleMonths.push(header.textContent.trim());
                }
            });
            if (visibleMonths.length > 0 && visibleMonths.length < 12) {
                isFilterActive = true;
                filteredMonths = visibleMonths;
                console.log(' Using visible months from table:', filteredMonths);
            }
        }
        
        // Process each customer (Live DB only, exclude Excel to avoid duplicates)
        Object.values(customers).forEach(customer => {
            // Skip Excel customers to avoid duplicates (show only Live DB customers as in dashboard)
            if (customer.excel_source || customer.excel_only || customer.excel_data) {
                console.log(` SKIPPING Excel customer for export: ${customer.name}`);
                return;
            }
            
            console.log(` EXPORTING Live DB customer: ${customer.name}`);
            
            // Prepare customer row data
            const customerRow = {
                'Type': 'Customer Summary',
                'Customer': customer.name,
                'Country': customer.country || customer.location || customer.region || 'Unknown',
                'Networks': customer.networks ? customer.networks.length : 0,
                'Node Qty': customer.node_count || customer.node_qty || customer.total_nodes || 0,
                'NE Type': customer.nw_type || customer.ne_type || customer.network_type || '1830 PSS',
                'GTAC': customer.gtac_team || customer.gtac || customer.gtac_type || 'PSS',
                'Last Run': getCustomerLastRunDisplay(customer)
            };
            
            // Add monthly data for customer summary - ONLY FILTERED MONTHS
            filteredMonths.forEach((month) => {
                const monthIndex = months.indexOf(month);
                let latestDate = '-';
                let totalRunsThisMonth = 0;
                
                // Check if this month should be included based on filter
                let shouldShowData = true;
                if (isFilterActive) {
                    shouldShowData = (monthIndex >= filterStartMonth && monthIndex <= filterEndMonth);
                    if (!shouldShowData) {
                        customerRow[month] = '-'; // Filtered out month
                        return;
                    }
                }
                
                // Use SAME function as dashboard table - getCustomerMonthRunDates
                const monthRunData = getCustomerMonthRunDates(customer, currentYear, monthIndex + 1);
                if (monthRunData && monthRunData.date && monthRunData.date !== '-') {
                    // Apply SAME date formatting as network data
                    const rawDate = monthRunData.date;
                    
                    // Format the date properly (same as CSV)
                    if (rawDate.match(/^\d{1,2}-\d{1,2}$/)) {
                        // Already in DD-MM format
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const month = parseInt(parts[1]);
                        latestDate = `${day.toString().padStart(2, '0')}-${month.toString().padStart(2, '0')}`;
                    } else if (rawDate.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/)) {
                        // DD-MMM format - convert to DD-MM
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const monthName = parts[1];
                        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                        const month = monthNames.indexOf(monthName) + 1;
                        latestDate = `${day.toString().padStart(2, '0')}-${month.toString().padStart(2, '0')}`;
                        console.log(` EXCEL CUSTOMER CONVERTED: ${rawDate} -> ${latestDate}`);
                    } else if (rawDate.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}$/)) {
                        // DD-MMM-YY format - convert to DD-MM
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const monthName = parts[1];
                        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                        const month = monthNames.indexOf(monthName) + 1;
                        latestDate = `${day.toString().padStart(2, '0')}-${month.toString().padStart(2, '0')}`;
                        console.log(` EXCEL CUSTOMER WITH YEAR: ${rawDate} -> ${latestDate}`);
                    } else {
                        latestDate = rawDate; // Keep as-is for status messages
                    }
                } else {
                    // Fallback to 'Not Started' or similar status  
                    if (customer.networks && customer.networks.length > 0) {
                        customer.networks.forEach(network => {
                            if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                                const monthValue = network.monthly_runs[monthIndex];
                                if (monthValue && (monthValue.includes('Not') || monthValue.includes('No')) && latestDate === '-') {
                                    latestDate = monthValue;
                                }
                            }
                        });
                    }
                }
                
                customerRow[month] = latestDate;
            });
            
            // Calculate total runs for customer - EXACTLY LIKE DASHBOARD TABLE
            let totalRuns = 0;
            
            // Check if filter is active and use same logic as dashboard
            const filterActive = window.isMonthFilterActive || isFilterActive;
            
            if (filterActive) {
                console.log(` EXCEL FILTER MODE: Calculating filtered runs for ${customer.name}`);
                // Count runs ONLY in filtered month range
                if (customer.networks && customer.networks.length > 0) {
                    customer.networks.forEach(network => {
                        if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                            network.monthly_runs.forEach((monthValue, monthIndex) => {
                                // STRICT: Only count if month is in filter range
                                if (monthIndex >= filterStartMonth && monthIndex <= filterEndMonth) {
                                    // Check if this month has actual run data (date format DD-MM)
                                    if (monthValue && 
                                        monthValue !== '-' && 
                                        monthValue !== 'N/S' &&
                                        monthValue !== 'N/R' &&
                                        monthValue !== 'N/Rpt' &&
                                        !monthValue.toLowerCase().includes('not') && 
                                        !monthValue.toLowerCase().includes('never') &&
                                        !monthValue.toLowerCase().includes('no') &&
                                        monthValue.match(/^\d{2}-\d{2}$/)) { // Must be DD-MM format
                                        totalRuns += 1;
                                        console.log(`    ${customer.name} ${network.network_name || network.name}: Month ${monthIndex+1} has run (${monthValue})`);
                                    } else {
                                        console.log(`    ${customer.name} ${network.network_name || network.name}: Month ${monthIndex+1} no run (${monthValue})`);
                                    }
                                }
                            });
                        }
                    });
                }
                console.log(`    FILTERED Total for ${customer.name}: ${totalRuns} runs`);
            } else {
                // No filter active - use getNetworkRuns like dashboard
                if (customer.networks && customer.networks.length > 0) {
                    customer.networks.forEach(network => {
                        let networkName = network.network_name || network.name || network;
                        // Clean network name EXACTLY like dashboard
                        if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
                            networkName = network.network_name;
                        } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
                            const cleanName = networkName.split(' - ').slice(1).join(' - ');
                            if (cleanName) {
                                networkName = cleanName;
                            }
                        }
                        const networkRuns = getNetworkRuns(customer, networkName) || 0;
                        totalRuns += networkRuns;
                    });
                } else {
                    totalRuns = customer.total_runs || customer.runs || customer.run_count || 0;
                }
            }
            customerRow['Total Runs'] = totalRuns;
            
            exportData.push(customerRow);
            
            // Add network detail rows
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, networkIndex) => {
                    const cleanNetworkName = getCleanNetworkName(network, customer.name);
                    
                    const networkRow = {
                        'Type': 'Network Detail', 
                        'Customer': customer.name, // CLEANED: Removed tree characters
                        'Network': cleanNetworkName || network.name || 'Default Network',
                        'Country': '',
                        'Networks': '',
                        'Node Qty': network.node_count || network.nodes || network.total_nodes || 0,
                        'NE Type': network.ne_type || network.equipment_type || 'PSS',
                        'GTAC': '',
                        'Last Run': ''
                    };
                    
                    // Add monthly data for this network - ONLY FILTERED MONTHS
                    filteredMonths.forEach((month) => {
                        const monthIndex = months.indexOf(month);
                        // Check if this month should be included based on filter
                        if (isFilterActive && (monthIndex < filterStartMonth || monthIndex > filterEndMonth)) {
                            networkRow[month] = '-'; // Filtered out month
                            return;
                        }
                        
                        let monthValue = '-';
                        
                        // FIXED DATE LOGIC: Ensure dates appear in correct months
                        if (network.monthly_runs && Array.isArray(network.monthly_runs) && network.monthly_runs[monthIndex]) {
                            let rawValue = network.monthly_runs[monthIndex];
                            
                            // STRICT DATE VALIDATION AND FORMATTING (same as CSV)
                            if (rawValue && rawValue !== '-' && typeof rawValue === 'string') {
                                // First check for DD-MM format (correct format)
                                if (rawValue.match(/^\d{1,2}-\d{1,2}$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const rawMonth = parseInt(parts[1]);
                                    
                                    // CRITICAL: Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}-${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` EXCEL CORRECT DD-MM: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                                    } else {
                                        console.log(` EXCEL WRONG MONTH: ${rawValue} belongs to month ${rawMonth}, not ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Check for DD-MMM format (like 5-Mar, 8-Jul)
                                else if (rawValue.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const monthName = parts[1];
                                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                                    const rawMonth = monthNames.indexOf(monthName) + 1;
                                    
                                    // Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}-${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` EXCEL CONVERTED DD-MMM: ${rawValue} -> ${monthValue}`);
                                    } else {
                                        console.log(` EXCEL MONTH MISMATCH: ${rawValue} (month ${rawMonth}) not for column ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Check for dates with year suffix (like 8-Jul-25, 26-Aug-25)
                                else if (rawValue.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const monthName = parts[1];
                                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                                    const rawMonth = monthNames.indexOf(monthName) + 1;
                                    
                                    // Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}-${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` EXCEL CONVERTED WITH YEAR: ${rawValue} -> ${monthValue}`);
                                    } else {
                                        console.log(` EXCEL YEAR FORMAT MISMATCH: ${rawValue} not for column ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Status messages (Not Started, Not Run, No Report)
                                else if (rawValue.includes('Not') || rawValue.includes('No')) {
                                    monthValue = rawValue;
                                }
                                // Invalid format - skip
                                else {
                                    console.log(` EXCEL INVALID FORMAT: ${rawValue} - skipping`);
                                    monthValue = '-';
                                }
                            }
                            
                            console.log(` EXPORT PROCESSED: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                        } else {
                            // Fallback to complex function - use CLEANED network name like dashboard does
                            const monthRunData = getNetworkMonthRunDates(customer, cleanNetworkName, currentYear, monthIndex + 1);
                            if (monthRunData && monthRunData.date && monthRunData.date !== '-' && monthRunData.date !== '0') {
                                monthValue = monthRunData.date;
                                console.log(` EXPORT FALLBACK: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                            }
                        }
                        
                        networkRow[month] = monthValue;
                    });
                    
                    //  Calculate network runs - respect filter if active
                    let networkRuns = 0;
                    
                    if (filterActive) {
                        // FILTER MODE: Count only runs in filtered month range
                        if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                            network.monthly_runs.forEach((monthValue, monthIndex) => {
                                if (monthIndex >= filterStartMonth && monthIndex <= filterEndMonth) {
                                    if (monthValue && 
                                        monthValue !== '-' && 
                                        monthValue !== 'N/S' &&
                                        monthValue !== 'N/R' &&
                                        monthValue !== 'N/Rpt' &&
                                        !monthValue.toLowerCase().includes('not') && 
                                        !monthValue.toLowerCase().includes('never') &&
                                        !monthValue.toLowerCase().includes('no') &&
                                        monthValue.match(/^\d{2}-\d{2}$/)) {
                                        networkRuns += 1;
                                    }
                                }
                            });
                        }
                        console.log(`    FILTERED ${cleanNetworkName}: ${networkRuns} runs`);
                    } else {
                        // NO FILTER: Use total runs
                        networkRuns = getNetworkRuns(customer, cleanNetworkName) || 0;
                        console.log(`    UNFILTERED ${cleanNetworkName}: ${networkRuns} runs`);
                    }
                    
                    networkRow['Total Runs'] = networkRuns;
                    
                    exportData.push(networkRow);
                });
            }
        });
        
        console.log(` Export contains ${exportData.length} rows`);
        
        // Create and download Excel file
        if (exportData.length > 0) {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `Customer_Overview_Complete_${timestamp}.xlsx`;
            
            // Convert to Excel using SheetJS (if available) or fallback to CSV
            if (typeof XLSX !== 'undefined') {
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(exportData);
                XLSX.utils.book_append_sheet(wb, ws, 'Customer Overview');
                XLSX.writeFile(wb, filename);
                const filterMsg = isFilterActive ? ` (Filtered: ${filteredMonths.join(', ')})` : ' (All months)';
                showNotification(` Excel file downloaded successfully! ${filterMsg} File: ${filename}`, 'success');
            } else {
                // Fallback to CSV export
                downloadCompleteOverview();
            }
        } else {
            showNotification(' No data available for export', 'error');
        }
        
    } catch (error) {
        console.error(' Export error:', error);
        showNotification(' Export failed: ' + error.message, 'error');
    }
}

/**
 * Download Complete Customer Overview as CSV
 * Downloads all customer data exactly as shown in the Customer Overview table with live updates
 */
function downloadCompleteOverview() {
    console.log(' Downloading COMPLETE Customer Overview as CSV...');
    
    try {
        // Show loading notification with better message
        showNotification(' Preparing CSV download with all customer data...', 'info');
        
        // Get all customer data from dashboard
        const customers = dashboardData?.customers || {};
        if (Object.keys(customers).length === 0) {
            // Don't show notification if data is still loading - just return silently
            console.log('Download: Waiting for dashboard data to load...');
            return;
        }
        
        // Prepare CSV data matching the dashboard table structure
        const csvData = [];
        const currentYear = new Date().getFullYear();
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // ENHANCED: Check for active date filters from dashboard (same as Excel)
        let isFilterActive = false;
        let filterStartMonth = 0;
        let filterEndMonth = 11;
        let filteredMonths = months; // Default to all months
        
        // Check multiple filter sources (same logic as Excel export)
        if (window.isFilterActive || window.isMonthFilterActive || isFilterActive || currentStartDate || currentEndDate) {
            const startDate = currentStartDate || window.currentStartDate;
            const endDate = currentEndDate || window.currentEndDate;
            
            if (startDate && endDate) {
                isFilterActive = true;
                filterStartMonth = new Date(startDate).getMonth();
                filterEndMonth = new Date(endDate).getMonth();
                filteredMonths = months.slice(filterStartMonth, filterEndMonth + 1);
                console.log(` CSV FILTER DETECTED: Downloading only months ${filterStartMonth + 1} to ${filterEndMonth + 1}`);
            }
        }
        
        // Check visual filter indicator
        const filterHeader = document.getElementById('filter-date-header');
        if (filterHeader && filterHeader.style.display !== 'none') {
            const visibleMonths = [];
            const monthHeaders = document.querySelectorAll('.month-col');
            monthHeaders.forEach((header) => {
                if (header.style.display !== 'none' && header.textContent && header.textContent !== 'Filter Date Range') {
                    visibleMonths.push(header.textContent.trim());
                }
            });
            if (visibleMonths.length > 0 && visibleMonths.length < 12) {
                isFilterActive = true;
                filteredMonths = visibleMonths;
                console.log(' CSV Using visible months from table:', filteredMonths);
            }
        }
        
        // CSV headers - use filtered months only
        const headers = [
            'Type', 'Customer', 'Network', 'Country', 'Networks', 'Node Qty', 'NE Type', 'GTAC', 'Last Run',
            ...filteredMonths, 'Total Runs'
        ];
        csvData.push(headers);
        
        // Process each customer (Live DB only, exclude Excel to avoid duplicates)
        Object.values(customers).forEach(customer => {
            // Skip Excel customers to avoid duplicates (show only Live DB customers as in dashboard)
            if (customer.excel_source || customer.excel_only || customer.excel_data) {
                console.log(` SKIPPING Excel customer for download: ${customer.name}`);
                return;
            }
            
            console.log(` DOWNLOADING Live DB customer: ${customer.name}`);
            
            // Prepare customer row data
            const customerRow = [
                'Customer Summary',
                customer.name,
                '', // Network column empty for customer summary
                customer.country || customer.location || customer.region || 'Unknown',
                customer.networks ? customer.networks.length : 0,
                customer.node_count || customer.node_qty || customer.total_nodes || 0,
                customer.nw_type || customer.ne_type || customer.network_type || '1830 PSS',
                customer.gtac_team || customer.gtac || customer.gtac_type || 'PSS',
                getCustomerLastRunDisplay(customer)
            ];
            
            // Add monthly data for customer summary - ONLY FILTERED MONTHS
            filteredMonths.forEach((month) => {
                const monthIndex = months.indexOf(month);
                // Check if this month should be included based on filter
                let shouldShowData = true;
                if (isFilterActive) {
                    shouldShowData = (monthIndex >= filterStartMonth && monthIndex <= filterEndMonth);
                    if (!shouldShowData) {
                        customerRow.push('-'); // Filtered out month
                        return;
                    }
                }
                
                let latestDate = '-';
                let totalRunsThisMonth = 0;
                
                // Use EXACT SAME logic as Excel export - getCustomerMonthRunDates function
                const monthRunData = getCustomerMonthRunDates(customer, currentYear, monthIndex + 1);
                if (monthRunData && monthRunData.date && monthRunData.date !== '-') {
                    // Apply SAME date formatting as Excel export
                    const rawDate = monthRunData.date;
                    
                    // Format the date properly (same as Excel)
                    if (rawDate.match(/^\d{1,2}-\d{1,2}$/)) {
                        // Already in DD-MM format - convert to DD/MM
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const month = parseInt(parts[1]);
                        latestDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}`;
                    } else if (rawDate.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/)) {
                        // DD-MMM format - convert to DD/MM
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const monthName = parts[1];
                        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                        const month = monthNames.indexOf(monthName) + 1;
                        latestDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}`;
                        console.log(` CSV CUSTOMER CONVERTED: ${rawDate} -> ${latestDate}`);
                    } else if (rawDate.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}$/)) {
                        // DD-MMM-YY format - convert to DD/MM
                        const parts = rawDate.split('-');
                        const day = parseInt(parts[0]);
                        const monthName = parts[1];
                        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                        const month = monthNames.indexOf(monthName) + 1;
                        latestDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}`;
                        console.log(` CSV CUSTOMER WITH YEAR: ${rawDate} -> ${latestDate}`);
                    } else {
                        latestDate = rawDate; // Keep as-is for status messages
                    }
                } else {
                    // Fallback to 'Not Started' or similar status  
                    if (customer.networks && customer.networks.length > 0) {
                        customer.networks.forEach(network => {
                            if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                                const monthValue = network.monthly_runs[monthIndex];
                                if (monthValue && (monthValue.includes('Not') || monthValue.includes('No')) && latestDate === '-') {
                                    latestDate = monthValue;
                                }
                            }
                        });
                    }
                }
                
                customerRow.push(latestDate);
            });
            
            // Calculate total runs for customer - EXACTLY LIKE DASHBOARD TABLE
            let totalRuns = 0;
            
            // Check if month filter is active (same as dashboard)
            const filterActive = window.isMonthFilterActive || isFilterActive;
            
            if (filterActive) {
                console.log(` CSV FILTER MODE: Calculating filtered runs for ${customer.name}`);
                
                // Use SAME filtered calculation as dashboard
                if (customer.networks && customer.networks.length > 0) {
                    customer.networks.forEach(network => {
                        if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                            network.monthly_runs.forEach((monthValue, monthIndex) => {
                                if (monthIndex >= filterStartMonth && monthIndex <= filterEndMonth) {
                                    if (monthValue && monthValue !== '-' && 
                                        !monthValue.toLowerCase().includes('not') && 
                                        !monthValue.toLowerCase().includes('never') &&
                                        !monthValue.toLowerCase().includes('no') &&
                                        monthValue.includes('-') && // Must be a date format
                                        monthValue.match(/^\d{2}-\d{2}$/)) { // Must be DD-MM format
                                        totalRuns += 1;
                                    }
                                }
                            });
                        }
                    });
                }
            } else {
                // No filter active - use normal calculation
                if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach(network => {
                    let networkName = network.network_name || network.name || network;
                    
                    // Clean network name EXACTLY like createNetworkDetailRow
                    if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
                        networkName = network.network_name;
                    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
                        const cleanName = networkName.split(' - ').slice(1).join(' - ');
                        if (cleanName) {
                            networkName = cleanName;
                        }
                    }
                    
                    // Use EXACT SAME getNetworkRuns function that dashboard table uses
                    const networkRuns = getNetworkRuns(customer, networkName) || 0;
                    totalRuns += networkRuns;
                    
                    console.log(` CSV CALC: ${customer.name} - ${networkName} = ${networkRuns} runs`);
                });
                } else {
                    totalRuns = customer.total_runs || customer.runs || customer.run_count || 0;
                }
            }
            
            console.log(` CSV TOTAL: ${customer.name} = ${totalRuns} runs (${filterActive ? 'filtered' : 'normal'} calculation)`);
            customerRow.push(totalRuns);
            
            csvData.push(customerRow);
            
            // Add network detail rows
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, networkIndex) => {
                    const cleanNetworkName = getCleanNetworkName(network, customer.name);
                    
                    const networkRow = [
                        'Network Detail',
                        customer.name, // CLEANED: Removed tree characters
                        cleanNetworkName || network.name || 'Default Network',
                        '', // Country empty for networks
                        '', // Networks empty for networks
                        network.node_count || network.nodes || network.total_nodes || 0,
                        network.ne_type || network.equipment_type || 'PSS',
                        '', // GTAC empty for networks
                        '' // Last Run empty for networks
                    ];
                    
                    // Add monthly data for this network - ONLY FILTERED MONTHS
                    filteredMonths.forEach((month) => {
                        const monthIndex = months.indexOf(month);
                        
                        let monthValue = '-';
                        
                        // FIXED CSV DATE LOGIC: Ensure dates appear in correct months
                        if (network.monthly_runs && Array.isArray(network.monthly_runs) && network.monthly_runs[monthIndex]) {
                            let rawValue = network.monthly_runs[monthIndex];
                            
                            // STRICT DATE VALIDATION AND FORMATTING
                            if (rawValue && rawValue !== '-' && typeof rawValue === 'string') {
                                // First check for DD-MM format (correct format)
                                if (rawValue.match(/^\d{1,2}-\d{1,2}$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const rawMonth = parseInt(parts[1]);
                                    
                                    // CRITICAL: Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}/${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` CSV CORRECT DD/MM: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                                    } else {
                                        console.log(` CSV WRONG MONTH: ${rawValue} belongs to month ${rawMonth}, not ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Check for DD-MMM format (like 5-Mar, 8-Jul)
                                else if (rawValue.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const monthName = parts[1];
                                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                                    const rawMonth = monthNames.indexOf(monthName) + 1;
                                    
                                    // Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}/${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` CSV CONVERTED DD-MMM: ${rawValue} -> ${monthValue}`);
                                    } else {
                                        console.log(` CSV MONTH MISMATCH: ${rawValue} (month ${rawMonth}) not for column ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Check for dates with year suffix (like 8-Jul-25, 26-Aug-25)
                                else if (rawValue.match(/^\d{1,2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}$/)) {
                                    const parts = rawValue.split('-');
                                    const day = parseInt(parts[0]);
                                    const monthName = parts[1];
                                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                                    const rawMonth = monthNames.indexOf(monthName) + 1;
                                    
                                    // Only include if month matches the column
                                    if (rawMonth === (monthIndex + 1)) {
                                        monthValue = `${day.toString().padStart(2, '0')}/${rawMonth.toString().padStart(2, '0')}`;
                                        console.log(` CSV CONVERTED WITH YEAR: ${rawValue} -> ${monthValue}`);
                                    } else {
                                        console.log(` CSV YEAR FORMAT MISMATCH: ${rawValue} not for column ${monthIndex + 1}`);
                                        monthValue = '-';
                                    }
                                }
                                // Status messages (Not Started, Not Run, No Report)
                                else if (rawValue.includes('Not') || rawValue.includes('No')) {
                                    monthValue = rawValue;
                                }
                                // Invalid format - skip
                                else {
                                    console.log(` CSV INVALID FORMAT: ${rawValue} - skipping`);
                                    monthValue = '-';
                                }
                            }
                            
                            console.log(` CSV PROCESSED: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                        } else {
                            // Fallback to complex function - use CLEANED network name like dashboard does
                            const monthRunData = getNetworkMonthRunDates(customer, cleanNetworkName, currentYear, monthIndex + 1);
                            if (monthRunData && monthRunData.date && monthRunData.date !== '-' && monthRunData.date !== '0') {
                                monthValue = monthRunData.date;
                                console.log(` CSV FALLBACK: ${cleanNetworkName} month ${monthIndex + 1} = "${monthValue}"`);
                            }
                        }
                        
                        networkRow.push(monthValue);
                    });
                    
                    // Calculate network runs using same method as dashboard
                    const networkRuns = getNetworkRuns(customer, cleanNetworkName) || 0;
                    networkRow.push(networkRuns);
                    
                    csvData.push(networkRow);
                });
            }
        });
        
        console.log(` Download contains ${csvData.length - 1} data rows`);
        
        // Convert to CSV string
        const csvContent = csvData.map(row => {
            return row.map(field => {
                // Escape quotes and wrap in quotes if contains comma, quote, or newline
                const fieldStr = String(field || '');
                if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
                    return '"' + fieldStr.replace(/"/g, '""') + '"';
                }
                return fieldStr;
            }).join(',');
        }).join('\n');
        
        // Create and download CSV file
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `Customer_Overview_Complete_${timestamp}.csv`;
        
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            const filterMsg = isFilterActive ? ` (Filtered: ${filteredMonths.join(', ')})` : ' (All months)';
            showNotification(` CSV file downloaded successfully! ${filterMsg} File: ${filename}`, 'success');
        } else {
            showNotification(' Download not supported in this browser', 'error');
        }
        
    } catch (error) {
        console.error(' Download error:', error);
        showNotification(' Download failed: ' + error.message, 'error');
    }
}


/**
 * Helper function to get clean network name - EXACT SAME logic as dashboard table (lines 6644-6657)
 */
function getCleanNetworkName(network, customerName) {
    // Clean network name - remove customer prefix like "Bsnl - "
    let networkName = network.network_name || network.name || network;
    
    // If network name is from network.name and has customer prefix, use network_name instead
    if (network.name && network.network_name && network.name.includes(`${customerName} - `)) {
        networkName = network.network_name;
        console.log(` EXPORT CLEANED: "${network.name}" -> "${networkName}"`);
    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
        // Remove any prefix before " - " (like "Bsnl - Timedotcom Default" -> "Timedotcom Default")
        const cleanName = networkName.split(' - ').slice(1).join(' - ');
        if (cleanName) {
            console.log(` EXPORT CLEANED PREFIX: "${networkName}" -> "${cleanName}"`);
            networkName = cleanName;
        }
    }
    
    return networkName;
}

/**
 * Helper function to get customer last run display
 */
function getCustomerLastRunDisplay(customer) {
    let lastRunInfo = 'Never';
    let lastRunDateStr = customer.actual_last_run || customer.last_run_date;
    
    if (lastRunDateStr && lastRunDateStr !== 'Never' && lastRunDateStr !== '-') {
        const lastRunDate = fixDateParsing(lastRunDateStr);
        if (lastRunDate) {
            // Format as DD-MM to match dashboard
            const day = lastRunDate.getDate().toString().padStart(2, '0');
            const month = (lastRunDate.getMonth() + 1).toString().padStart(2, '0');
            lastRunInfo = `${day}-${month}`;
        } else {
            lastRunInfo = lastRunDateStr; // Show original string if parsing fails
        }
    } else {
        // Check if customer has runs but no date - this indicates missing date integration
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        if (totalRuns > 0) {
            lastRunInfo = 'Date missing';
        }
    }
    
    return lastRunInfo;
}

// ========== LIVE DB ONLY EDIT MODAL - NEW IMPLEMENTATION ==========

/**
 * Open Live DB Only Edit Modal - Shows only Live DB customers, saves to localStorage
 */
function openLiveDBOnlyEditModal() {
    console.log(' Opening Live DB Only Edit Modal...');
    
    // Remove existing modal if present
    const existingModal = document.getElementById('liveDBOnlyEditModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Filter only Live DB customers (exclude Excel customers)
    const allCustomers = Object.values(dashboardData.customers || {});
    const liveDBCustomers = allCustomers.filter(customer => {
        return !(customer.excel_source || customer.excel_only || customer.excel_data);
    });
    
    if (liveDBCustomers.length === 0) {
        showNotification(' No Live DB customers found to edit', 'error');
        return;
    }
    
    console.log(` Found ${liveDBCustomers.length} Live DB customers to edit`);
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'liveDBOnlyEditModal';
    modal.style.display = 'block';
    modal.style.zIndex = '1000';
    
    // Generate modal content
    let modalContent = `
        <div class="modal-content" style="max-width: 95%; max-height: 90%; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #16a085 0%, #0f8b73 100%); color: white; padding: 16px; border-radius: 8px 8px 0 0;">
                <h2 style="margin: 0; font-size: 1.3rem;">
                     Live DB Editor
                </h2>
                <button class="close" onclick="closeLiveDBOnlyEditModal()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; float: right; margin-top: -8px;">&times;</button>
            </div>
            <div style="padding: 20px;">
                <p style="color: #555; margin-bottom: 20px; font-size: 0.9rem;">
                     Edit monthly run dates for Live DB customers only. Changes save to localStorage and persist after page refresh.
                </p>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                <th style="padding: 8px; text-align: left; border-right: 1px solid #dee2e6; min-width: 120px;">Customer</th>
                                <th style="padding: 8px; text-align: left; border-right: 1px solid #dee2e6; min-width: 120px;">Network</th>
                                <th style="padding: 8px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Reset</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Jan</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Feb</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Mar</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Apr</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">May</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Jun</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Jul</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Aug</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Sep</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px; background: #e8f5e8;">Oct</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Nov</th>
                                <th style="padding: 6px; text-align: center; border-right: 1px solid #dee2e6; min-width: 60px;">Dec</th>
                                <th style="padding: 6px; text-align: center; min-width: 80px; background: #e8f2ff; color: #0066cc; font-weight: bold;">Total Runs</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Generate table rows for each Live DB customer and their networks
    liveDBCustomers.forEach((customer, customerIndex) => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                // Get network name with multiple fallbacks
                let networkName = network.network_name || network.name || network.Network;
                
                // If none found, create from ID or use default
                if (!networkName) {
                    if (network.id) {
                        networkName = `Network_${network.id}`;
                    } else {
                        networkName = 'Default Network';
                    }
                }
                
                
                // Remove "Bsnl -" prefix if present
                if (networkName.startsWith('Bsnl - ')) {
                    networkName = networkName.replace('Bsnl - ', '');
                }
                
                // Remove customer name prefix if present
                if (networkName.startsWith(customer.name + ' - ')) {
                    networkName = networkName.replace(customer.name + ' - ', '');
                }
                
                const monthlyRuns = network.monthly_runs || Array(12).fill('-');
                
                modalContent += `<tr style="border-bottom: 1px solid #e9ecef;">`;
                modalContent += `<td style="padding: 8px; border-right: 1px solid #dee2e6; font-weight: 500;">${customer.name}</td>`;
                modalContent += `<td style="padding: 8px; border-right: 1px solid #dee2e6; color: #666;">${networkName}</td>`;
                modalContent += `<td style="padding: 4px; border-right: 1px solid #dee2e6; text-align: center;">
                    <button onclick="resetNetworkData('${customer.name}', '${networkName}')" 
                            style="background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 0.7rem;" 
                            title="Reset to original data">
                        
                    </button>
                </td>`;
                
                // Generate 12 month input fields
                for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                    const inputId = `livedb_edit_${customerIndex}_${networkIndex}_${monthIndex}`;
                    const currentValue = monthlyRuns[monthIndex] || '-';
                    const isOctober = monthIndex === 9;
                    const bgColor = isOctober ? 'background: #e8f5e8;' : '';
                    
                    modalContent += `<td style="padding: 4px; border-right: 1px solid #dee2e6; text-align: center; ${bgColor}">
                        <input type="text" 
                               id="${inputId}" 
                               value="${currentValue}" 
                               style="width: 50px; padding: 4px; border: 1px solid #ccc; border-radius: 3px; text-align: center; font-size: 0.8rem;"
                               placeholder="-"
                               onchange="markCustomerAsEdited('${customer.name}'); updateTotalRunsInModal(${customerIndex}, ${networkIndex});">
                    </td>`;
                }
                
                // Calculate Total Runs for this network using same logic as dashboard
                const networkRuns = getNetworkRuns(customer, networkName) || 0;
                
                // Add Total Runs column
                modalContent += `<td style="padding: 4px; text-align: center; background: #e8f2ff; color: #0066cc; font-weight: bold; font-size: 0.9rem;" id="modal_total_runs_${customerIndex}_${networkIndex}">
                    ${networkRuns}
                </td>`;
                
                modalContent += `</tr>`;
            });
        }
    });
    
    modalContent += `
                        </tbody>
                    </table>
                </div>
                
                <div style="margin-top: 20px; text-align: center; border-top: 1px solid #dee2e6; padding-top: 16px;">
                    <button onclick="saveLiveDBOnlyChanges()" 
                            style="background: linear-gradient(135deg, #16a085 0%, #0f8b73 100%); 
                                   color: white; 
                                   border: none; 
                                   padding: 10px 20px; 
                                   border-radius: 6px; 
                                   cursor: pointer; 
                                   margin-right: 10px;
                                   font-weight: 600;">
                         Save Changes
                    </button>
                    <button onclick="closeLiveDBOnlyEditModal()" 
                            style="background: #6c757d; 
                                   color: white; 
                                   border: none; 
                                   padding: 10px 20px; 
                                   border-radius: 6px; 
                                   cursor: pointer;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    modal.innerHTML = modalContent;
    document.body.appendChild(modal);
    
    // Load any existing saved data from localStorage
    loadSavedLiveDBData();
    
    // Update all Total Runs after loading data
    updateAllTotalRunsInModal();
    
    console.log(' Live DB Only Edit Modal opened');
}

/**
 * Close Live DB Only Edit Modal
 */
function closeLiveDBOnlyEditModal() {
    const modal = document.getElementById('liveDBOnlyEditModal');
    if (modal) {
        modal.remove();
        console.log(' Live DB Only Edit Modal closed');
    }
}

/**
 * Mark customer as edited (for tracking)
 */
function markCustomerAsEdited(customerName) {
    console.log(` Customer ${customerName} has been edited`);
}

/**
 * Update Total Runs in modal when monthly inputs change
 */
function updateTotalRunsInModal(customerIndex, networkIndex) {
    console.log(` Updating Total Runs for customer ${customerIndex}, network ${networkIndex}`);
    
    let totalRuns = 0;
    
    // Count valid dates from the 12 month inputs
    for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
        const inputId = `livedb_edit_${customerIndex}_${networkIndex}_${monthIndex}`;
        const inputElement = document.getElementById(inputId);
        
        if (inputElement) {
            const monthValue = inputElement.value.trim();
            
            // Count valid dates (same logic as dashboard)
            if (monthValue && monthValue !== '-' && 
                !monthValue.toLowerCase().includes('not') && 
                !monthValue.toLowerCase().includes('never') &&
                !monthValue.toLowerCase().includes('no') &&
                monthValue.includes('-') && // Must be a date format
                monthValue.match(/^\d{1,2}-\d{1,2}$/)) { // Must be DD-MM format
                totalRuns += 1;
            }
        }
    }
    
    // Update the Total Runs display
    const totalRunsElement = document.getElementById(`modal_total_runs_${customerIndex}_${networkIndex}`);
    if (totalRunsElement) {
        totalRunsElement.textContent = totalRuns;
        console.log(` Updated Total Runs to ${totalRuns} for customer ${customerIndex}, network ${networkIndex}`);
    }
}

/**
 * Update all Total Runs in modal after loading data
 */
function updateAllTotalRunsInModal() {
    console.log(' Updating all Total Runs in modal...');
    
    const allCustomers = Object.values(dashboardData.customers || {});
    const liveDBCustomers = allCustomers.filter(customer => {
        return !(customer.excel_source || customer.excel_only || customer.excel_data);
    });
    
    liveDBCustomers.forEach((customer, customerIndex) => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                updateTotalRunsInModal(customerIndex, networkIndex);
            });
        }
    });
    
    console.log(' All Total Runs updated in modal');
}

/**
 * Reset network data to original values (from modal)
 */
function resetNetworkData(customerName, networkName) {
    if (confirm(` Reset ${networkName} data for ${customerName} to original values?\n\nThis will restore the data from before your edits.`)) {
        const success = deleteSavedLiveDBEdit(customerName, networkName);
        
        if (success) {
            showNotification(` Reset ${networkName} for ${customerName} to original data`, 'success');
            
            // Refresh the modal with updated data including Total Runs
            closeLiveDBOnlyEditModal();
            setTimeout(() => {
                openLiveDBOnlyEditModal();
            }, 300);
        } else {
            showNotification(` No saved edits found for ${networkName}`, 'warning');
        }
    }
}

/**
 * Load saved data from localStorage into the modal inputs
 */
function loadSavedLiveDBData() {
    console.log(' Loading saved Live DB data from localStorage...');
    
    let loadedCount = 0;
    const allCustomers = Object.values(dashboardData.customers || {});
    const liveDBCustomers = allCustomers.filter(customer => {
        return !(customer.excel_source || customer.excel_only || customer.excel_data);
    });
    
    liveDBCustomers.forEach((customer, customerIndex) => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                let originalNetworkName = network.network_name || network.name || network.Network || 'Default Network';
                
                // If still Default Network, try to extract from other fields
                if (originalNetworkName === 'Default Network' && network.id) {
                    originalNetworkName = `Network_${network.id}`;
                }
                
                // Clean network name for localStorage key matching
                let cleanNetworkName = originalNetworkName;
                if (cleanNetworkName.startsWith('Bsnl - ')) {
                    cleanNetworkName = cleanNetworkName.replace('Bsnl - ', '');
                }
                if (cleanNetworkName.startsWith(customer.name + ' - ')) {
                    cleanNetworkName = cleanNetworkName.replace(customer.name + ' - ', '');
                }
                
                const storageKey = `livedb_edit_${customer.name}_${cleanNetworkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                
                const savedData = localStorage.getItem(storageKey);
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        console.log(` Loading saved data for ${customer.name} - ${cleanNetworkName}:`, data);
                        
                        // Load the saved monthly data into inputs
                        for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                            const inputId = `livedb_edit_${customerIndex}_${networkIndex}_${monthIndex}`;
                            const inputElement = document.getElementById(inputId);
                            
                            if (inputElement && data.months && data.months[monthIndex]) {
                                inputElement.value = data.months[monthIndex];
                                loadedCount++;
                            }
                        }
                    } catch (error) {
                        console.error(` Error loading saved data for ${customer.name} - ${cleanNetworkName}:`, error);
                    }
                }
            });
        }
    });
    
    if (loadedCount > 0) {
        showNotification(` Loaded ${loadedCount} saved edits from localStorage`, 'info');
    }
}

/**
 * Save Live DB Only Changes - Only affects edited customers, saves to localStorage
 */
function saveLiveDBOnlyChanges() {
    console.log(' Saving Live DB Only changes...');
    
    // Debug: Check if dashboardData exists
    if (!dashboardData || !dashboardData.customers) {
        console.error(' Dashboard data not available!');
        showNotification(' Dashboard data not available!', 'error');
        return;
    }
    
    const allCustomers = Object.values(dashboardData.customers || {});
    const liveDBCustomers = allCustomers.filter(customer => {
        return !(customer.excel_source || customer.excel_only || customer.excel_data);
    });
    
    console.log(` Found ${liveDBCustomers.length} Live DB customers to check:`, liveDBCustomers.map(c => c.name));
    
    // Debug: Check if ANY input fields exist and have values
    const allInputs = document.querySelectorAll('input[id^="livedb_edit_"]');
    console.log(` Found ${allInputs.length} input fields`);
    
    let hasAnyInput = false;
    allInputs.forEach((input, index) => {
        if (input.value && input.value.trim() !== '' && input.value.trim() !== '-') {
            console.log(` Input ${index}: ${input.id} = "${input.value}"`);
            hasAnyInput = true;
        }
    });
    
    if (!hasAnyInput) {
        console.log(' No inputs with values found');
    }
    
    let totalChanges = 0;
    const changedCustomers = [];
    const editedMonths = new Set(); // Track which months were edited
    
    liveDBCustomers.forEach((customer, customerIndex) => {
        if (customer.networks && customer.networks.length > 0) {
            let customerHasChanges = false;
            
            customer.networks.forEach((network, networkIndex) => {
                // Use ORIGINAL network name for precise matching (not cleaned)
                let originalNetworkName = network.network_name || network.name || network.Network || 'Default Network';
                
                // If still Default Network, try to extract from other fields
                if (originalNetworkName === 'Default Network' && network.id) {
                    originalNetworkName = `Network_${network.id}`;
                }
                
                // Clean network name only for localStorage key
                let cleanNetworkName = originalNetworkName;
                if (cleanNetworkName.startsWith('Bsnl - ')) {
                    cleanNetworkName = cleanNetworkName.replace('Bsnl - ', '');
                }
                if (cleanNetworkName.startsWith(customer.name + ' - ')) {
                    cleanNetworkName = cleanNetworkName.replace(customer.name + ' - ', '');
                }
                
                // Get original months data (check multiple sources)
                let originalMonths = network.monthly_runs || network.months || Array(12).fill('-');
                if (!Array.isArray(originalMonths)) {
                    originalMonths = Array(12).fill('-');
                }
                
                const newMonths = Array(12).fill('-');
                let networkHasChanges = false;
                
                console.log(` Checking changes for ${customer.name} - ${cleanNetworkName}:`);
                console.log(`   Original months:`, originalMonths);
                
                // Collect new values from inputs
                for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                    const inputId = `livedb_edit_${customerIndex}_${networkIndex}_${monthIndex}`;
                    const inputElement = document.getElementById(inputId);
                    
                    if (inputElement) {
                        let newValue = inputElement.value.trim();
                        if (!newValue || newValue === '') {
                            newValue = '-';
                        }
                        
                        const oldValue = originalMonths[monthIndex] || '-';
                        newMonths[monthIndex] = newValue;
                        
                        console.log(`   Month ${monthIndex + 1}: "${oldValue}" vs "${newValue}"`);
                        
                        // Check if value actually changed
                        if (newValue !== oldValue) {
                            networkHasChanges = true;
                            editedMonths.add(monthIndex); // Track this month was edited
                            console.log(` CHANGE DETECTED: ${customer.name} - ${cleanNetworkName} - Month ${monthIndex + 1}: "${oldValue}"  "${newValue}"`);
                        }
                    } else {
                        console.log(` Input element not found: ${inputId}`);
                    }
                }
                
                console.log(`   Network has changes: ${networkHasChanges}`);
                console.log(`   New months:`, newMonths);
                
                // Save changes if any
                if (networkHasChanges) {
                    // Update the network data and RECALCULATE runs count
                    network.monthly_runs = [...newMonths];
                    network.months = [...newMonths];
                    network.editedData = true;
                    network.editedTimestamp = Date.now();
                    
                    // INCREMENTAL CALCULATION - Only count the changes, not recalculate everything
                    const originalValidRuns = originalMonths.filter(month => {
                        return month && month !== '-' && month !== 'Not Started' && 
                               month !== 'Not Run' && month !== 'No Report';
                    }).length;
                    
                    const newValidRuns = newMonths.filter(month => {
                        return month && month !== '-' && month !== 'Not Started' && 
                               month !== 'Not Run' && month !== 'No Report';
                    }).length;
                    
                    // Calculate the CHANGE (increase or decrease)
                    const originalNetworkRuns = network.runs || network.total_runs || 0;
                    const runsDifference = newValidRuns - originalValidRuns;
                    const newNetworkRuns = Math.max(0, originalNetworkRuns + runsDifference);
                    
                    network.runs = newNetworkRuns;
                    network.total_runs = newNetworkRuns;
                    
                    console.log(` INCREMENTAL: ${customer.name} - ${cleanNetworkName}:`);
                    console.log(`   Original runs: ${originalNetworkRuns}`);
                    console.log(`   Change: ${runsDifference > 0 ? '+' : ''}${runsDifference}`);
                    console.log(`   New runs: ${newNetworkRuns}`);
                    
                    console.log(` UPDATED: ${customer.name} - ${cleanNetworkName}: ${newNetworkRuns} runs`);
                    
                    // Send to backend to save in database
                    saveNetworkToDatabase(customer.name, cleanNetworkName, newMonths, newNetworkRuns);
                    
                    // Save to localStorage for persistence using clean network name
                    const storageKey = `livedb_edit_${customer.name}_${cleanNetworkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                    localStorage.setItem(storageKey, JSON.stringify({
                        customerName: customer.name,
                        networkName: cleanNetworkName,
                        originalNetworkName: originalNetworkName, // Store both names
                        months: newMonths,
                        originalMonths: originalMonths,
                        timestamp: Date.now(),
                        source: 'livedb_edit'
                    }));
                    
                    totalChanges++;
                    customerHasChanges = true;
                    
                    console.log(` SAVED: ${customer.name} - ${cleanNetworkName} (${originalNetworkName}) to localStorage`);
                }
            });
            
            if (customerHasChanges && !changedCustomers.includes(customer.name)) {
                changedCustomers.push(customer.name);
            }
        }
    });
    
    if (totalChanges > 0) {
        // Update the dashboard data while preserving customer total runs
        dashboardData.customers = Object.fromEntries(
            Object.entries(dashboardData.customers).map(([key, customer]) => {
                const liveCustomer = liveDBCustomers.find(c => c.name === customer.name);
                if (liveCustomer) {
                    // Preserve customer's original total runs
                    const originalCustomerRuns = customer.runs || customer.total_runs || 0;
                    liveCustomer.runs = originalCustomerRuns;
                    liveCustomer.total_runs = originalCustomerRuns;
                    return [key, liveCustomer];
                }
                return [key, customer];
            })
        );
        
        // TARGETED UPDATE - Only update table, NO graphs or header cards
        updateEditedCustomersOnly(changedCustomers);  // Only update edited customers data
        updateEditedCustomersInTable(changedCustomers); // Update only edited rows in table
        
        // Force table refresh to show new values immediately
        setTimeout(() => {
            if (window.updateCustomerGrid) {
                console.log(' Refreshing customer table to show changes');
                window.updateCustomerGrid();
            }
        }, 100);
        
        // SKIP updateChartsAndGraphs - Keep graphs unchanged during Live DB Edit
        console.log(' Graphs and header cards deliberately skipped to preserve original state');
        
        showNotification(` Saved ${totalChanges} changes for ${changedCustomers.length} customers: ${changedCustomers.join(', ')}`, 'success');
        
        closeLiveDBOnlyEditModal();
        
        console.log(` Successfully saved ${totalChanges} changes - Dashboard fully updated`);
        
        // Show targeted visual feedback for updated customers only
        showTargetedUpdateAnimation(changedCustomers);
    } else {
        console.log(' No changes detected:');
        console.log(`   - Checked ${liveDBCustomers.length} customers`);
        console.log(`   - Found ${allInputs.length} input fields`);
        console.log(`   - Inputs with values: ${hasAnyInput ? 'Yes' : 'No'}`);
        
        if (allInputs.length === 0) {
            showNotification(' No input fields found! Modal might not be loaded properly.', 'error');
        } else {
            showNotification(' No changes detected. Try editing some month values and save again.', 'info');
        }
    }
}

/**
 * Load saved Live DB edits from localStorage on page load
 */
function loadSavedLiveDBEditsOnPageLoad() {
    console.log(' Loading saved Live DB edits on page load...');
    
    if (!dashboardData.customers) {
        console.log(' Dashboard data not ready yet, skipping localStorage load');
        return;
    }
    
    let loadedCount = 0;
    const allCustomers = Object.values(dashboardData.customers || {});
    const liveDBCustomers = allCustomers.filter(customer => {
        return !(customer.excel_source || customer.excel_only || customer.excel_data);
    });
    
    liveDBCustomers.forEach(customer => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                let networkName = network.network_name || network.name || network.Network || 'Default Network';
                
                // If still Default Network, try to extract from other fields
                if (networkName === 'Default Network' && network.id) {
                    networkName = `Network_${network.id}`;
                }
                
                // Clean network name for localStorage key
                let cleanNetworkName = networkName;
                if (cleanNetworkName.startsWith('Bsnl - ')) {
                    cleanNetworkName = cleanNetworkName.replace('Bsnl - ', '');
                }
                if (cleanNetworkName.startsWith(customer.name + ' - ')) {
                    cleanNetworkName = cleanNetworkName.replace(customer.name + ' - ', '');
                }
                
                const storageKey = `livedb_edit_${customer.name}_${cleanNetworkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                
                const savedData = localStorage.getItem(storageKey);
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        console.log(` Restoring saved data for ${customer.name} - ${networkName}:`, data);
                        
                        // Restore the saved monthly data but preserve original runs
                        const originalRuns = network.runs || network.total_runs || 0;
                        
                        network.monthly_runs = [...data.months];
                        network.months = [...data.months];
                        network.editedData = true;
                        network.editedTimestamp = data.timestamp;
                        network.originalMonths = data.originalMonths;
                        
                        // Preserve original runs count
                        network.runs = originalRuns;
                        network.total_runs = originalRuns;
                        
                        loadedCount++;
                        
                        console.log(` RESTORED: ${customer.name} - ${networkName}`);
                    } catch (error) {
                        console.error(` Error loading saved data for ${customer.name} - ${networkName}:`, error);
                    }
                }
            });
        }
    });
    
    if (loadedCount > 0) {
        console.log(` Loaded ${loadedCount} saved edits from localStorage on page load`);
        updateCustomerGrid(); // Update table to show restored data
        showNotification(` Restored ${loadedCount} saved edits from previous session`, 'info');
    }
}

/**
 * Delete saved edits (restore to original)
 */
function deleteSavedLiveDBEdit(customerName, networkName) {
    const storageKey = `livedb_edit_${customerName}_${networkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
    const savedData = localStorage.getItem(storageKey);
    
    if (savedData) {
        try {
            const data = JSON.parse(savedData);
            
            // Find the customer and network
            const allCustomers = Object.values(dashboardData.customers || {});
            const customer = allCustomers.find(c => c.name === customerName);
            
            if (customer && customer.networks) {
                const network = customer.networks.find(n => {
                    let nName = n.network_name || n.name || n.Network || 'Default Network';
                    
                    // If still Default Network, try to extract from other fields
                    if (nName === 'Default Network' && n.id) {
                        nName = `Network_${n.id}`;
                    }
                    
                    // Clean network name for comparison
                    if (nName.startsWith('Bsnl - ')) {
                        nName = nName.replace('Bsnl - ', '');
                    }
                    if (nName.startsWith(customerName + ' - ')) {
                        nName = nName.replace(customerName + ' - ', '');
                    }
                    
                    return nName === networkName;
                });
                
                if (network && data.originalMonths) {
                    // Restore original data
                    network.monthly_runs = [...data.originalMonths];
                    network.months = [...data.originalMonths];
                    delete network.editedData;
                    delete network.editedTimestamp;
                    delete network.originalMonths;
                    
                    // Remove from localStorage
                    localStorage.removeItem(storageKey);
                    
                    console.log(` DELETED saved edit for ${customerName} - ${networkName}`);
                    
                    // Update table
                    updateCustomerGrid();
                    
                    return true;
                }
            }
        } catch (error) {
            console.error(` Error deleting saved data for ${customerName} - ${networkName}:`, error);
        }
    }
    
    return false;
}

// Auto-load saved data when dashboard data is ready
if (typeof updateDashboard !== 'undefined') {
    const originalUpdateDashboard = updateDashboard;
    updateDashboard = function() {
        originalUpdateDashboard.call(this);
        // Load saved edits after dashboard is updated
        setTimeout(() => {
            loadSavedLiveDBEditsOnPageLoad();
        }, 500);
    };
}

console.log(' Live DB Only Edit Modal functions loaded');

// ========== MISSING DUAL CHART FUNCTIONS - CRITICAL FIX ==========

// Update Activity Chart (Left Chart - Last 6 Months)
function updateActivityChart() {
    console.log(' Updating Activity Chart with dashboard data...');
    
    const chartContainer = document.getElementById('activity-chart');
    const totalRunsElement = document.getElementById('chart-total-runs');
    
    if (!chartContainer) {
        console.log(' Chart container not found');
        return;
    }
    
    // Get current data from dashboard
    if (!dashboardData || !dashboardData.customers) {
        console.log(' No dashboard data available');
        chartContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; font-weight: 600;">
                 No data available
            </div>
        `;
        return;
    }
    
    // Check if customers object is empty
    if (Object.keys(dashboardData.customers).length === 0) {
        console.log(' Dashboard customers object is empty');
        chartContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #f59e0b; font-weight: 600;">
                 Loading data...
            </div>
        `;
        return;
    }
    
    console.log(' Processing chart data with', Object.keys(dashboardData.customers).length, 'customers');
    
    // Simple last 6 months data
    const currentDate = new Date();
    const monthsData = [];
    
    // Generate last 6 months
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'short' });
        const monthNumber = monthDate.getMonth() + 1;
        const year = monthDate.getFullYear();
        
        let monthTotal = 0;
        
        // DYNAMIC FIX: Count runs based on ACTUAL RUN DATES
        Object.values(dashboardData.customers).forEach(customer => {
            // Skip Excel customers
            if (customer.excel_source || customer.excel_only || customer.excel_data) {
                return;
            }
            
            let customerMonthRuns = 0;
            
            // FIXED: Check networks for ACTUAL dates in this specific month/year
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network) => {
                    // Check if network has last_run_date and it matches this month/year
                    if (network.last_run_date && 
                        network.last_run_date !== 'Never' && 
                        network.last_run_date !== '-' && 
                        network.runs > 0) {
                        
                        try {
                            const networkDate = new Date(network.last_run_date);
                            if (!isNaN(networkDate.getTime())) {
                                const networkYear = networkDate.getFullYear();
                                const networkMonth = networkDate.getMonth() + 1;
                                
                                // If network's actual run date matches this chart month/year
                                if (networkYear === year && networkMonth === monthNumber) {
                                    customerMonthRuns += network.runs;
                                    console.log(` REAL DATE: ${customer.name} - ${network.name} ran in ${monthName} ${year}`);
                                }
                            }
                        } catch (error) {
                            console.log(` Date parse error: ${network.name}`);
                        }
                    }
                    
                    // BACKUP: Check monthly_runs array for valid dates only
                    if (customerMonthRuns === 0 && network.monthly_runs && Array.isArray(network.monthly_runs)) {
                        const monthValue = network.monthly_runs[monthNumber - 1];
                        if (monthValue && monthValue !== '-' && monthValue !== 'Never' && monthValue !== 'Not Started') {
                            // Only count if it's a real date format
                            if (typeof monthValue === 'string' && monthValue.includes('-')) {
                                customerMonthRuns += 1;
                            }
                        }
                    }
                });
            }
            
            // NO current month fallback - only show real dates
            
            monthTotal += customerMonthRuns;
        });
        
        monthsData.push({
            month: monthName,
            year: year,
            runs: monthTotal
        });
    }
    
    // Calculate totals
    const totalRuns = monthsData.reduce((sum, month) => sum + month.runs, 0);
    const maxRuns = Math.max(...monthsData.map(m => m.runs), 1);
    
    // Update total runs display
    if (totalRunsElement) {
        totalRunsElement.textContent = totalRuns;
    }
    
    // Render chart
    chartContainer.innerHTML = '';
    chartContainer.style.cssText = `
        display: flex;
        align-items: flex-end;
        justify-content: space-around;
        height: 200px;
        padding: 20px 16px 40px 16px;
        background: linear-gradient(to bottom, rgba(59, 130, 246, 0.04) 0%, transparent 50%);
        border-radius: 12px;
        position: relative;
    `;
    
    // Create bars
    monthsData.forEach((monthData, index) => {
        const percentage = maxRuns > 0 ? (monthData.runs / maxRuns) * 100 : 0;
        const barHeight = Math.max((percentage / 100) * 120, 8);
        
        const barContainer = document.createElement('div');
        barContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        `;
        
        const bar = document.createElement('div');
        bar.style.cssText = `
            width: 60%;
            height: ${barHeight}px;
            background: linear-gradient(135deg, 
                ${monthData.runs > 0 ? '#3b82f6' : '#e5e7eb'} 0%, 
                ${monthData.runs > 0 ? '#1d4ed8' : '#d1d5db'} 100%);
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        `;
        
        // Add value label
        if (monthData.runs > 0) {
            const valueLabel = document.createElement('div');
            valueLabel.style.cssText = `
                position: absolute;
                top: -24px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 0.75rem;
                font-weight: 700;
                color: #1d4ed8;
                background: rgba(255, 255, 255, 0.9);
                padding: 2px 6px;
                border-radius: 4px;
            `;
            valueLabel.textContent = monthData.runs;
            bar.appendChild(valueLabel);
        }
        
        // Add month label
        const monthLabel = document.createElement('div');
        monthLabel.style.cssText = `
            margin-top: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #4b5563;
            text-align: center;
        `;
        monthLabel.textContent = monthData.month;
        
        barContainer.appendChild(bar);
        barContainer.appendChild(monthLabel);
        chartContainer.appendChild(barContainer);
    });
    
    console.log(' Activity chart updated successfully!');
}

// Update Current Month Customer Chart (Right Chart)
function updateCurrentMonthCustomerChart() {
    console.log(' Updating Current Month Customer Chart...');
    
    const chartContainer = document.getElementById('month-customer-chart');
    const totalCustomersElement = document.getElementById('month-chart-total-customers');
    
    if (!chartContainer) {
        console.log(' Customer chart container not found');
        return;
    }
    
    // Get current data
    if (!dashboardData || !dashboardData.customers || Object.keys(dashboardData.customers).length === 0) {
        chartContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">
                 Loading customer data...
            </div>
        `;
        return;
    }
    
    // DYNAMIC: Get current month info - but use actual run dates
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    const monthName = currentDate.toLocaleDateString('en-US', { month: 'long' });
    
    console.log(` Customer Chart for ${monthName} ${currentYear} (checking actual run dates)`);
    
    // Collect customer data for current month
    const customerData = [];
    
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip Excel customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            return;
        }
        
        let customerCurrentMonthRuns = 0;
        
        // DYNAMIC FIX: Check networks for ACTUAL current month activity only
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network) => {
                // PRIORITY: Check if network has REAL last_run_date in this month/year
                if (network.last_run_date && 
                    network.last_run_date !== 'Never' && 
                    network.last_run_date !== '-' && 
                    network.runs > 0) {
                    
                    try {
                        const networkDate = new Date(network.last_run_date);
                        if (!isNaN(networkDate.getTime())) {
                            const networkYear = networkDate.getFullYear();
                            const networkMonth = networkDate.getMonth() + 1;
                            
                            // If network's run date matches current month/year
                            if (networkYear === currentYear && networkMonth === currentMonth) {
                                customerCurrentMonthRuns += network.runs;
                                console.log(` REAL DATE: ${customer.name} - ${network.name} ran in ${monthName} ${currentYear}`);
                                return; // Found real date, skip other methods
                            }
                        }
                    } catch (error) {
                        console.log(` Date parsing error for ${network.name}`);
                    }
                }
                
                // BACKUP: Check monthly_runs array only for valid dates
                if (customerCurrentMonthRuns === 0 && network.monthly_runs && Array.isArray(network.monthly_runs)) {
                    const monthValue = network.monthly_runs[currentMonth - 1];
                    if (monthValue && monthValue !== '-' && monthValue !== 'Never' && monthValue !== 'Not Started') {
                        // Only count if it's a real date format
                        if (typeof monthValue === 'string' && monthValue.includes('-')) {
                            customerCurrentMonthRuns += 1;
                            console.log(` ARRAY DATE: ${customer.name} has date "${monthValue}" in ${monthName}`);
                        }
                    }
                }
            });
        }
        
        // SPECIAL DEBUGGING FOR KEY CUSTOMERS
        if (customer.name === 'BSNL' || customer.name === 'Moratelindo' || customer.name === 'OPT_NC') {
            console.log(` ${customer.name} October runs: ${customerCurrentMonthRuns}`);
        }
        
        // Only include customers with current month activity
        if (customerCurrentMonthRuns > 0) {
            customerData.push({
                name: customer.name,
                runs: customerCurrentMonthRuns,
                country: customer.country || 'Unknown'
            });
        }
    });
    
    // Sort and take top 10
    customerData.sort((a, b) => b.runs - a.runs);
    const topCustomers = customerData.slice(0, 10);
    
    // Update total customers display
    if (totalCustomersElement) {
        totalCustomersElement.textContent = topCustomers.length;
    }
    
    // Render chart
    chartContainer.innerHTML = '';
    
    if (topCustomers.length === 0) {
        chartContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">
                 No customer activity for ${monthName}
            </div>
        `;
        return;
    }
    
    const maxRuns = Math.max(...topCustomers.map(c => c.runs), 1);
    
    chartContainer.style.cssText = `
        display: flex;
        align-items: flex-end;
        justify-content: space-around;
        height: 200px;
        padding: 20px 16px 40px 16px;
        background: linear-gradient(to bottom, rgba(16, 185, 129, 0.04) 0%, transparent 50%);
        border-radius: 12px;
        position: relative;
        overflow-x: auto;
    `;
    
    // Create bars for each customer
    topCustomers.forEach((customerData, index) => {
        const percentage = (customerData.runs / maxRuns) * 100;
        const barHeight = Math.max((percentage / 100) * 120, 15);
        
        const barContainer = document.createElement('div');
        barContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            max-width: 80px;
            min-width: 60px;
            position: relative;
            margin: 0 2px;
        `;
        
        const bar = document.createElement('div');
        bar.style.cssText = `
            width: 70%;
            height: ${barHeight}px;
            background: linear-gradient(135deg, #10b981 0%, #047857 100%);
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        `;
        
        // Add value label
        const valueLabel = document.createElement('div');
        valueLabel.style.cssText = `
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: 700;
            color: #047857;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
        `;
        valueLabel.textContent = customerData.runs;
        bar.appendChild(valueLabel);
        
        // Add customer name label
        const customerLabel = document.createElement('div');
        customerLabel.style.cssText = `
            margin-top: 8px;
            font-size: 0.7rem;
            font-weight: 600;
            color: #4b5563;
            text-align: center;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        `;
        customerLabel.textContent = customerData.name.length > 8 ? 
                                   customerData.name.substring(0, 8) + '...' : 
                                   customerData.name;
        customerLabel.title = `${customerData.name}: ${customerData.runs} runs (${customerData.country})`;
        
        barContainer.appendChild(bar);
        barContainer.appendChild(customerLabel);
        chartContainer.appendChild(barContainer);
    });
    
    console.log(' Customer chart updated successfully!');
}

// Manual refresh function
window.refreshChart = function() {
    console.log(' Manual chart refresh triggered...');
    updateActivityChart();
    updateCurrentMonthCustomerChart();
};

// Hook into the main refresh button to also refresh charts
const originalRefresh = window.location.reload;
if (document.querySelector('.refresh-btn')) {
    document.querySelector('.refresh-btn').addEventListener('click', function(e) {
        console.log(' Main refresh triggered - also refreshing charts...');
        setTimeout(() => {
            updateActivityChart();
            updateCurrentMonthCustomerChart();
        }, 1000);
    });
}

console.log(' Dual Chart Functions Added Successfully!');

// DEBUG: Check current customer data for October
window.debugOctoberCustomerData = function() {
    console.log(' DEBUGGING OCTOBER CUSTOMER DATA');
    console.log('='.repeat(60));
    
    if (!dashboardData || !dashboardData.customers) {
        console.error(' No dashboard data available!');
        return;
    }
    
    const currentMonth = 10; // October
    const customers = dashboardData.customers;
    
    Object.values(customers).forEach(customer => {
        if (customer.name === 'BSNL' || customer.name === 'Moratelindo' || customer.name === 'OPT_NC') {
            console.log(`\n ${customer.name}:`);
            
            let currentMonthRuns = 0;
            
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, index) => {
                    console.log(`   Network ${index}: ${network.name}`);
                    
                    // Check monthly_runs array for October (index 9)
                    if (network.monthly_runs && Array.isArray(network.monthly_runs)) {
                        const octoberValue = network.monthly_runs[currentMonth - 1]; // Index 9
                        console.log(`    monthly_runs[9] (Oct): ${octoberValue}`);
                        if (octoberValue && octoberValue !== '-' && octoberValue !== 'Never' && octoberValue !== 'Not Started') {
                            currentMonthRuns += 1;
                        }
                    } else {
                        console.log(`     No monthly_runs array`);
                    }
                    
                    // Also check months array
                    if (network.months && Array.isArray(network.months)) {
                        const octoberValue = network.months[currentMonth - 1];
                        console.log(`    months[9] (Oct): ${octoberValue}`);
                        if (octoberValue && octoberValue !== '-' && octoberValue !== 'Never' && octoberValue !== 'Not Started') {
                            currentMonthRuns += 1;
                        }
                    } else {
                        console.log(`     No months array`);
                    }
                });
            }
            
            console.log(`   Total October runs for ${customer.name}: ${currentMonthRuns}`);
        }
    });
    
    console.log('\n Now updating charts to see if they reflect this data...');
    updateCurrentMonthCustomerChart();
};

// Manual chart debug function for browser console
window.debugCharts = function() {
    console.log(' DEBUGGING CHARTS AND DATA');
    console.log('='.repeat(50));
    
    // Debug October data
    debugOctoberCustomerData();
    
    // Show chart containers
    const activityChart = document.getElementById('activity-chart');
    const customerChart = document.getElementById('month-customer-chart');
    
    console.log(' Chart containers:');
    console.log('  Activity chart:', activityChart ? 'Found' : 'Missing');
    console.log('  Customer chart:', customerChart ? 'Found' : 'Missing');
    
    // Force refresh charts
    console.log(' Refreshing charts...');
    updateActivityChart();
    updateCurrentMonthCustomerChart();
};

// Manual total runs verification function
window.verifyTotalRuns = function() {
    console.log(' VERIFYING TOTAL RUNS CALCULATION');
    console.log('='.repeat(60));
    
    if (!dashboardData || !dashboardData.customers) {
        console.error(' No dashboard data available!');
        return;
    }
    
    let calculatedTotal = 0;
    const customers = dashboardData.customers;
    
    console.log(` Total customers in data: ${Object.keys(customers).length}`);
    
    Object.values(customers).forEach(customer => {
        // Skip Excel customers
        if (customer.excel_source || customer.excel_only || customer.excel_data) {
            console.log(` Skipping Excel customer: ${customer.name}`);
            return;
        }
        
        let customerRuns = 0;
        
        // Method 1: Count from networks array
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                const networkRuns = parseInt(network.runs || network.total_runs || 0);
                customerRuns += networkRuns;
            });
            console.log(`   ${customer.name}: ${customerRuns} runs from ${customer.networks.length} networks`);
        } else {
            // Method 2: Customer-level runs
            customerRuns = parseInt(customer.runs || customer.total_runs || customer.run_count || 0);
            console.log(`   ${customer.name}: ${customerRuns} runs (customer-level)`);
        }
        
        calculatedTotal += customerRuns;
    });
    
    // Check what's displayed in header
    const headerElement = document.getElementById('header-total-runs');
    const headerValue = headerElement ? headerElement.textContent : 'Not Found';
    
    console.log(`\n COMPARISON:`);
    console.log(`   Calculated Total: ${calculatedTotal}`);
    console.log(`   Header Shows: ${headerValue}`);
    console.log(`   Dashboard Stats: ${dashboardData.statistics?.total_runs || 'Not Set'}`);
    
    if (calculatedTotal.toString() !== headerValue) {
        console.log(` MISMATCH DETECTED!`);
        console.log(`   Fix needed in calculation logic`);
    } else {
        console.log(` Numbers match - calculation is correct`);
    }
};

// Manual function to increment runs after health check
window.incrementRunsAfterHealthCheck = function(customerName, networkName) {
    console.log(` MANUAL RUN INCREMENT: ${customerName} - ${networkName}`);
    
    if (!dashboardData || !dashboardData.customers) {
        console.error(' No dashboard data available!');
        return;
    }
    
    const currentDate = new Date().toISOString();
    updateMonthlyRunsAfterTool(customerName, networkName, currentDate);
    
    // Force immediate refresh
    setTimeout(() => {
        updateStatistics();
        updateCustomerGrid();
        updateActivityChart();
        updateCurrentMonthCustomerChart();
        
        console.log(' Dashboard refreshed after run increment');
        showNotification(` ${customerName} - ${networkName} run count updated!`, 'success');
    }, 500);
};

// Quick increment functions for common customers
window.incrementBSNL = function(zone = 'East', type = 'DWDM') {
    const networkName = `BSNL_${zone}_Zone_${type}`;
    incrementRunsAfterHealthCheck('BSNL', networkName);
};

window.incrementOPT = function() {
    incrementRunsAfterHealthCheck('OPT_NC', 'OPT_NC');
};

window.incrementMoratel = function(network = 'PSS24') {
    const networkName = `Moratelindo_${network}`;
    incrementRunsAfterHealthCheck('Moratelindo', networkName);
};

// PERMANENT TOTAL RUNS FIX - Direct in dashboard
function forceUseDatabaseTotalRuns() {
    console.log(' Forcing dashboard to use database total_runs...');
    
    if (window.dashboardData && window.dashboardData.customers) {
        // Force all customers to use database total_runs for display
        Object.values(window.dashboardData.customers).forEach(customer => {
            const dbTotalRuns = customer.total_runs || 0;
            
            // Override all run-related fields with database value
            customer.runs = dbTotalRuns;
            customer.run_count = dbTotalRuns;
            customer.total_run_count = dbTotalRuns;
            
            // Also fix networks array
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach(network => {
                    network.runs = network.total_runs || 0;
                    network.run_count = network.total_runs || 0;
                });
            }
        });
        
        // Force update display
        if (window.updateCustomerGrid) updateCustomerGrid();
        if (window.updateStatistics) updateStatistics();
        
        console.log(' Dashboard forced to use database total_runs values');
    }
}

// Auto-refresh with database values every 15 seconds
function autoRefreshDatabaseValues() {
    fetch('/api/customer-dashboard/customers/')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.customers) {
                // Check if any total_runs changed
                let hasChanges = false;
                
                if (window.dashboardData && window.dashboardData.customers) {
                    Object.entries(data.customers).forEach(([key, newCustomer]) => {
                        const oldCustomer = window.dashboardData.customers[key];
                        if (oldCustomer && oldCustomer.total_runs !== newCustomer.total_runs) {
                            console.log(` ${newCustomer.name}: ${oldCustomer.total_runs}  ${newCustomer.total_runs} runs`);
                            hasChanges = true;
                        }
                    });
                }
                
                if (hasChanges || !window.dashboardData) {
                    // Store updated data
                    window.dashboardData = data;
                    
                    // Force use database values
                    forceUseDatabaseTotalRuns();
                    
                    console.log(' Dashboard auto-updated with new database values');
                }
            }
        })
        .catch(error => {
            console.log(' Auto-refresh (background):', error.message);
        });
}

// Auto-refresh DISABLED to prevent unwanted total runs changes
// setInterval(autoRefreshDatabaseValues, 15000); // DISABLED
console.log(' Auto-refresh disabled to keep total runs stable');

// Override DISABLED to prevent automatic total runs changes
// const originalLoadData = window.loadDashboardData || function() {};
// window.loadDashboardData = function() {
//     // Call original if exists
//     if (originalLoadData && originalLoadData !== window.loadDashboardData) {
//         originalLoadData();
//     }
//     
//     // Then force database values
//     setTimeout(forceUseDatabaseTotalRuns, 1000);
// }; // DISABLED
console.log(' LoadDashboardData override disabled to prevent 196238 change');

// Auto-debug DISABLED to prevent total runs changes
// setTimeout(() => {
//     if (window.dashboardData && window.dashboardData.customers) {
//         debugOctoberCustomerData();
//         
//         // Force use database total_runs immediately
//         forceUseDatabaseTotalRuns();
//         
//         // Also auto-verify total runs
//         setTimeout(() => {
//             verifyTotalRuns();
//         }, 1000);
//     }
// }, 2000); // DISABLED
console.log(' Auto-debug disabled to keep total runs stable');

// Manual refresh function triggered by refresh button
function manualRefreshTotalRuns() {
    console.log(' Manual refresh triggered by user');
    
    // Show visual feedback
    const refreshBtn = event.target.closest('button');
    const originalText = refreshBtn.innerHTML;
    refreshBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;"><path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg> Refreshing...';
    refreshBtn.disabled = true;
    
    // Force refresh data from server
    fetch('c')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.customers) {
                // Update global data
                window.dashboardData = data;
                
                // Force use database total_runs values
                forceUseDatabaseTotalRuns();
                
                console.log(' Manual refresh completed successfully');
                
                // Success feedback
                refreshBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>  Updated!';
                
                setTimeout(() => {
                    refreshBtn.innerHTML = originalText;
                    refreshBtn.disabled = false;
                }, 2000);
            } else {
                throw new Error('Invalid response from server');
            }
        })
        .catch(error => {
            console.error(' Manual refresh failed:', error);
            
            // Error feedback
            refreshBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>  Error';
            
            setTimeout(() => {
                refreshBtn.innerHTML = originalText;
                refreshBtn.disabled = false;
            }, 3000);
        });
}

// Add spinning animation for refresh button
if (!document.querySelector('#refresh-animation-styles')) {
    const styles = document.createElement('style');
    styles.id = 'refresh-animation-styles';
    styles.textContent = `
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    `;
    document.head.appendChild(styles);
}

// ========== LIVE DB EDIT HELPER FUNCTIONS ==========

// Update only table total runs (ORIGINAL WORKING VERSION - NO HEADER UPDATES)
function updateAllDashboardComponents(editedCustomerNames = null) {
    console.log(' Updating dashboard components (table total runs only, no graphs, no header cards)...');
    
    // 1. Update customer-level total runs
    if (editedCustomerNames && editedCustomerNames.length > 0) {
        updateEditedCustomersOnly(editedCustomerNames);
    } else {
        updateCustomerTotalRuns();
    }
    
    // 2. SKIP HEADER STATISTICS - Keep static cards unchanged
    console.log(' Header cards deliberately skipped to preserve static state');
    
    // 3. Update table display for edited customers
    if (editedCustomerNames && editedCustomerNames.length > 0) {
        updateEditedCustomersInTable(editedCustomerNames);
    }
    
    // 4. SKIP CHARTS - Keep graphs unchanged during Live DB Edit
    console.log(' Charts deliberately skipped to preserve original state');
    
    console.log(' Dashboard components updated (table total runs only - everything else preserved)');
}

// Save network changes to database
function saveNetworkToDatabase(customerName, networkName, monthlyData, totalRuns) {
    console.log(` Saving to database: ${customerName} - ${networkName}, ${totalRuns} runs`);
    
    // Create payload for backend
    const payload = {
        customer_name: customerName,
        network_name: networkName,
        monthly_runs: monthlyData,
        total_runs: totalRuns,
        action: 'update_network_runs'
    };
    
    // Send to backend API (async - don't wait for response)
    fetch('/api/customer-dashboard/update-network/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log(` Database updated: ${customerName} - ${networkName}`);
        } else {
            console.log(` Database update failed: ${data.error || 'Unknown error'}`);
        }
    })
    .catch(error => {
        console.log(` Database update (background): ${error.message}`);
    });
}

// Update only edited customers (targeted update)
function updateEditedCustomersOnly(changedCustomerNames) {
    console.log(' Updating only edited customers:', changedCustomerNames);
    
    if (!dashboardData.customers || !changedCustomerNames || changedCustomerNames.length === 0) return;
    
    // Only update the specific customers that were edited
    Object.values(dashboardData.customers).forEach(customer => {
        // Skip customers that weren't edited
        if (!changedCustomerNames.includes(customer.name)) return;
        
        if (customer.networks && customer.networks.length > 0) {
            let customerTotalRuns = 0;
            
            // Sum up runs from all networks for this edited customer only
            customer.networks.forEach(network => {
                // Network runs are already updated by the incremental logic above
                // Just sum them up for customer total
                customerTotalRuns += (network.runs || network.total_runs || 0);
            });
            
            // Update customer totals (only for edited customer)
            customer.runs = customerTotalRuns;
            customer.total_runs = customerTotalRuns;
            customer.run_count = customerTotalRuns;
            customer.total_run_count = customerTotalRuns;
            
            console.log(` Updated edited customer ${customer.name}: ${customerTotalRuns} total runs`);
        }
    });
    
    console.log(` Targeted update completed for ${changedCustomerNames.length} customers`);
}

// Update only edited customers in the table (targeted table update)
function updateEditedCustomersInTable(changedCustomerNames) {
    console.log(' Updating only edited customer rows in table:', changedCustomerNames);
    
    if (!changedCustomerNames || changedCustomerNames.length === 0) return;
    
    // Find and update only the table rows for edited customers
    const tableBody = document.getElementById('customer-table-body');
    if (!tableBody) {
        console.log(' Customer table body not found');
        return;
    }
    
    // Update table rows for each edited customer
    changedCustomerNames.forEach(customerName => {
        const customer = Object.values(dashboardData.customers).find(c => c.name === customerName);
        if (!customer) return;
        
        // Find existing customer rows (customer might have multiple network rows)
        const existingRows = Array.from(tableBody.querySelectorAll('tr')).filter(row => {
            const nameCell = row.querySelector('.customer-name-main, .network-name-main');
            return nameCell && nameCell.textContent.trim().includes(customerName);
        });
        
        // Update each row for this customer
        existingRows.forEach(row => {
            // Update total runs cell
            const totalRunsCell = row.querySelector('.total-runs-cell, .total-runs');
            if (totalRunsCell) {
                const newTotalRuns = customer.total_runs || 0;
                const oldValue = parseInt(totalRunsCell.textContent) || 0;
                
                if (newTotalRuns !== oldValue) {
                    totalRunsCell.textContent = newTotalRuns;
                    
                    // Add visual feedback
                    totalRunsCell.style.backgroundColor = '#10b981';
                    totalRunsCell.style.color = 'white';
                    totalRunsCell.style.transform = 'scale(1.1)';
                    totalRunsCell.style.transition = 'all 0.3s ease';
                    
                    console.log(` Updated table row: ${customerName}: ${oldValue}  ${newTotalRuns} runs`);
                    
                    // Reset styling after animation
                    setTimeout(() => {
                        totalRunsCell.style.backgroundColor = '';
                        totalRunsCell.style.color = '';
                        totalRunsCell.style.transform = '';
                    }, 1000);
                }
            }
            
            // Update monthly columns if this is a network detail row
            if (customer.networks) {
                customer.networks.forEach(network => {
                    if (network.editedData && network.months) {
                        // Update monthly data columns (Jan-Dec)
                        for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                            const monthCell = row.children[7 + monthIndex]; // Assuming month columns start at index 7
                            if (monthCell && network.months[monthIndex]) {
                                const newValue = network.months[monthIndex];
                                if (monthCell.textContent.trim() !== newValue) {
                                    monthCell.textContent = newValue;
                                    monthCell.style.backgroundColor = '#dff0d8';
                                    setTimeout(() => {
                                        monthCell.style.backgroundColor = '';
                                    }, 2000);
                                }
                            }
                        }
                    }
                });
            }
        });
    });
    
    console.log(` Table update completed for ${changedCustomerNames.length} customer rows`);
}

// Update customer-level total runs (legacy - for full updates)
function updateCustomerTotalRuns() {
    console.log(' Recalculating customer-level total runs...');
    
    if (!dashboardData.customers) return;
    
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.networks && customer.networks.length > 0) {
            let customerTotalRuns = 0;
            
            // Sum up runs from all networks
            customer.networks.forEach(network => {
                customerTotalRuns += (network.runs || network.total_runs || 0);
            });
            
            // Update customer totals
            customer.runs = customerTotalRuns;
            customer.total_runs = customerTotalRuns;
            customer.run_count = customerTotalRuns;
            customer.total_run_count = customerTotalRuns;
            
            console.log(` Updated ${customer.name}: ${customerTotalRuns} total runs`);
        }
    });
}

// Update header statistics cards (DISABLED - KEEP STATIC CARDS UNCHANGED)
function updateHeaderStatistics() {
    console.log(' Header statistics update DISABLED (keeping all static cards unchanged during Live DB Edit)');
    
    // INTENTIONALLY DO NOTHING - Keep ALL header cards unchanged during Live DB Edit
    // This preserves the original header state completely
    
    return; // Exit early, no header updates during Live DB edit mode
}

// Update charts and graphs (ORIGINAL WORKING - DISABLED FOR LIVE DB EDIT)
function updateChartsAndGraphs(editedCustomerNames = null, editedMonths = null) {
    console.log(' Chart updates DISABLED during Live DB Edit (preserving original chart state)');
    
    // INTENTIONALLY DO NOTHING - Keep all charts unchanged during Live DB Edit
    // This preserves the original chart state and only allows total runs updates
    
    return; // Exit early, no chart updates during edit mode
}

// Update Last 6 Months Activity Graph based on monthly data
function updateLast6MonthsGraph() {
    console.log(' Updating Last 6 Months Activity Graph...');
    
    if (!dashboardData.customers) return;
    
    // Get last 6 months
    const currentDate = new Date();
    const monthlyData = {};
    
    // Initialize last 6 months with 0
    for (let i = 5; i >= 0; i--) {
        const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthKey = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0');
        const monthName = date.toLocaleDateString('en', { month: 'short' });
        const yearShort = String(date.getFullYear()).slice(-2); // Get last 2 digits (2025 -> 25)
        console.log(` Month data: ${monthName}'${yearShort}`);
        monthlyData[monthKey] = { count: 0, name: monthName, year: yearShort };
    }
    
    // Count runs by month from customer data
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.excel_source || customer.excel_only || customer.excel_data) return; // Skip Excel customers
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.months && Array.isArray(network.months)) {
                    // Check each month in the network's monthly data
                    network.months.forEach((monthValue, monthIndex) => {
                        if (monthValue && monthValue !== '-' && monthValue !== 'Not Started' && monthValue !== 'Not Run') {
                            // This month has a run - figure out which year-month it is
                            const monthKey = currentDate.getFullYear() + '-' + String(monthIndex + 1).padStart(2, '0');
                            if (monthlyData[monthKey]) {
                                monthlyData[monthKey].count++;
                                console.log(` ${customer.name}: +1 run for ${monthlyData[monthKey].name} (${monthKey})`);
                            }
                        }
                    });
                }
            });
        }
    });
    
    // Update the graph element
    const graphElement = document.getElementById('tracking-graph');
    if (graphElement) {
        let graphHTML = '';
        const maxCount = Math.max(...Object.values(monthlyData).map(d => d.count), 1);
        
        Object.values(monthlyData).forEach(data => {
            const percentage = (data.count / maxCount) * 100;
            const height = Math.max(percentage, 5); // Minimum 5% height
            
            graphHTML += `
                <div style="display: inline-block; width: 14%; text-align: center; vertical-align: bottom; margin: 0 1%;">
                    <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); 
                                height: ${height}%; 
                                border-radius: 3px 3px 0 0; 
                                margin-bottom: 2px;
                                min-height: 8px;
                                transition: height 0.3s ease;
                                position: relative;
                                animation: slideUp 0.5s ease-out;">
                        <div style="position: absolute; top: -18px; left: 50%; transform: translateX(-50%); 
                                    font-size: 0.7rem; font-weight: 600; color: #059669;">
                            ${data.count}
                        </div>
                    </div>
                    <div style="font-size: 0.65rem; color: #666; margin-top: 2px;">${data.name}'${data.year}</div>
                </div>
            `;
        });
        
        graphElement.innerHTML = graphHTML;
        
        // Add slide-up animation
        if (!document.querySelector('#graph-animation-styles')) {
            const styles = document.createElement('style');
            styles.id = 'graph-animation-styles';
            styles.textContent = `
                @keyframes slideUp {
                    from { height: 0%; opacity: 0; }
                    to { height: var(--final-height, 100%); opacity: 1; }
                }
            `;
            document.head.appendChild(styles);
        }
        
        console.log(' Last 6 Months Graph updated with monthly data');
    }
}

// Update Current Month Customer Chart (Only if current month was edited)
function updateCurrentMonthChart(editedMonths = null) {
    const currentMonth = new Date().getMonth(); // 0-11 (Oct = 9)
    const currentMonthName = new Date().toLocaleDateString('en', { month: 'long' });
    
    // Check if current month was edited
    let shouldUpdateCurrentMonthChart = false;
    
    if (editedMonths && Array.isArray(editedMonths)) {
        // Check if any of the edited months includes current month
        shouldUpdateCurrentMonthChart = editedMonths.includes(currentMonth);
    } else {
        // Default behavior - always update (for backward compatibility)
        shouldUpdateCurrentMonthChart = true;
    }
    
    if (!shouldUpdateCurrentMonthChart) {
        console.log(` Current Month Chart update SKIPPED (current month ${currentMonthName} not edited)`);
        return;
    }
    
    console.log(` Updating Current Month Customer Chart (${currentMonthName} was edited)...`);
    
    if (!dashboardData.customers) return;
    
    // Count customers active in current month
    let activeCustomersThisMonth = 0;
    
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.excel_source || customer.excel_only || customer.excel_data) return; // Skip Excel customers
        
        let customerActiveThisMonth = false;
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.months && Array.isArray(network.months)) {
                    const currentMonthValue = network.months[currentMonth];
                    if (currentMonthValue && currentMonthValue !== '-' && 
                        currentMonthValue !== 'Not Started' && currentMonthValue !== 'Not Run') {
                        customerActiveThisMonth = true;
                    }
                }
            });
        }
        
        if (customerActiveThisMonth) {
            activeCustomersThisMonth++;
        }
    });
    
    // Update chart title
    const chartTitle = document.getElementById('customer-chart-title');
    if (chartTitle) {
        chartTitle.textContent = ` Customer HealthCheck - ${currentMonthName}: ${activeCustomersThisMonth}`;
        chartTitle.style.animation = 'pulse 0.5s';
    }
    
    // Update chart element (if exists)
    const chartElement = document.getElementById('customer-month-chart');
    if (chartElement) {
        const totalCustomers = Object.values(dashboardData.customers).filter(c => 
            !c.excel_source && !c.excel_only && !c.excel_data
        ).length;
        
        const percentage = totalCustomers > 0 ? (activeCustomersThisMonth / totalCustomers) * 100 : 0;
        
        chartElement.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
                <div style="text-align: center;">
                    <div style="font-size: 1.2rem; font-weight: 700; color: #10b981;">
                        ${activeCustomersThisMonth}/${totalCustomers}
                    </div>
                    <div style="font-size: 0.65rem; color: #666; margin-top: 2px;">
                        ${percentage.toFixed(1)}% Active
                    </div>
                </div>
            </div>
        `;
    }
    
    console.log(` Current Month Chart UPDATED: ${activeCustomersThisMonth} active customers in ${currentMonthName}`);
}

// Show targeted update animation (less prominent)
function showTargetedUpdateAnimation(changedCustomerNames) {
    console.log(' Showing targeted update feedback for:', changedCustomerNames);
    
    if (!changedCustomerNames || changedCustomerNames.length === 0) return;
    
    // Create subtle success indicator
    const indicator = document.createElement('div');
    indicator.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        z-index: 10001;
        font-weight: 600;
        font-size: 0.9rem;
        animation: slideInRight 0.3s ease-out;
    `;
    
    const customerList = changedCustomerNames.length > 1 ? 
        `${changedCustomerNames[0]} +${changedCustomerNames.length - 1} more` :
        changedCustomerNames[0];
    
    indicator.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="font-size: 1.2rem;"></div>
            <div>
                <div style="font-size: 0.8rem; opacity: 0.9;">Updated:</div>
                <div>${customerList}</div>
            </div>
        </div>
    `;
    
    // Add slide-in animation
    if (!document.querySelector('#targeted-animation-styles')) {
        const styles = document.createElement('style');
        styles.id = 'targeted-animation-styles';
        styles.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(styles);
    }
    
    document.body.appendChild(indicator);
    
    // Remove after 2.5 seconds
    setTimeout(() => {
        indicator.style.animation = 'slideOutRight 0.3s ease-out';
        setTimeout(() => {
            indicator.remove();
        }, 300);
    }, 2500);
}

// Show visual feedback animation
function showUpdateAnimation() {
    console.log(' Showing update animation...');
    
    // Create success indicator
    const indicator = document.createElement('div');
    indicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 20px 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
        z-index: 10001;
        font-weight: 700;
        font-size: 1.1rem;
        animation: popIn 0.5s ease-out;
    `;
    indicator.innerHTML = `
        <div style="text-align: center;">
            <div style="font-size: 2rem; margin-bottom: 8px;"></div>
            <div>Dashboard Updated!</div>
            <div style="font-size: 0.8rem; opacity: 0.9; margin-top: 4px;">Total runs & graphs refreshed</div>
        </div>
    `;
    
    // Add animation styles
    if (!document.querySelector('#update-animation-styles')) {
        const styles = document.createElement('style');
        styles.id = 'update-animation-styles';
        styles.textContent = `
            @keyframes popIn {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                80% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                to { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            }
        `;
        document.head.appendChild(styles);
    }
    
    document.body.appendChild(indicator);
    
    // Remove after 3 seconds
    setTimeout(() => {
        indicator.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
            indicator.remove();
        }, 300);
    }, 2500);
    
    // Also add pulse animation to table cells that were updated
    setTimeout(() => {
        const totalRunsCells = document.querySelectorAll('.total-runs');
        totalRunsCells.forEach(cell => {
            cell.style.animation = 'pulse 0.5s';
            setTimeout(() => cell.style.animation = '', 500);
        });
    }, 100);
}

console.log(' Live DB Edit Helper Functions loaded');

</script>

<!-- PERMANENT TOTAL RUNS FIX -->
<script src="/static/js/fix_total_runs_permanent.js"></script>

<!-- TABLE REAL-TIME UPDATE FIX -->
<script src="/static/js/table_total_runs_realtime_fix.js"></script>

{% endblock %}
 
