



{% extends 'base.html' %}

{% block title %}Customer Dashboard - Health Check Overview{% endblock %}

{% block extra_head %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
    body {
        background: #f8fafc;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        color: #1e293b;
        line-height: 1.6;
    }
    
    .dashboard-container {
        min-height: 100vh;
        padding: 4px;
        max-width: 1400px;
        margin: 0 auto;
        background: transparent;
    }
    
    /* HEADER - COMPACT */
    .dashboard-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 6px;
        padding: 4px 8px;
        margin-bottom: 1px;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.06), 0 2px 6px rgba(0, 0, 0, 0.03);
        border: 1px solid rgba(59, 130, 246, 0.2);
        position: relative;
        backdrop-filter: blur(20px);
    }
    
    .dashboard-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        border-radius: 12px 12px 0 0;
        opacity: 0.9;
    }
    
    @keyframes shimmer {
        0% { background-position: -200% 0; }
        100% { background-position: 200% 0; }
    }
    
    .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .header-title h1 {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        line-height: 1.1;
        letter-spacing: -0.025em;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .header-subtitle {
        color: #64748b;
        font-size: 0.7rem;
        margin-top: 2px;
        font-weight: 400;
    }
    
    .live-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .live-dot {
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    .header-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }
    
    .refresh-btn, .export-btn, .back-btn {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.65rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        text-decoration: none;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(8px);
        text-transform: uppercase;
        letter-spacing: 0.02em;
        min-height: 24px;
        white-space: nowrap;
    }
    
    .refresh-btn {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(59, 130, 246, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .refresh-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(37, 99, 235, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .export-btn {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(16, 185, 129, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .export-btn:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4), 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    
    .refresh-btn:active, .export-btn:active, .back-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .refresh-btn:active {
        box-shadow: 0 1px 3px rgba(59, 130, 246, 0.4);
    }
    
    .export-btn:active {
        box-shadow: 0 1px 3px rgba(16, 185, 129, 0.4);
    }
    
    .back-btn:active {
        box-shadow: 0 1px 3px rgba(107, 114, 128, 0.4);
    }
    
    .back-btn {
        background: rgba(248, 250, 252, 0.9);
        color: #475569;
        box-shadow: 0 2px 8px rgba(107, 114, 128, 0.15), 0 1px 3px rgba(0, 0, 0, 0.06);
        border: 1px solid #e2e8f0;
    }
    
    .back-btn:hover {
        background: rgba(241, 245, 249, 0.95);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(107, 114, 128, 0.2), 0 2px 6px rgba(0, 0, 0, 0.08);
        text-decoration: none;
        color: #334155;
    }
    
    /* HEADER STATS CARDS - COMPACT */
    .header-stats-grid {
        display: flex;
        gap: 6px;
        align-items: center;
        margin-right: 8px;
    }
    
    .header-stat-card {
        display: flex;
        align-items: center;
        gap: 3px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid rgba(59, 130, 246, 0.15);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.04), 0 1px 4px rgba(0, 0, 0, 0.02);
        min-width: 70px;
        min-height: 24px;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
    }
    
    .header-stat-icon {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        flex-shrink: 0;
    }
    
    .header-stat-info {
        display: flex;
        flex-direction: column;
        gap: 0;
    }
    
    .header-stat-title {
        font-size: 0.55rem;
        color: #6b7280;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        line-height: 1;
    }
    
    .header-stat-value {
        font-size: 0.75rem;
        font-weight: 700;
        color: #1f2937;
        line-height: 1;
    }
    
    .header-stat-card:hover {
        transform: translateY(-2px);
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08), 0 4px 12px rgba(0, 0, 0, 0.06);
        border-color: rgba(59, 130, 246, 0.25);
    }
    
    .header-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    /* DATE FILTER SECTION */
    .filter-section {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 2px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .filter-content {
        display: flex;
        align-items: end;
        gap: 1px;
        flex: 1;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .filter-label {
        font-size: 0.9rem;
        font-weight: 600;
        color: #374151;
    }

    .filter-input {
        padding: 8px 12px;
        border: 2px solid #e5e7eb;
        border-radius: 6px;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        min-width: 130px;
    }

    .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }

    .filter-btn {
        padding: 8px 16px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.55rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        align-self: end;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        min-width: 80px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
    }

    .filter-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4), 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .filter-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(59, 130, 246, 0.3);
    }
    
    /* STATS FLEXBOX - More Responsive */
    .stats-grid {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        gap: 6px;
        margin-bottom: 2px;
        width: 100%;
        flex-wrap: wrap;
    }
    
    .stat-card {
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(20px);
        border-radius: 12px;
        padding: 20px 16px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        flex: 1;
        min-width: 200px;
        max-width: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 25px;
    }
    
    .stat-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.18), 0 4px 16px rgba(0, 0, 0, 0.08);
    }
    
    .stat-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
    }
    
    .stat-card:hover::before {
        left: 100%;
    }
    
    .stat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    
    .stat-icon {
        width: 14px;
        height: 14px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
    }
    
    .stat-title {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 600;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .stat-value {
        font-size: 2rem;
        font-weight: 800;
        color: #1f2937;
        margin: 8px 0;
        line-height: 1;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        position: relative;
        z-index: 1;
    }
    
    .stat-change {
        font-size: 0.8rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 4px;
    }
    
    .stat-change.positive {
        color: #10b981;
    }
    
    .stat-change.neutral {
        color: #6b7280;
    }
    
    /* Circular Progress Indicators */
    .stat-visual {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 16px 0;
        position: relative;
    }
    
    .circular-progress {
        position: relative;
        width: 12px;
        height: 12px;
    }
    
    .circular-progress svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }
    
    .progress-bg {
        fill: none;
        stroke: rgba(0, 0, 0, 0.1);
        stroke-width: 1.5;
    }
    
    .progress-fill {
        fill: none;
        stroke-width: 1.5;
        stroke-linecap: round;
        transition: stroke-dasharray 1.5s ease-in-out;
    }
    
    .progress-customers {
        stroke: url(#gradient-customers);
    }
    
    .progress-runs {
        stroke: url(#gradient-runs);
    }
    
    .progress-trackers {
        stroke: url(#gradient-trackers);
    }
    
    .progress-value {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.95rem;
        font-weight: 700;
        color: #1f2937;
    }
    
    /* Animated dots decoration */
    .stat-decoration {
        position: absolute;
        top: 0;
        right: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
    }
    
    .floating-dots {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        opacity: 0.3;
        animation: floatDots 3s ease-in-out infinite;
    }
    
    .dot-1 {
        top: 20%;
        right: 15%;
        background: #cbd5e1;
        animation-delay: 0s;
    }
    
    .dot-2 {
        top: 60%;
        right: 25%;
        background: #10b981;
        animation-delay: 0.5s;
    }
    
    .dot-3 {
        top: 40%;
        right: 8%;
        background: #f59e0b;
        animation-delay: 1s;
    }
    
    @keyframes floatDots {
        0%, 100% {
            transform: translateY(0px) scale(1);
            opacity: 0.3;
        }
        50% {
            transform: translateY(-8px) scale(1.2);
            opacity: 0.6;
        }
    }
    
    /* Professional stat card layout */
    .stat-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .stat-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .stat-info {
        flex: 1;
    }
    
    /* PROFESSIONAL TRACKING GRAPH */
    .tracking-graph-container {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
        backdrop-filter: blur(24px);
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 1px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.4);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    .tracking-graph-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #e2e8f0 0%, #cbd5e1 50%, #f1f5f9 100%);
        border-radius: 16px 16px 0 0;
        opacity: 0.8;
    }
    
    .tracking-graph-container:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.12), 
                    0 8px 16px rgba(0, 0, 0, 0.07);
    }
    
    .tracking-graph-title {
        font-size: 1.4rem;
        font-weight: 800;
        background: linear-gradient(135deg, #1e293b 0%, #64748b 60%, #94a3b8 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 20px 0;
        letter-spacing: -0.01em;
        line-height: 1.2;
        position: relative;
        z-index: 1;
    }
    
    .tracking-graph {
        display: flex;
        align-items: end;
        gap: 1px;
        height: 45px;
        padding: 4px 8px;
        background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
        border-radius: 6px;
        position: relative;
        z-index: 1;
        overflow-x: auto;
        overflow-y: hidden;
    }
    
    /* Dynamic sizing for tracking graphs based on content */
    .tracking-graph-container.dynamic {
        min-width: 400px;
        flex: none;
    }
    
    .tracking-graph-container.compact {
        min-width: 300px;
        max-width: 600px;
    }
    
    .tracking-graph-container.expanded {
        min-width: 800px;
        max-width: none;
    }
    
    .tracking-graph::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
    }
    
    .graph-bar {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 70px;
        position: relative;
    }
    
    .bar {
        width: 50%;
        background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        border-radius: 8px 8px 4px 4px;
        min-height: 6px;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        box-shadow: 0 4px 12px rgba(203, 213, 225, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
        cursor: pointer;
    }
    
    .bar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.3) 100%);
        border-radius: 8px 8px 0 0;
    }
    
    .bar:hover {
        background: linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%);
        transform: translateY(-4px) scaleY(1.08) scaleX(1.1);
        box-shadow: 0 8px 20px rgba(148, 163, 184, 0.4),
                    0 4px 8px rgba(148, 163, 184, 0.2);
    }
    
    .bar-value {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.8rem;
        font-weight: 700;
        color: #1e293b;
        opacity: 0;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .bar:hover .bar-value {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
    }
    
    .month-label {
        margin-top: 12px;
        font-size: 0.8rem;
        color: #64748b;
        font-weight: 600;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        transition: color 0.3s ease;
    }
    
    .graph-bar:hover .month-label {
        color: #4f46e5;
        font-weight: 700;
    }
    
    /* PROFESSIONAL CHART LOADING */
    .tracking-graph .loading {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        color: #64748b;
        font-weight: 500;
    }
    
    .tracking-graph .spinner {
        width: 32px;
        height: 32px;
        border: 3px solid rgba(203, 213, 225, 0.1);
        border-radius: 50%;
        border-top: 3px solid #cbd5e1;
        border-right: 3px solid #94a3b8;
        animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
        box-shadow: 0 0 20px rgba(203, 213, 225, 0.3);
    }
    
    /* PROFESSIONAL CHART ANIMATIONS */
    @keyframes chartSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .tracking-graph-container {
        animation: chartSlideUp 0.8s ease-out;
    }
    
    .bar {
        animation: chartSlideUp 0.6s ease-out;
        animation-fill-mode: both;
    }
    
    .graph-bar:nth-child(1) .bar { animation-delay: 0.1s; }
    .graph-bar:nth-child(2) .bar { animation-delay: 0.2s; }
    .graph-bar:nth-child(3) .bar { animation-delay: 0.3s; }
    .graph-bar:nth-child(4) .bar { animation-delay: 0.4s; }
    .graph-bar:nth-child(5) .bar { animation-delay: 0.5s; }
    .graph-bar:nth-child(6) .bar { animation-delay: 0.6s; }
    
    /* CUSTOMER OVERVIEW */
    .customer-section {
        margin-top: 2px;
        margin-bottom: 2px;
    }
    
    .section-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 6px 6px 0 0;
        padding: 3px 8px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-bottom: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        overflow: hidden;
        flex-wrap: wrap;
        gap: 6px;
    }
    
    .section-header-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    .customer-filter-section {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 6px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        backdrop-filter: blur(20px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.04);
    }
    
    .customer-filter-section .filter-group {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        margin: 0;
    }
    
    .customer-filter-section .filter-label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #6b7280;
        margin: 0;
        white-space: nowrap;
        min-width: auto;
    }
    
    .customer-filter-section .filter-input {
        padding: 4px 8px;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        font-size: 0.8rem;
        min-width: 110px;
        max-width: 130px;
        transition: all 0.2s ease;
    }
    
    .customer-filter-section .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .filter-divider {
        width: 1px;
        height: 20px;
        background: rgba(0, 0, 0, 0.1);
        margin: 0 4px;
    }
    
    .customer-filter-section .filter-btn,
    .customer-filter-section .download-btn {
        padding: 5px 8px;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.6rem;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        white-space: nowrap;
        min-width: 55px;
    }
    
    .customer-filter-section .filter-btn {
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: white;
        box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3), 0 1px 4px rgba(59, 130, 246, 0.2);
    }
    
    .customer-filter-section .download-btn {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        color: white;
        box-shadow: 0 1px 4px rgba(5, 150, 105, 0.3);
    }
    
    .customer-filter-section .filter-btn:hover {
        background: linear-gradient(135deg, #1d4ed8, #2563eb);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.25), 0 3px 10px rgba(59, 130, 246, 0.15);
    }
    
    .customer-filter-section .download-btn:hover {
        background: linear-gradient(135deg, #047857 0%, #065f46 100%);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4);
    }
    
    .customer-filter-section .filter-btn:active,
    .customer-filter-section .download-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .section-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        opacity: 0.8;
    }
    
    .section-title {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .customer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 0;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 16px 16px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
        max-height: 600px;
        overflow-y: auto;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08);
    }
    
    .customer-card {
        padding: 20px;
        border-right: 1px solid rgba(0, 0, 0, 0.05);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        transition: background-color 0.3s ease;
    }
    
    .customer-card:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 4px solid #3b82f6;
        transform: translateX(4px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.08);
    }
    
    .customer-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 12px;
    }
    
    .customer-stats {
        margin-bottom: 16px;
    }
    
    .stats-header {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 12px;
    }
    
    .customer-stat {
        text-align: center;
        padding: 8px;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(96, 165, 250, 0.05));
        border-radius: 8px;
        border: 1px solid rgba(59, 130, 246, 0.1);
    }
    
    .customer-stat-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: #1e40af;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .customer-stat-label {
        font-size: 0.7rem;
        color: #6b7280;
        text-transform: uppercase;
        font-weight: 600;
    }
    
    /* TABLE CONTAINER - Light & Compact */
    .table-container {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 8px 8px;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.06), 0 2px 8px rgba(0, 0, 0, 0.04);
        overflow: hidden;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
    }
    
    /* CUSTOMER TABLE */
    .customer-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.875rem;
    }
    
    .customer-table thead {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(96, 165, 250, 0.05) 100%);
        color: #1e40af;
        position: relative;
        font-weight: 600;
    }
    
    .customer-table thead::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.4), transparent);
    }
    
    .customer-table th {
        padding: 4px 6px;
        text-align: left;
        font-weight: 600;
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .customer-table td {
        padding: 3px 6px;
        border-bottom: 1px solid #e5e7eb;
        vertical-align: middle;
        font-size: 0.7rem;
        line-height: 1.2;
    }
    
    .customer-table tbody tr:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 3px solid #3b82f6;
        transform: translateX(2px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .customer-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    /* TABLE COLUMN STYLES - COMPACT */
    .customer-col {
        width: 160px;
        min-width: 120px;
    }
    
    .networks-col {
        width: 180px;
        min-width: 140px;
        max-width: 200px;
    }
    
    .info-col {
        width: 60px;
        text-align: center;
        font-size: 0.65rem;
        font-weight: 500;
        padding: 2px 4px;
    }
    
    .month-col {
        width: 45px;
        text-align: center;
        font-size: 0.6rem;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        color: #374151 !important;
        padding: 2px 3px;
    }
    
    .total-col {
        width: 70px;
        text-align: center;
        font-weight: 600;
        background-color: rgba(16, 185, 129, 0.05);
        font-size: 0.7rem;
        padding: 2px 4px;
    }
    
    /* CUSTOMER NAME CELL - COMPACT */
    .customer-name-cell {
        font-weight: 600;
        color: #1f2937;
        font-size: 0.75rem;
        padding: 2px;
        max-width: 180px;
    }
    
    .customer-name-container {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    
    .customer-name-main {
        font-weight: 700;
        color: #1f2937;
        font-size: 0.75rem;
        line-height: 1.1;
    }
    
    .customer-last-run {
        font-size: 0.6rem;
        color: #6b7280;
        font-weight: 500;
        line-height: 1;
    }
    
    /* NETWORKS CELL - COMPACT */
    .networks-cell {
        font-size: 0.65rem;
        color: #6b7280;
        line-height: 1.2;
        max-width: 180px;
        padding: 2px 6px;
    }
    
    .networks-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .networks-header {
        display: flex;
        align-items: center;
        margin-bottom: 2px;
    }
    
    .network-count-badge {
        background: #f3f4f6;
        color: #374151;
        padding: 1px 6px;
        border-radius: 8px;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        line-height: 1;
    }
    
    .networks-list {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    
    .network-item-row {
        display: flex;
        align-items: center;
    }
    
    .network-tag {
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        background: #e0e7ff;
        color: #3730a3;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.6rem;
        font-weight: 500;
        border: 1px solid #c7d2fe;
        min-width: 0;
        max-width: 160px;
        gap: 4px;
        line-height: 1;
    }
    
    .network-name {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        min-width: 0;
    }
    
    .network-runs-count {
        background: #3730a3;
        color: white;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.55rem;
        font-weight: 600;
        min-width: 14px;
        text-align: center;
        flex-shrink: 0;
        line-height: 1;
    }
    
    .no-networks {
        color: #9ca3af;
        font-style: italic;
        font-size: 0.7rem;
    }
    
    /* CUSTOMER SUMMARY ROWS */
    .customer-summary-row {
        background-color: #f8fafc;
        border-left: 4px solid #3b82f6;
        font-weight: 600;
    }
    
    .customer-summary-row:hover {
        background-color: #f1f5f9;
    }
    
    .customer-summary .customer-name-main {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
    }
    
    .network-count-badge-large {
        background: #3b82f6;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .customer-summary .run-count {
        font-weight: 700;
        background-color: rgba(59, 130, 246, 0.1);
    }
    
    .customer-summary .total-runs-cell {
        background-color: rgba(59, 130, 246, 0.2);
        font-weight: 800;
        color: #1e40af;
    }
    
    /* NETWORK DETAIL ROWS */
    .network-detail-row {
        background-color: #ffffff;
        border-left: 2px solid #e5e7eb;
    }
    
    .network-detail-row:hover {
        background-color: #f9fafb;
    }
    
    .network-detail .network-name-main {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 500;
        padding-left: 8px;
    }
    
    .network-type {
        font-size: 0.65rem;
        color: #9ca3af;
        font-weight: 400;
        padding-left: 16px;
        font-style: italic;
    }
    
    .network-runs-badge {
        background: #10b981;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65rem;
        font-weight: 600;
    }
    
    .network-detail .run-count {
        font-size: 0.8rem;
        color: #6b7280;
    }
    
    .network-detail .total-runs-cell {
        background-color: rgba(16, 185, 129, 0.1);
        color: #059669;
        font-weight: 600;
    }
    
    /* MONTH RUN COUNTS */
    .run-count {
        text-align: center;
        font-weight: 600;
        color: #059669;
    }
    
    .run-count.zero {
        color: #9ca3af;
    }
    
    .run-count.high {
        color: #dc2626;
        background-color: rgba(220, 38, 38, 0.1);
        border-radius: 4px;
        padding: 2px 4px;
    }
    
    /* TOTAL RUNS CELL */
    .total-runs-cell {
        text-align: center;
        font-weight: 700;
        font-size: 1rem;
        color: #10b981;
        background-color: rgba(16, 185, 129, 0.1);
    }
    
    .customer-networks {
        margin-top: 8px;
    }
    
    .network-badge {
        display: inline-block;
        background: #e5e7eb;
        color: #374151;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        margin: 2px;
    }
    
    .last-run {
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 8px;
    }
    
    /* CHARTS */
    .chart-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        margin-bottom: 30px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .chart-title {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 20px;
        text-align: center;
    }
    
    /* EXCEL EXPORT MODAL */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
    }
    
    .modal-content {
        background: white;
        margin: 5% auto;
        padding: 30px;
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        position: relative;
        box-shadow: 0 20px 80px rgba(0, 0, 0, 0.2);
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .modal-title {
        font-size: 1.4rem;
        font-weight: 700;
        color: #1f2937;
        margin: 0;
    }
    
    .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    
    .close:hover {
        background: #f3f4f6;
        color: #374151;
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #374151;
        font-size: 0.9rem;
    }
    
    .form-input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.3s ease;
    }
    
    .form-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .form-checkbox {
        margin-right: 8px;
    }
    
    .export-options {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
    }
    
    .export-option {
        display: flex;
        align-items: center;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .export-option:hover {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.05);
    }
    
    .export-option.selected {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.1);
    }
    
    .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 24px;
    }
    
    .btn-cancel, .btn-export {
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: all 0.3s ease;
    }
    
    .btn-cancel {
        background: #6b7280;
        color: white;
    }
    
    .btn-cancel:hover {
        background: #4b5563;
    }
    
    .btn-export {
        background: #10b981;
        color: white;
    }
    
    .btn-export:hover {
        background: #059669;
    }
    
    /* LOADING STATES */
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    
    .spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #e5e7eb;
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
    }
    
    .spinner.white {
        border: 2px solid #ffffff;
        border-top-color: transparent;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        }
    }
    
    /* RESPONSIVE */
    @media (max-width: 768px) {
        .dashboard-container {
            padding: 10px;
        }
        
        .header-content {
            flex-direction: column;
            text-align: center;
        }

        .filter-content {
            flex-direction: column;
            align-items: stretch;
        }

        .filter-group {
            width: 100%;
        }

        .filter-input {
            min-width: auto;
            width: 100%;
        }
        
        .stats-grid {
            flex-direction: column;
            justify-content: center;
            gap: 12px;
        }
        
        .stat-card {
            min-width: 100%;
            max-width: none;
            padding: 16px 12px;
        }
        
        .stat-value {
            font-size: 1.5rem;
        }
        
        .stat-icon {
            width: 28px;
            height: 28px;
            font-size: 1.2rem;
        }
        
        .charts-grid {
            grid-template-columns: 1fr;
        }
        
        .charts-row {
            flex-direction: column !important;
            gap: 16px !important;
        }
        
        .tracking-graph-container {
            min-width: auto !important;
            flex: none !important;
        }
        
        .tracking-graph-container {
            padding: 16px !important;
        }
        
        /* Dynamic sizing adjustments for mobile */
        .tracking-graph-container.expanded,
        .tracking-graph-container.dynamic {
            min-width: auto !important;
            max-width: none !important;
        }
        
        .tracking-graph {
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch;
        }
        
        .tracking-graph-title {
            font-size: 1.2rem !important;
        }
        
        .tracking-graph {
            height: 120px !important;
            padding: 12px 4px !important;
        }
        
        .table-container {
            overflow-x: auto;
        }
        
        .customer-table {
            min-width: 700px;
        }
        
        .customer-table th,
        .customer-table td {
            padding: 2px 4px;
            font-size: 0.65rem;
        }
        
        .month-col {
            width: 35px;
        }
        
        .customer-col {
            width: 130px;
            min-width: 100px;
        }
        
        .networks-col {
            width: 150px;
            min-width: 120px;
        }
        
        .info-col {
            width: 50px;
        }
        
        .modal-content {
            width: 95%;
            margin: 10% auto;
            padding: 20px;
        }
        
        .section-header-controls {
            flex-direction: column;
            gap: 16px;
            align-items: stretch;
        }
        
        .customer-filter-section {
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
            padding: 6px 8px;
        }
        
        .customer-filter-section .filter-group {
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }
        
        .customer-filter-section .filter-input {
        min-width: 140px;
            max-width: 120px;
        }
        
        .customer-filter-section .filter-btn,
        .customer-filter-section .download-btn {
            min-width: 60px;
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .filter-divider {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Add CSRF token for API calls -->
{% csrf_token %}
<div class="dashboard-container">
    <!-- DASHBOARD HEADER -->
    <div class="dashboard-header">
        <div class="header-content">
            <div class="header-title">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z" fill="url(#gradient)"/>
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#1e40af"/>
                            <stop offset="100%" style="stop-color:#3b82f6"/>
                        </linearGradient>
                    </defs>
                </svg>
                <div>
                    <h1>Customer Dashboard</h1>
                    <div class="header-subtitle">Network Health Check Management & Analytics</div>
                </div>
                <div class="live-badge">
                    <div class="live-dot"></div>
                    Live Updates
                </div>
            </div>
            
            <div class="header-controls">
                <!-- STATS CARDS IN HEADER -->
                <div class="header-stats-grid">
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white;">
                            üë•
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">CUSTOMERS</div>
                            <div class="header-stat-value" id="header-total-customers">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white;">
                            üèÉ‚Äç‚ôÇÔ∏è
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TOTAL RUNS</div>
                            <div class="header-stat-value" id="header-total-runs">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white;">
                            üìà
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TRACKERS</div>
                            <div class="header-stat-value" id="header-total-trackers">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- EXPORT AND BACK BUTTONS -->
                <div class="header-buttons">
                    <button class="export-btn" onclick="directExcelDownload()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                        </svg>
                        Export
                    </button>
                    <a href="{% url 'customer_selection' %}" class="back-btn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                        </svg>
                        Back
                    </a>
                </div>
            </div>
        </div>
    </div>

    
    <!-- CHARTS SECTION -->
    <div class="charts-row" style="
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
        margin: 0;
        justify-content: space-between;
        align-items: stretch;
    ">
        <!-- LAST 6 MONTHS TRACKING GRAPH -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 6px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" style="font-size: 0.8rem; margin: 0 0 2px 0;">üìà Last 6 Months Activity</h3>
            <div class="tracking-graph" id="tracking-graph" style="height: 45px;">
                <!-- Graph will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading tracking data...</span>
                </div>
            </div>
        </div>
        
        <!-- CUSTOMER MONTHLY BREAKDOWN CHART -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 6px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" id="customer-chart-title" style="font-size: 0.8rem; margin: 0 0 2px 0;">üë• Active Customers - Loading...</h3>
            <div class="tracking-graph" id="customer-month-chart" style="height: 45px;">
                <!-- Customer monthly chart will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading customer data...</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- CUSTOMER OVERVIEW -->
    <div class="customer-section">
        <div class="section-header">
            <h2 class="section-title">Customer Overview</h2>
           <a href="{% url 'customer_dashboard_excel_page' %}" class="filter-btn" id="nav-to-excel-btn" style="margin-left: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; font-weight: 700; text-decoration: none;" onclick="console.log('Navigation to Excel page triggered');">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 4px;">
        <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
    </svg>
    Summary
</a>
            <div class="section-header-controls">
                <!-- Date Filter Controls -->
                <div class="customer-filter-section">
                    <div class="filter-group">
                        <label class="filter-label">From</label>
                        <input type="date" id="customer-start-date" class="filter-input">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">To</label>
                        <input type="date" id="customer-end-date" class="filter-input">
                    </div>
                    <div class="filter-divider"></div>
                    <button class="filter-btn" onclick="applyCustomerFilter()">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                        </svg>
                        Filter
                    </button>
                    <button class="filter-btn" onclick="clearFilter()" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                        Clear
                    </button>
                    <button class="download-btn" onclick="downloadFilteredData()">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                        </svg>
                        Download
                    </button>
                </div>
                <div class="live-badge">
                    <div class="live-dot"></div>
                    <span id="customer-count">Loading...</span>
                </div>
                
            </div>
        </div>
        <!-- CUSTOMER TABLE -->
        <div class="table-container">
            <table class="customer-table" id="customer-table">
                <thead>
                    <tr>
                        <th class="customer-col">Customer</th>
                        <th class="info-col">Country</th>
                        <th class="networks-col">Networks</th>
                        <th class="info-col">Node Qty</th>
                        <th class="info-col">NE Type</th>
                        <th class="info-col">GTAC</th>
                        <th class="info-col" id="filter-date-header" style="background: #e3f2fd; color: #1976d2; display: none;">Filter Date Range</th>
                        <th class="month-col">Jan</th>
                        <th class="month-col">Feb</th>
                        <th class="month-col">Mar</th>
                        <th class="month-col">Apr</th>
                        <th class="month-col">May</th>
                        <th class="month-col">Jun</th>
                        <th class="month-col">Jul</th>
                        <th class="month-col">Aug</th>
                        <th class="month-col">Sep</th>
                        <th class="month-col">Oct</th>
                        <th class="month-col">Nov</th>
                        <th class="month-col">Dec</th>
                        <th class="total-col">Total Runs</th>
                    </tr>
                </thead>
                <tbody id="customer-table-body">
                    <!-- Customer rows will be populated here -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- EXCEL EXPORT MODAL - HIDDEN (NOT USED ANYMORE) -->
<div id="export-modal" class="modal" style="display: none !important;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Export to Excel</h3>
            <button class="close" onclick="closeExportModal()">&times;</button>
        </div>
        
        <form id="export-form">
            <div class="form-group">
                <label class="form-label">Date Range</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">Start Date</label>
                        <input type="date" id="start-date" class="form-input">
                    </div>
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">End Date</label>
                        <input type="date" id="end-date" class="form-input">
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label class="form-label">Export Options</label>
                <div class="export-options">
                    <div class="export-option selected" data-option="all">
                        <input type="radio" name="export-type" value="all" class="form-checkbox" checked>
                        <label>All Data</label>
                    </div>
                    <div class="export-option" data-option="customer">
                        <input type="radio" name="export-type" value="customer" class="form-checkbox">
                        <label>Customer Details</label>
                    </div>
                </div>
            </div>
        </form>
        
        <div class="modal-actions">
            <button class="btn-cancel" onclick="closeExportModal()">Cancel</button>
            <button class="btn-export" onclick="exportToExcel()">
                <span id="export-text">Export Excel</span>
                <span id="export-spinner" class="spinner white" style="display: none;"></span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
// GLOBAL VARIABLES
let dashboardData = {
    customers: {},
    statistics: {},
    filteredData: {}
};

let refreshInterval;
let currentStartDate = null;
let currentEndDate = null;
let isFilterActive = false; // Track if user has applied a date filter

// GET ACTUAL LAST RUN DATE FOR A CUSTOMER (NEW FUNCTION)
async function getActualLastRunDate(customerName, csrfToken) {
    console.log(`üìÖ Getting ACTUAL last run date for: ${customerName}`);
    
    try {
        // FIRST: Try customer monthly sessions API which might have better date data
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear(),
                include_latest_date: true
            })
        });
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(`üìÖ Monthly sessions API response for ${customerName}:`, monthlyData);
            
            if (monthlyData.latest_run_date && monthlyData.latest_run_date !== '-' && monthlyData.latest_run_date !== 'Never') {
                const actualDate = fixDateParsing(monthlyData.latest_run_date);
                if (actualDate) {
                    const formattedDate = actualDate.toISOString().split('T')[0];
                    console.log(`‚úÖ LATEST RUN from monthly API: ${customerName} -> ${formattedDate}`);
                    return formattedDate;
                }
            }
            
            // Check monthly_sessions for the most recent date
            if (monthlyData.monthly_sessions) {
                let latestDate = null;
                let latestMonth = null;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    if (sessionData.count > 0 && sessionData.date && sessionData.date !== '-') {
                        const sessionDate = fixDateParsing(sessionData.date);
                        if (sessionDate && (!latestDate || sessionDate > latestDate)) {
                            latestDate = sessionDate;
                            latestMonth = month;
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(`‚úÖ LATEST from monthly sessions: ${customerName} -> ${formattedDate} (month ${latestMonth})`);
                    return formattedDate;
                }
            }
        }
        // FIRST: Try customer sessions API to get the most recent session
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                get_latest_only: true,
                include_dates: true,
                force_real_data: true  // Force backend to return actual session data
            })
        });
        
        console.log(`üìÖ API REQUEST: customer-sessions for ${customerName}`);
        if (!sessionsResponse.ok) {
            console.log(`‚ö†Ô∏è API customer-sessions failed with status: ${sessionsResponse.status}`);
        }
        
        if (sessionsResponse.ok) {
            const data = await sessionsResponse.json();
            console.log(`üìÖ Customer sessions response for ${customerName}:`, data);
            
            if (data.latest_session && data.latest_session.created_at) {
                const lastRunDate = fixDateParsing(data.latest_session.created_at);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from ${data.latest_session.created_at})`);
                    return formattedDate;
                }
            }
            
            // Try sessions array if latest_session not available
            if (data.sessions && Array.isArray(data.sessions) && data.sessions.length > 0) {
                // Get the most recent session (sessions should be sorted by date)
                const latestSession = data.sessions[0];
                const lastRunDate = fixDateParsing(latestSession.created_at || latestSession.date || latestSession.timestamp);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0];
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from sessions array)`);
                    return formattedDate;
                }
            }
        }
        
        // SECOND: Try to get from customer dashboard API
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const customerData = await customerResponse.json();
            if (customerData.customers && customerData.customers[customerName]) {
                const customer = customerData.customers[customerName];
                if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
                    const lastRunDate = fixDateParsing(customer.last_run_date);
                    if (lastRunDate) {
                        const formattedDate = lastRunDate.toISOString().split('T')[0];
                        console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from customer API)`);
                        return formattedDate;
                    }
                }
            }
        }
        
        // THIRD: Try to get from networks for this customer
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            if (networksData.networks && networksData.networks.length > 0) {
                let latestDate = null;
                
                // Check each network for the latest session date
                for (const network of networksData.networks) {
                    const networkResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: network.id,
                            get_latest_only: true
                        })
                    });
                    
                    if (networkResponse.ok) {
                        const networkData = await networkResponse.json();
                        if (networkData.latest_session_date) {
                            const networkDate = fixDateParsing(networkData.latest_session_date);
                            if (networkDate && (!latestDate || networkDate > latestDate)) {
                                latestDate = networkDate;
                            }
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from network sessions)`);
                    return formattedDate;
                }
            }
        }
        
        console.log(`‚ö†Ô∏è No actual last run date found for ${customerName}`);
        return null;
        
    } catch (error) {
        console.error(`‚ùå Error getting actual last run date for ${customerName}:`, error);
        return null;
    }
}

// UNIVERSAL DATE FIXING FUNCTION
function fixDateParsing(dateString) {
    if (!dateString || dateString === '-' || dateString === 'Never') {
        return null;
    }
    
    try {
        let fixedDate;
        
        // Handle different date formats
        if (dateString.includes('T')) {
            // ISO format: 2024-09-10T10:30:00Z or 2024-09-10T00:00:00
            fixedDate = new Date(dateString);
        } else if (dateString.includes('-') && dateString.length === 10) {
            // Date format: 2024-09-10 - ADD EXPLICIT TIME to avoid timezone issues
            fixedDate = new Date(dateString + 'T12:00:00');
        } else if (dateString.includes('/')) {
            // US format: 09/10/2024
            fixedDate = new Date(dateString + ' 12:00:00');
        } else {
            // Fallback
            fixedDate = new Date(dateString + ' 12:00:00');
        }
        
        // Verify the date is valid
        if (isNaN(fixedDate.getTime())) {
            console.warn(`‚ö†Ô∏è Could not parse date: ${dateString}`);
            return null;
        }
        
        console.log(`üîß DATE FIX: "${dateString}" -> ${fixedDate.toDateString()} (${fixedDate.getDate()})`);
        return fixedDate;
        
    } catch (error) {
        console.error(`‚ùå Error parsing date "${dateString}":`, error);
        return null;
    }
}

// INITIALIZE DASHBOARD
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOM loaded, initializing dashboard with REAL data only...');
    
    initializeDashboard();
    startLiveUpdates();
    setupExportModal();
    setDefaultDates();
    setDefaultFilterDates();
});

function initializeDashboard() {
    console.log('üöÄ Initializing customer dashboard...');
    showLoadingState();
    // First test what endpoints work
    testEndpoints().then(() => {
        // FILTER FIX: Only load data if no filter is currently active
        if (!isFilterActive) {
            loadDashboardData();
        } else {
            console.log('üìÖ Filter is active, skipping initial load to preserve filtered data');
            hideLoadingState();
        }
    });
}

// Test available endpoints to find what works
async function testEndpoints() {
    console.log('üìû Testing available endpoints...');
    
    const testUrls = [
        '/api/customer-dashboard/customers/',
        '/api/dashboard/statistics/',
        '/api/run-statistics/',
        '/admin/', // Just to test basic connectivity
    ];
    
    for (const url of testUrls) {
        try {
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'same-origin'
            });
            console.log(`üìû ${url} -> ${response.status} ${response.statusText}`);
        } catch (error) {
            console.log(`üìû ${url} -> Error: ${error.message}`);
        }
    }
}

function startLiveUpdates() {
    // AUTO-REFRESH COMMENTED OUT FOR NOW
    /* refreshInterval = setInterval(() => {
        console.log('üîÑ Auto-refreshing dashboard data...');
        loadDashboardData();
    }, 30000); */
    console.log('‚ö†Ô∏è Auto-refresh disabled for now');
}

// LOAD MONTHLY DATA FOR CUSTOMERS WITH DATE FILTERING - ENHANCED FOR CORRECT DATE RETRIEVAL
async function loadMonthlyDataForCustomers(customers, csrfToken, startDate = null, endDate = null) {
    const customersWithMonthly = {};
    const currentYear = new Date().getFullYear();
    
    console.log('üîç Loading monthly data for customers:', Object.keys(customers));
    console.log('üìÖ Date filter applied:', { startDate, endDate });
    
    for (const [customerName, customerData] of Object.entries(customers)) {
        console.log(`üìÖ Processing monthly data for: ${customerName}`);
        
        try {
            // STEP 1: Get the REAL last run date first for this customer
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            
            // Get network-specific run data first (with date filtering)
            const networkRuns = await fetchCustomerNetworkRuns(customerName, csrfToken, startDate, endDate);
            
            // Then get monthly data based on network runs (with date filtering)
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken, startDate, endDate);
            
            // Get network monthly data with dates for each network
            const networkMonthlyData = {};
            for (const [networkName, networkInfo] of Object.entries(networkRuns)) {
                if (networkInfo.id) {
                    try {
                        console.log(`üó∫Ô∏è Getting monthly dates for network: ${networkName}`);
                        const networkResponse = await fetch('/api/network-sessions/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken,
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify({
                                'network_id': networkInfo.id,
                                'cache_bust': Date.now(),  // Force fresh data
                                'include_last_run_date': true  // Request actual last run date
                            })
                        });
                        
                        if (networkResponse.ok) {
                            const networkData = await networkResponse.json();
                            console.log(`üîç RAW API Response for ${networkName}:`, networkData);
                            if (networkData.monthly_sessions) {
                                // Convert to the format expected by frontend
                                const formattedData = {};
                                for (const [month, sessionData] of Object.entries(networkData.monthly_sessions)) {
                                    if (sessionData.count > 0) {
                                        // ENHANCED: Use ACTUAL session dates, not defaults
                                        let correctDate = sessionData.date;
                                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                                            try {
                                                // Parse the ACTUAL date from database
                                                const parsedDate = fixDateParsing(sessionData.date);
                                                if (parsedDate) {
                                                    correctDate = parsedDate.toLocaleDateString('en-US', {
                                                        month: 'short',
                                                        day: 'numeric'
                                                    });
                                                    console.log(`‚úÖ REAL DATE: Original "${sessionData.date}" -> Parsed "${correctDate}"`);
                                                } else {
                                                    correctDate = sessionData.date; // Keep original if parsing fails
                                                }
                                            } catch (error) {
                                                console.warn(`‚ö†Ô∏è Could not parse date: ${sessionData.date}`);
                                                correctDate = sessionData.date;
                                            }
                                        } else {
                                            // NO DEFAULT DATES - only use if we have actual session data
                                            correctDate = '-';
                                            console.log(`üö´ No actual date for month ${month}, keeping as '-'`);
                                        }
                                        
                                        formattedData[parseInt(month)] = {
                                            count: sessionData.count,
                                            date: correctDate,
                                            hasData: true
                                        };
                                    }
                                }
                                networkMonthlyData[networkName] = formattedData;
                                console.log(`‚úÖ Got REAL monthly dates for ${networkName}:`, formattedData);
                            }
                        }
                    } catch (error) {
                        console.error(`‚ùå Error getting monthly data for ${networkName}:`, error);
                    }
                }
            }
            
            // ENHANCED: Copy the original customer data and add CORRECT last run date
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: monthlyData,
                network_runs: networkRuns,
                network_monthly_runs: networkMonthlyData,
                // Use ACTUAL last run date, not fallback to current date
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate  // Keep separate field for debugging
            };
            
            console.log(`‚úÖ Added data for ${customerName}:`);
            console.log(`   Monthly:`, monthlyData);
            console.log(`   Network runs:`, networkRuns);
            console.log(`   ACTUAL Last Run Date: ${actualLastRunDate}`);
            console.log(`   FINAL Last Run Date: ${customersWithMonthly[customerName].last_run_date}`);
            
        } catch (error) {
            console.error(`‚ùå Failed to load data for ${customerName}:`, error);
            
            // ENHANCED: Keep customer data but mark the integration issue
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken).catch(() => null);
            
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: {}, // Empty monthly data
                network_runs: {}, // Empty network data
                // Still try to get the actual last run date even if monthly data fails
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate,
                data_integration_error: true // Flag for debugging
            };
            
            console.log(`‚ö†Ô∏è Customer ${customerName} added with minimal data due to error. Last run: ${actualLastRunDate || 'Not found'}`);
        }
    }
    
    return customersWithMonthly;
}

// FETCH ACTUAL NETWORK-WISE RUN DATA FOR A CUSTOMER
async function fetchCustomerNetworkRuns(customerName, csrfToken) {
    try {
        console.log(`üîç Fetching ALL networks and real runs for customer: ${customerName}`);
        
        // Get all networks for this customer using correct API endpoint
        const response = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`üåê Found ${data.networks ? data.networks.length : 0} networks for ${customerName}:`, data.networks);
            
            const networkRuns = {};
            
            if (data.networks && Array.isArray(data.networks)) {
                console.log(`üîç Processing ${data.networks.length} networks for ${customerName}...`);
                
                // Get actual session counts for EACH network
                for (let i = 0; i < data.networks.length; i++) {
                    const network = data.networks[i];
                    const networkName = network.network_name || network.display_name || `${customerName} Network ${i+1}`;
                    const networkId = network.id;
                    
                    console.log(`üîç [${i+1}/${data.networks.length}] Checking network: ${networkName} (ID: ${networkId})`);
                    
                    try {
                        // Get REAL session count for this specific network
                        const realRuns = await getActualNetworkRuns(networkId, csrfToken);
                        networkRuns[networkName] = realRuns;
                        
                        if (realRuns > 0) {
                            console.log(`‚úÖ Network "${networkName}" has ${realRuns} REAL runs`);
                        } else {
                            console.log(`‚ö™ Network "${networkName}" has 0 runs`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error getting real runs for network ${networkName}:`, error);
                        networkRuns[networkName] = 0;
                    }
                    
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log(`‚úÖ Final network breakdown for ${customerName}:`, networkRuns);
                const totalRuns = Object.values(networkRuns).reduce((sum, runs) => sum + runs, 0);
                console.log(`üìà Total runs across all networks: ${totalRuns}`);
                
                return networkRuns;
            } else {
                console.log(`‚ö†Ô∏è No networks array found for ${customerName}`);
            }
        } else {
            console.error(`‚ùå Failed to fetch networks for ${customerName}. Status: ${response.status}`);
        }
    } catch (error) {
        console.error(`‚ùå Error fetching network runs for ${customerName}:`, error);
    }
    
    console.log(`‚ùå Returning empty network data for ${customerName}`);
    return {};
}

// GET ACTUAL RUN COUNT FOR A SPECIFIC NETWORK ID FROM DATABASE
async function getActualNetworkRuns(networkId, csrfToken) {
    try {
        console.log(`üî¢ Getting REAL session count for network ID: ${networkId}`);
        
        // Use the new network sessions API
        const response = await fetch('/api/network-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                network_id: parseInt(networkId)
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`‚úÖ Real session data for network ${networkId}:`, data);
            return data.total_sessions || 0;
        } else {
            console.log(`‚ùå Network sessions API failed with status: ${response.status}`);
            const errorText = await response.text();
            console.log(`Error details: ${errorText}`);
            return 0;
        }
        
    } catch (error) {
        console.error(`‚ùå Error getting real sessions for network ${networkId}:`, error);
        return 0;
    }
}

// FALLBACK: Get network runs from existing statistics
async function getNetworkRunsFromStats(networkId, csrfToken) {
    try {
        console.log(`üîÑ Fallback: Getting network ${networkId} runs from statistics`);
        
        const response = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            // Use total_runs and distribute based on network priority
            const totalRuns = data.total_runs || 0;
            
            if (totalRuns > 0) {
                // Network ID 1 gets most runs, others get proportional amounts
                if (networkId === 1) {
                    return Math.ceil(totalRuns * 0.7); // 70% to primary
                } else if (networkId === 2) {
                    return Math.ceil(totalRuns * 0.2); // 20% to secondary  
                } else if (networkId === 3) {
                    return Math.ceil(totalRuns * 0.1); // 10% to tertiary
                }
            }
        }
        
        return 0;
        
    } catch (error) {
        console.error(`‚ùå Fallback method failed:`, error);
        return 0;
    }
}

// FETCH REAL MONTHLY RUNS FROM DATABASE SESSIONS USING ACTUAL DATES WITH DATE FILTERING
async function fetchCustomerMonthlyRuns(customerName, year, csrfToken, startDate = null, endDate = null) {
    const monthlyRuns = {};
    
    // Initialize all months to 0
    for (let month = 1; month <= 12; month++) {
        monthlyRuns[month] = 0;
    }
    
    console.log(`üìÖ Getting REAL monthly session data for ${customerName} in ${year}`);
    console.log(`üìÖ Date filter: ${startDate} to ${endDate}`);
    
    try {
        // FIRST: Try to get real session dates from session history API
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                include_dates: true,
                year: year,
                start_date: startDate,
                end_date: endDate
            })
        });
        
        if (sessionsResponse.ok) {
            const sessionsData = await sessionsResponse.json();
            console.log(`üìÖ REAL session data for ${customerName}:`, sessionsData);
            
            // Process each session and count by month using REAL dates
            if (sessionsData.sessions && Array.isArray(sessionsData.sessions)) {
                console.log(`üìÖ Processing ${sessionsData.sessions.length} REAL sessions for ${customerName}`);
                
                sessionsData.sessions.forEach((session, index) => {
                    const sessionDate = new Date(session.created_at || session.date || session.timestamp);
                    const sessionYear = sessionDate.getFullYear();
                    const sessionMonth = sessionDate.getMonth() + 1;
                    
                    // ENHANCED: Only count sessions that match the filtering criteria
                    if (sessionYear === year) {
                        // Additional date filtering if startDate/endDate provided
                        let includeSession = true;
                        if (startDate || endDate) {
                            const sessionDateStr = sessionDate.toISOString().split('T')[0];
                            if (startDate && sessionDateStr < startDate) includeSession = false;
                            if (endDate && sessionDateStr > endDate) includeSession = false;
                        }
                        
                        if (includeSession) {
                            monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                            console.log(`‚úÖ REAL: Session ${index + 1} on ${sessionDate.toDateString()} -> Month ${sessionMonth} (${sessionDate.toISOString().split('T')[0]})`);
                        }
                    }
                });
                
                console.log(`‚úÖ REAL monthly distribution for ${customerName}:`, monthlyRuns);
                return monthlyRuns;
            }
        }
        
        // SECOND: Try the monthly sessions API (with date filtering) - ENHANCED
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: year,
                start_date: startDate,
                end_date: endDate,
                include_actual_dates: true,  // Request actual session dates
                format_dates: true  // Request properly formatted dates
            })
        });
        
        console.log(`üìä API REQUEST: customer-monthly-sessions for ${customerName}`);
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(`üìä REAL monthly API data for ${customerName}:`, monthlyData);
            
            if (monthlyData.monthly_sessions) {
                let hasRealData = false;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    const monthNum = parseInt(month);
                    
                    if (sessionData.count > 0) {
                        hasRealData = true;
                        
                        // Enhanced date processing
                        let processedDate = '-';
                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                            // Try to parse and format the date correctly
                            const parsedDate = fixDateParsing(sessionData.date);
                            if (parsedDate) {
                                const day = parsedDate.getDate();
                                const monthName = parsedDate.toLocaleDateString('en-US', { month: 'short' });
                                const yearShort = parsedDate.getFullYear().toString().slice(-2);
                                processedDate = `${day}-${monthName}-${yearShort}`;
                                console.log(`‚úÖ PROCESSED DATE: ${customerName} month ${month}: "${sessionData.date}" -> "${processedDate}"`);
                            } else {
                                console.log(`‚ö†Ô∏è FAILED TO PARSE: ${customerName} month ${month}: "${sessionData.date}"`);
                                processedDate = sessionData.date; // Keep original if parsing fails
                            }
                        }
                        
                        monthlyRuns[monthNum] = {
                            count: sessionData.count,
                            date: processedDate,
                            hasData: true,
                            originalDate: sessionData.date  // Keep original for debugging
                        };
                    } else {
                        monthlyRuns[monthNum] = {
                            count: 0,
                            date: '-',
                            hasData: false
                        };
                    }
                }
                
                if (hasRealData) {
                    console.log(`‚úÖ SUCCESS: Using REAL monthly API data with processed dates for ${customerName}:`, monthlyRuns);
                    return monthlyRuns;
                } else {
                    console.log(`‚ö†Ô∏è NO REAL DATA: ${customerName} monthly API returned no sessions with dates`);
                }
            } else {
                console.log(`‚ö†Ô∏è NO MONTHLY SESSIONS: ${customerName} API response has no monthly_sessions`);
            }
        } else {
            const errorText = await monthlyResponse.text();
            console.log(`‚ùå API FAILED: customer-monthly-sessions for ${customerName} - ${monthlyResponse.status}: ${errorText}`);
        }
        
        // THIRD: Get network sessions with dates as fallback
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
        
    } catch (error) {
        console.error(`‚ùå Error fetching REAL monthly runs for ${customerName}:`, error);
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
    }
    
    return monthlyRuns;
}

// FALLBACK: Get real monthly data using existing APIs with date filtering
async function fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate = null, endDate = null) {
    try {
        console.log(`üîÑ Fallback: Getting session dates for ${customerName} from database`);
        console.log(`üìÖ Fallback date filter: ${startDate} to ${endDate}`);
        
        // Try to get network IDs for this customer first
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            console.log(`üåê Found networks for ${customerName}:`, networksData);
            
            if (networksData.networks && networksData.networks.length > 0) {
                // For each network, get real sessions and their dates
                for (const network of networksData.networks) {
                    const networkId = network.id;
                    console.log(`üîç Getting real sessions for network ID: ${networkId}`);
                    
                    // Get actual sessions for this network
                    const sessionsResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: parseInt(networkId),
                            include_dates: true
                        })
                    });
                    
                    if (sessionsResponse.ok) {
                        const sessionData = await sessionsResponse.json();
                        console.log(`‚úÖ Real sessions for network ${networkId}:`, sessionData);
                        
                        // If we have session dates, use them for monthly distribution
                        if (sessionData.recent_sessions && sessionData.recent_sessions.length > 0) {
                            console.log(`üìÖ Processing ${sessionData.recent_sessions.length} real sessions...`);
                            
                            sessionData.recent_sessions.forEach(session => {
                                // Use universal date fix function
                                const sessionDate = fixDateParsing(session.created_at);
                                
                                if (sessionDate) {
                                    const sessionMonth = sessionDate.getMonth() + 1;
                                    const sessionYear = sessionDate.getFullYear();
                                    const sessionDay = sessionDate.getDate();
                                    
                                    console.log(`üìÖ SESSION: "${session.created_at}" -> Month: ${sessionMonth}, Day: ${sessionDay}, Year: ${sessionYear}`);
                                    
                                    if (sessionYear === year) {
                                        monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                                        console.log(`‚úÖ Added 1 run to month ${sessionMonth} from session on ${sessionDate.toDateString()} (Day: ${sessionDay})`);
                                    }
                                }
                            });
                        }
                    }
                }
                
                console.log(`‚úÖ Final real monthly distribution for ${customerName}:`, monthlyRuns);
                return;
            }
        }
        
        console.log(`‚ö†Ô∏è Could not get network data for ${customerName}, using basic fallback`);
        
        // ENHANCED: Only use real dates, no fallback to current month
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const data = await customerResponse.json();
            const customerData = data.customers[customerName];
            
            if (customerData && customerData.runs > 0) {
                // ONLY assign runs if we have an actual last_run_date from the API
                if (customerData.last_run_date && customerData.last_run_date !== 'Never' && customerData.last_run_date !== '-') {
                    const actualDate = fixDateParsing(customerData.last_run_date);
                    if (actualDate && actualDate.getFullYear() === year) {
                        const actualMonth = actualDate.getMonth() + 1;
                        monthlyRuns[actualMonth] = customerData.runs;
                        console.log(`‚úÖ Using REAL date from API: assigned ${customerData.runs} runs to month ${actualMonth} based on actual date ${customerData.last_run_date}`);
                    } else {
                        console.log(`‚ö†Ô∏è Customer ${customerName} has runs but date is from different year or invalid: ${customerData.last_run_date}`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Customer ${customerName} has ${customerData.runs} runs but NO valid last_run_date - not assigning to any month`);
                }
            }
        }
        
    } catch (error) {
        console.error(`‚ùå Error in real monthly data fallback:`, error);
    }
}

function setDefaultFilterDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    // Set default dates for customer overview filter (but don't apply them automatically)
    const customerStartInput = document.getElementById('customer-start-date');
    const customerEndInput = document.getElementById('customer-end-date');
    
    if (customerStartInput && customerEndInput) {
        customerEndInput.value = today.toISOString().split('T')[0];
        customerStartInput.value = firstDayOfMonth.toISOString().split('T')[0];
    }
    
    // FILTER FIX: Don't automatically set filter dates - let user apply them
    // currentStartDate = firstDayOfMonth.toISOString().split('T')[0];
    // currentEndDate = today.toISOString().split('T')[0];
}

// Duplicate function removed - using the one defined later

// Duplicate function removed - using the one defined later


// COMPLETELY REWRITTEN: Load dashboard data using same method as Excel export
async function loadDashboardData(startDate = null, endDate = null) {
    console.log('üîÑ Loading UNIFIED customer dashboard data (Database + Excel)...');
    
    // CRITICAL FIX: Use current filter dates if no parameters provided
    if (!startDate && !endDate && (currentStartDate || currentEndDate)) {
        startDate = currentStartDate;
        endDate = currentEndDate;
        console.log(`üîÑ Using existing filter dates: ${startDate} to ${endDate}`);
    }
    
    // Store current filter dates for customer overview
    if (startDate && endDate) {
        console.log(`üìÖ Applying date filter to customer data: ${startDate} to ${endDate}`);
        currentStartDate = startDate;
        currentEndDate = endDate;
    }
    
    // Check CSRF token first
    const csrfToken = getCsrfToken();
    if (!csrfToken) {
        console.error('‚ùå No CSRF token found!');
        showNotification('‚ö†Ô∏è Security error: Missing CSRF token. Please refresh the page.', 'error');
        return;
    }
    console.log('üîê CSRF token found:', csrfToken.substring(0, 10) + '...');
    
    try {
        console.log('üì° LOADING UNIFIED DATA: Database + Excel...');
        
        // STEP 1: Load UNIFIED customers (Database + Excel) from single API
        let allCustomers = {};
        
        let apiUrl = '/api/customer-dashboard/customers/';
        if (startDate || endDate) {
            const params = new URLSearchParams();
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            apiUrl += '?' + params.toString();
            console.log('üìÖ Added date filters to API URL:', apiUrl);
        }
        
        console.log('üì° LOADING UNIFIED CUSTOMERS (Database + Excel):', apiUrl);
        
        try {
            const response = await fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin'
            });
            
            if (response.ok) {
                const data = await response.json();
                console.log('üìä UNIFIED API Response:', data);
                console.log('üìä Total customers returned:', Object.keys(data.customers || {}).length);
                
                if (data.status === 'success' && data.customers) {
                    allCustomers = data.customers;
                    console.log('‚úÖ Loaded UNIFIED customers (Database + Excel):', Object.keys(allCustomers).length);
                    
                    // Log customer sources for debugging
                    Object.keys(allCustomers).forEach(customerName => {
                        const customer = allCustomers[customerName];
                        console.log(`üìä Customer: ${customerName} - Networks: ${customer.networks_count || 0}, Runs: ${customer.runs || 0}, Country: ${customer.country || 'Unknown'}`);
                    });
                } else {
                    console.log('‚ö†Ô∏è API returned no customer data');
                }
            } else {
                console.log('‚ö†Ô∏è API failed:', response.status);
            }
        } catch (apiError) {
            console.error('‚ùå API error:', apiError);
        }
        // STEP 2: Process unified customer data (already contains Database + Excel)
        console.log('üîÑ Processing unified customer data...');
        
        if (Object.keys(allCustomers).length === 0) {
            console.log('‚ö†Ô∏è No customer data loaded from API');
            showNotification('‚ö†Ô∏è No customer data available. Please check your connection.', 'warning');
            hideLoadingState();
            return;
        }
        
        // STEP 3: Process unified customer data (API already has Database + Excel combined)
        const totalCustomers = Object.keys(allCustomers).length;
        
        console.log(`üîÑ UNIFIED DATA PROCESSED:`);
        console.log(`   üåü Total customers: ${totalCustomers}`);
        
        // Calculate statistics from unified data
        let totalRuns = 0;
        let totalTrackers = 0;
        let dbCustomers = 0;
        let excelCustomers = 0;
        
        Object.values(allCustomers).forEach(customer => {
            totalRuns += parseInt(customer.runs || customer.total_runs || customer.run_count || 0);
            totalTrackers += parseInt(customer.trackers_generated || customer.total_trackers || customer.trackers || 0);
            
            // Count source types (simplified)
            if (customer.networks_count > 1) {
                dbCustomers++;
            } else {
                excelCustomers++;
            }
        });
        
        // Store unified data
        dashboardData.customers = allCustomers;
        dashboardData.statistics = {
            total_customers: totalCustomers,
            database_customers: dbCustomers,
            excel_customers: excelCustomers,
            total_runs: totalRuns,
            total_trackers: totalTrackers,
            current_month_runs: 0,
            filtered_runs: totalRuns
        };
        
        console.log('‚úÖ Unified statistics:', dashboardData.statistics);
        
        // Update all dashboard components
        updateDashboard();
        hideLoadingState();
        
        const filterMsg = startDate && endDate ? ` (filtered: ${startDate} to ${endDate})` : '';
        showNotification(`üåü Loaded ${totalCustomers} customers (Database + Excel integrated)${filterMsg}`, 'success');
        
        return;
        
    } catch (error) {
        console.error('‚ùå Unified dashboard loading error:', error);
        hideLoadingState();
        showNotification('‚ùå Failed to load unified data. Please try again.', 'error');
    }
}

// LOAD REAL DATABASE DATA

// LOAD REAL DATA DIRECTLY FROM YOUR DATABASE
async function loadRealDatabaseData() {
    console.log('üìä Loading REAL data from your database...');
    
    try {
        // Try multiple API endpoints to get your real data
        const endpoints = [
            '/api/customer-dashboard/customers/',
            '/api/dashboard/statistics/',
            '/api/run-statistics/',
            '/get-customer-networks/1/' // Try to get data from first customer
        ];
        
        // Test each endpoint
        for (const endpoint of endpoints) {
            try {
                console.log(`üìû Trying endpoint: ${endpoint}`);
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': getCsrfToken(),
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`‚úÖ Success from ${endpoint}:`, data);
                    
                    // If we got customers data, use it
                    if (data.customers) {
                        dashboardData.customers = data.customers;
                    }
                    
                    // If we got statistics, use them
                    if (data.total_customers !== undefined) {
                        dashboardData.statistics = {
                            total_customers: data.total_customers || 0,
                            total_runs: data.total_runs || 0,
                            total_trackers: data.total_trackers || 0,
                            current_month_runs: data.current_month_runs || 0,
                            filtered_runs: data.current_month_runs || 0
                        };
                    }
                } else {
                    console.log(`‚ö†Ô∏è ${endpoint} returned ${response.status}`);
                }
            } catch (endpointError) {
                console.log(`‚ùå ${endpoint} failed:`, endpointError.message);
            }
        }
        
        // If we have any data, show it
        if (Object.keys(dashboardData.customers).length > 0 || dashboardData.statistics.total_customers > 0) {
            updateDashboard();
            showNotification('‚úÖ Dashboard loaded with REAL database data!', 'success');
        } else {
            // Try one more direct approach - load page data
            await loadFromPageContext();
        }
        
    } catch (error) {
        console.error('‚ùå Real data loading failed:', error);
        await loadFromPageContext();
    }
}

// FALLBACK: Try to load data from page context - only use REAL data
async function loadFromPageContext() {
    console.log('üìä Fallback: Trying to get REAL data from any available source...');
    
    // Try direct API calls to get REAL data
    try {
        const csrfToken = getCsrfToken();
        
        // Try the statistics API first
        const statsResponse = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (statsResponse.ok) {
            const statsData = await statsResponse.json();
            console.log('‚úÖ Got REAL statistics from API:', statsData);
            
            dashboardData.statistics = {
                total_customers: statsData.total_customers || 0,
                total_runs: statsData.total_runs || 0,
                total_trackers: statsData.total_trackers || 0,
                current_month_runs: statsData.current_month_runs || 0,
                filtered_runs: statsData.current_month_runs || 0
            };
            
            updateDashboard();
            showNotification('‚úÖ Loaded REAL data from statistics API', 'success');
            return;
        }
        
        console.log('‚ö†Ô∏è Statistics API not available, showing loading state');
        
    } catch (error) {
        console.error('‚ùå Error in fallback data loading:', error);
    }
    
    // If no real data available, show loading state instead of fake data
    dashboardData.statistics = {
        total_customers: 0,
        total_runs: 0,
        total_trackers: 0,
        current_month_runs: 0,
        filtered_runs: 0
    };
    
    dashboardData.customers = {};
    
    updateDashboard();
    showNotification('‚ö†Ô∏è No real data available. Please check API endpoints and database connection.', 'warning');
}

// SHOW LOADING STATE DURING API CALLS
function showLoadingState() {
    // Show loading indicators in statistics
    const loadingHTML = '<div class="spinner"></div>';
    document.getElementById('header-total-customers').innerHTML = loadingHTML;
    document.getElementById('header-total-runs').innerHTML = loadingHTML;
    document.getElementById('header-total-trackers').innerHTML = loadingHTML;
    document.getElementById('customer-count').textContent = 'Loading data...';
    
    // Show loading messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer data...</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading tracking graph...</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer chart...</div>';
}

// HIDE LOADING STATE - STOPS LOADING SPINNERS
function hideLoadingState() {
    console.log('‚úÖ Hiding loading state');
    // Loading will be cleared when updateDashboard() is called
}

// SHOW ERROR STATE WHEN API FAILS
function showErrorState() {
    // Clear all statistics
    document.getElementById('header-total-customers').textContent = '--';
    document.getElementById('header-total-runs').textContent = '--';
    document.getElementById('header-total-trackers').textContent = '--';
    document.getElementById('customer-count').textContent = 'Unable to load data';
    
    // Show error messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to connect to database.<br><br>Please check your connection and refresh the page.</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to load tracking data.<br><br>Please refresh the page to try again.</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to load customer data.<br><br>Please refresh the page to try again.</div>';
}

// UPDATE DASHBOARD
function updateDashboard() {
    console.log('üîÑ Updating dashboard components...');
    
    updateStatistics();
    updateCustomerGrid();
    updateTrackingGraph();
    updateCustomerMonthChart();
    
    // DISABLED: checkDataIntegrationIssues() - can cause performance issues
    
    console.log('‚úÖ Customer dashboard updated successfully');
}

// NEW DEBUG FUNCTION: Inspect customer data structure
function debugCustomerData(customerName) {
    const customers = dashboardData.customers;
    const customer = customers[customerName];
    
    if (!customer) {
        console.log(`‚ùå Customer "${customerName}" not found. Available customers:`, Object.keys(customers));
        return;
    }
    
    console.log(`üîç DEBUGGING CUSTOMER: ${customerName}`);
    console.log('='.repeat(50));
    console.log(`Basic Info:`, {
        name: customer.name,
        runs: customer.runs,
        run_count: customer.run_count,
        last_run_date: customer.last_run_date,
        actual_last_run: customer.actual_last_run
    });
    
    console.log(`Monthly Runs:`, customer.monthly_runs);
    console.log(`Network Runs:`, customer.network_runs);
    console.log(`Network Monthly Runs:`, customer.network_monthly_runs);
    console.log(`Networks:`, customer.networks);
    
    // Test date retrieval for each month
    console.log('\nMonth-by-month data:');
    for (let month = 1; month <= 12; month++) {
        const monthData = getCustomerMonthRunDates(customer, new Date().getFullYear(), month);
        if (monthData.count > 0) {
            console.log(`Month ${month}: ${monthData.count} runs, date: ${monthData.date}`);
        }
    }
    console.log('='.repeat(50));
}

// NEW: Test API endpoints directly
async function testCustomerAPIs(customerName) {
    const csrfToken = getCsrfToken();
    console.log(`üî¨ TESTING APIs for: ${customerName}`);
    console.log('='.repeat(60));
    
    // Test 1: Customer monthly sessions
    try {
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear()
            })
        });
        
        if (monthlyResponse.ok) {
            const data = await monthlyResponse.json();
            console.log(`üìä customer-monthly-sessions RESPONSE:`, data);
        } else {
            console.log(`‚ùå customer-monthly-sessions FAILED: ${monthlyResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå customer-monthly-sessions ERROR:`, error);
    }
    
    // Test 2: Dashboard customers
    try {
        const customersResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customersResponse.ok) {
            const data = await customersResponse.json();
            if (data.customers && data.customers[customerName]) {
                console.log(`üìÑ dashboard/customers RESPONSE for ${customerName}:`, data.customers[customerName]);
            } else {
                console.log(`‚ö†Ô∏è dashboard/customers: Customer ${customerName} not found`);
                console.log(`Available customers:`, Object.keys(data.customers || {}));
            }
        } else {
            console.log(`‚ùå dashboard/customers FAILED: ${customersResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå dashboard/customers ERROR:`, error);
    }
    
    // Test 3: Networks for customer
    try {
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const data = await networksResponse.json();
            console.log(`üåê networks RESPONSE for ${customerName}:`, data);
        } else {
            console.log(`‚ùå networks FAILED: ${networksResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå networks ERROR:`, error);
    }
    
    console.log('='.repeat(60));
}

// NEW: Manually refresh specific customers
async function refreshCustomers(customerNames) {
    console.log(`üîÑ MANUALLY REFRESHING customers:`, customerNames);
    
    const csrfToken = getCsrfToken();
    const currentYear = new Date().getFullYear();
    
    for (const customerName of customerNames) {
        console.log(`\nüîÑ Processing: ${customerName}`);
        
        try {
            // Get actual last run date
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            console.log(`üìÖ Actual last run date for ${customerName}: ${actualLastRunDate}`);
            
            // Get monthly data
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken);
            console.log(`üìÖ Monthly data for ${customerName}:`, monthlyData);
            
            // Update customer in dashboardData
            if (dashboardData.customers[customerName]) {
                dashboardData.customers[customerName].monthly_runs = monthlyData;
                dashboardData.customers[customerName].last_run_date = actualLastRunDate || dashboardData.customers[customerName].last_run_date;
                dashboardData.customers[customerName].actual_last_run = actualLastRunDate;
                
                console.log(`‚úÖ Updated ${customerName} with fresh data`);
            }
            
        } catch (error) {
            console.error(`‚ùå Error refreshing ${customerName}:`, error);
        }
    }
    
    // Update the dashboard display
    updateCustomerGrid();
    console.log(`‚úÖ Dashboard updated with refreshed data`);
}

// NEW: Load data using exact Excel export method
async function loadDataUsingExcelMethod() {
    console.log('üì• LOADING DATA USING EXACT EXCEL EXPORT METHOD');
    const csrfToken = getCsrfToken();
    
    try {
        // Use the exact same API endpoint and parameters as exportToExcel()
        const formData = {
            start_date: currentStartDate || new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0],
            end_date: currentEndDate || new Date().toISOString().split('T')[0],
            export_type: 'all',
            current_filter_start: currentStartDate,
            current_filter_end: currentEndDate,
            format: 'json',  // Request JSON instead of Excel file
            dashboard_context: {
                current_year: new Date().getFullYear(),
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                include_run_dates: true,
                return_json: true  // Force JSON return
            }
        };
        
        console.log('üì• Excel method request:', formData);
        
        const response = await fetch('/api/customer-dashboard/export/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest',
                'Accept': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify(formData)
        });
        
        if (response.ok) {
            const contentType = response.headers.get('content-type');
            
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log('‚úÖ Excel method returned JSON data:', data);
                
                // Process and update dashboard
                if (data.customers) {
                    dashboardData.customers = data.customers;
                    dashboardData.statistics = data.statistics || {};
                    updateDashboard();
                    console.log('‚úÖ Dashboard updated with Excel method data!');
                    return true;
                }
            } else {
                console.log('‚ö†Ô∏è Excel method returned file, not JSON');
            }
        } else {
            console.log(`‚ùå Excel method API failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error('‚ùå Excel method failed:', error);
    }
    
    return false;
}

// NEW: Force reload with Excel method
async function forceReloadWithExcelMethod() {
    console.log('üîÑ FORCE RELOADING WITH EXCEL METHOD...');
    showLoadingState();
    
    const success = await loadDataUsingExcelMethod();
    
    if (!success) {
        console.log('‚ö†Ô∏è Excel method failed, falling back to enhanced method...');
        await loadDashboardData(currentStartDate, currentEndDate);
    }
    
    showNotification('‚úÖ Dashboard reloaded with Excel-compatible data', 'success');
}

// Expose debug functions to window for manual testing
window.debugCustomerData = debugCustomerData;
window.testCustomerAPIs = testCustomerAPIs;
window.refreshCustomers = refreshCustomers;
window.loadDataUsingExcelMethod = loadDataUsingExcelMethod;
window.forceReloadWithExcelMethod = forceReloadWithExcelMethod;

// NEW FUNCTION: Check for common data integration issues
function checkDataIntegrationIssues() {
    const customers = dashboardData.customers;
    let issueCount = 0;
    
    Object.values(customers).forEach(customer => {
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        const hasValidDate = customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-';
        
        if (totalRuns > 0 && !hasValidDate) {
            console.log(`‚ùå DATA INTEGRATION ISSUE: ${customer.name} has ${totalRuns} runs but no valid date`);
            issueCount++;
        }
        
        if (customer.data_integration_error) {
            console.log(`‚ùå DATA INTEGRATION ERROR: ${customer.name} had errors during data loading`);
            issueCount++;
        }
    });
    
    if (issueCount > 0) {
        console.log(`‚ö†Ô∏è SUMMARY: Found ${issueCount} data integration issues. Check console for details.`);
        showNotification(`‚ö†Ô∏è Found ${issueCount} data integration issues. Check browser console for details.`, 'warning');
    } else {
        console.log('‚úÖ No data integration issues detected.');
    }
}

// Function to animate header stats
function animateStatCard(type, targetValue, maxValue = 100) {
    const headerValue = document.getElementById(`header-total-${type}`);
    
    if (!headerValue) return;
    
    // Simple animation for header stats
    const duration = 1000; // 1 second
    const steps = 30;
    const stepTime = duration / steps;
    
    let currentStep = 0;
    
    const animate = () => {
        currentStep++;
        const progress = currentStep / steps;
        
        // Smooth ease-out
        const easedProgress = 1 - Math.pow(1 - progress, 2);
        
        // Calculate current value
        const currentValue = Math.round(targetValue * easedProgress);
        
        // Update header value
        headerValue.textContent = currentValue;
        
        // Continue animation
        if (currentStep < steps) {
            setTimeout(animate, stepTime);
        }
    };
    
    // Start animation
    animate();
}

function updateStatistics() {
    const stats = dashboardData.statistics || {};
    console.log('üìä Updating statistics with:', stats);
    
    // Animate statistics displays with circular progress
    // Use reasonable max values for progress calculation
    animateStatCard('customers', stats.total_customers || 0, Math.max(50, stats.total_customers || 0));
    animateStatCard('runs', stats.total_runs || 0, Math.max(1000, stats.total_runs || 0));
    animateStatCard('trackers', stats.total_trackers || 0, Math.max(500, stats.total_trackers || 0));
    
    console.log('üìä Statistics updated on page:', {
        customers: stats.total_customers || 0,
        runs: stats.total_runs || 0,
        trackers: stats.total_trackers || 0
    });
    
    // Update customer count with filter info
    const customerCount = Object.keys(dashboardData.customers).length;
    let customerCountText = `${customerCount} customers`;
    
    // Add filter info if dates are applied
    if (currentStartDate && currentEndDate) {
        const startDate = new Date(currentStartDate).toLocaleDateString();
        const endDate = new Date(currentEndDate).toLocaleDateString();
        customerCountText += ` (${startDate} - ${endDate})`;
    }
    
    document.getElementById('customer-count').textContent = customerCountText;
    
    console.log('üìä Dashboard updated with live data:', {
        customers: customerCount,
        runs: stats.total_runs,
        trackers: stats.total_trackers,
        filtered: currentStartDate && currentEndDate
    });
}

function updateTrackingGraph() {
    const graphContainer = document.getElementById('tracking-graph');
    const trackingContainer = graphContainer.parentElement;
    const customers = dashboardData.customers;
    
    // Get last 6 months data with real data from customers
    const currentDate = new Date();
    const monthsData = [];
    
    // Generate last 6 months
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'short' });
        const monthNumber = monthDate.getMonth() + 1;
        const year = monthDate.getFullYear();
        
        // Calculate total runs for this month from all customers
        let monthTotal = 0;
        if (customers && Object.keys(customers).length > 0) {
            Object.values(customers).forEach(customer => {
                const monthRuns = getCustomerMonthRuns(customer, year, monthNumber);
                monthTotal += monthRuns;
            });
        }
        
        // UNIVERSAL FIX: No fake data generation - monthTotal remains 0 if no actual data
        // The getCustomerMonthRuns function will handle all month validation properly
        console.log(`üìÖ Month ${monthDate.getMonth() + 1}/${monthDate.getFullYear()}: ${monthTotal} actual runs`);
        
        
        monthsData.push({
            month: monthName,
            runs: monthTotal,
            fullDate: monthDate
        });
    }
    
    const maxRuns = Math.max(...monthsData.map(m => m.runs), 1); // At least 1 to avoid division by zero
    
    graphContainer.innerHTML = '';
    
    // RENDER AS BEAUTIFUL LINE CHART for tracking-graph
    if (graphContainer.id === 'tracking-graph') {
        // Modern line chart container
        graphContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            min-height: 220px;
            padding: 16px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.02) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Calculate total and max values
        const totalRuns = monthsData.reduce((sum, month) => sum + month.runs, 0);
        const maxRuns = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Handle empty data state
        if (totalRuns === 0) {
            graphContainer.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    color: #6b7280;
                    font-weight: 600;
                ">
                    <div style="
                        width: 60px;
                        height: 60px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, #e5e7eb 0%, #f3f4f6 100%);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        margin-bottom: 12px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    ">üìà</div>
                    <div style="font-size: 0.9rem; text-align: center;">No activity data</div>
                    <div style="font-size: 0.7rem; color: #9ca3af; margin-top: 4px;">Start by uploading health checks</div>
                </div>
            `;
            return;
        }
        
        // Create professional line chart container
        graphContainer.innerHTML = '';
        graphContainer.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 140px;
            padding: 20px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Dynamic professional chart dimensions based on data points
        const baseWidth = 320;
        const dataPointWidth = Math.max(60, Math.min(120, baseWidth / monthsData.length)); // 60-120px per data point
        const chartWidth = Math.max(baseWidth, monthsData.length * dataPointWidth);
        const chartHeight = 120;
        const padding = { left: 25, right: 25, top: 25, bottom: 25 };
        const innerWidth = chartWidth - padding.left - padding.right;
        const innerHeight = chartHeight - padding.top - padding.bottom;
        
        // Apply dynamic container sizing
        if (monthsData.length <= 4) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
        } else if (monthsData.length > 8) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
        } else {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
        }
        
        // Create SVG with proper styling
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', chartHeight);
        svg.setAttribute('viewBox', `0 0 ${chartWidth} ${chartHeight}`);
        svg.style.cssText = 'overflow: visible;';
        
        // Calculate max value for proper scaling
        const maxValue = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Create professional data points with improved positioning
        const points = monthsData.map((month, i) => {
            const x = padding.left + (i / Math.max(monthsData.length - 1, 1)) * innerWidth;
            const normalizedValue = maxValue > 0 ? month.runs / maxValue : 0;
            // Use more chart area for better visualization (90% instead of 80%)
            const y = padding.top + innerHeight - (normalizedValue * innerHeight * 0.9);
            
            return {
                x: x,
                y: Math.max(y, padding.top + 10), // More top padding for labels
                runs: month.runs,
                month: month.month
            };
        });
        
        // Create smooth line path
        let pathData = `M ${points[0].x} ${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
            pathData += ` L ${points[i].x} ${points[i].y}`;
        }
        
        // Add subtle background grid
        for (let i = 0; i <= 4; i++) {
            const y = padding.top + (i / 4) * innerHeight;
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', padding.left + innerWidth);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#f3f4f6');
            gridLine.setAttribute('stroke-width', '0.5');
            if (i > 0) gridLine.setAttribute('stroke-dasharray', '2,2');
            svg.appendChild(gridLine);
        }
        
        // Create professional line with gradient
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', 'lineGradient');
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '100%');
        gradient.setAttribute('y2', '0%');
        
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#667eea');
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#764ba2');
        
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
        svg.appendChild(defs);
        
        // Draw professional line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        line.setAttribute('d', pathData);
        line.setAttribute('stroke', 'url(#lineGradient)');
        line.setAttribute('stroke-width', '2.5');
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-linejoin', 'round');
        line.style.filter = 'drop-shadow(0 1px 3px rgba(102, 126, 234, 0.3))';
        svg.appendChild(line);
        
        // Add professional data points
        points.forEach((point, i) => {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', '3');
            circle.setAttribute('fill', '#ffffff');
            circle.setAttribute('stroke', '#667eea');
            circle.setAttribute('stroke-width', '2');
            circle.style.cssText = `
                cursor: pointer;
                transition: all 0.2s ease;
                filter: drop-shadow(0 1px 2px rgba(102, 126, 234, 0.3));
            `;
            
            // Professional hover effect
            circle.addEventListener('mouseenter', () => {
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', '#667eea');
            });
            circle.addEventListener('mouseleave', () => {
                circle.setAttribute('r', '3');
                circle.setAttribute('fill', '#ffffff');
            });
            
            svg.appendChild(circle);
        });
        
        // Add enhanced professional value labels
        points.forEach((point, i) => {
            const labelText = `${point.runs} runs`;
            const textWidth = Math.max(labelText.length * 6, 40); // Better width calculation
            
            // Create professional background pill
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelBg.setAttribute('x', point.x - textWidth/2 - 3);
            labelBg.setAttribute('y', point.y - 26);
            labelBg.setAttribute('width', textWidth + 6);
            labelBg.setAttribute('height', 18);
            labelBg.setAttribute('rx', '9');
            labelBg.setAttribute('fill', 'rgba(255, 255, 255, 0.95)');
            labelBg.setAttribute('stroke', '#667eea');
            labelBg.setAttribute('stroke-width', '1.5');
            labelBg.style.cssText = `
                filter: drop-shadow(0 2px 6px rgba(102, 126, 234, 0.2));
            `;
            svg.appendChild(labelBg);
            
            // Add enhanced value text
            const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            valueText.setAttribute('x', point.x);
            valueText.setAttribute('y', point.y - 12);
            valueText.setAttribute('text-anchor', 'middle');
            valueText.setAttribute('font-size', '10');
            valueText.setAttribute('font-weight', '700');
            valueText.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            valueText.setAttribute('fill', '#667eea');
            valueText.textContent = labelText;
            svg.appendChild(valueText);
        });
        
        // Add enhanced professional month labels
        points.forEach((point, i) => {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', point.x);
            text.setAttribute('y', chartHeight - 8);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', '600');
            text.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            text.setAttribute('fill', '#4b5563');
            text.textContent = point.month;
            svg.appendChild(text);
        });
        
        // Append the complete professional chart
        graphContainer.appendChild(svg);
        
    } else {
        // RENDER AS BAR CHART (for other charts)
        monthsData.forEach(monthData => {
            const height = maxRuns > 0 ? Math.max((monthData.runs / maxRuns) * 80, 4) : 4;
            
            const graphBar = document.createElement('div');
            graphBar.className = 'graph-bar';
            
            graphBar.innerHTML = `
                <div class="bar" style="height: ${height}px;" title="${monthData.month}: ${monthData.runs} runs">
                    <div class="bar-value">${monthData.runs}</div>
                </div>
                <div class="month-label">${monthData.month}</div>
            `;
            
            graphContainer.appendChild(graphBar);
        });
    }
    
    console.log('üìä 6-month tracking graph updated:', monthsData);
}

// UPDATE CUSTOMER MONTHLY BREAKDOWN CHART
function updateCustomerMonthChart() {
    const chartContainer = document.getElementById('customer-month-chart');
    const chartContainerParent = chartContainer.parentElement;
    const customers = dashboardData.customers;
    
    // Get current month data for all customers
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    const currentMonthName = currentDate.toLocaleDateString('en-US', { month: 'long' });
    
    // Update the chart title with current month and year
    const chartTitle = document.getElementById('customer-chart-title');
    if (chartTitle) {
        chartTitle.textContent = `üë• Active Customers - ${currentMonthName} ${currentYear}`;
    }
    
    const customersData = [];
    
    if (customers && Object.keys(customers).length > 0) {
        Object.entries(customers).forEach(([customerName, customer]) => {
            const monthRuns = getCustomerMonthRuns(customer, currentYear, currentMonth);
            if (monthRuns > 0) { // Only show customers with runs this month
                customersData.push({
                    name: customerName,
                    runs: monthRuns,
                    customer: customer
                });
            }
        });
        
        // Sort by runs (highest first) and take top 10
        customersData.sort((a, b) => b.runs - a.runs);
        customersData.splice(10); // Keep only top 10
    }
    
    // Apply dynamic container sizing based on number of customers
    if (customersData.length <= 3) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
    } else if (customersData.length > 10) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
    } else {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
    }
    
    chartContainer.innerHTML = '';
    
    // Dynamic container styling based on customer count
    const dynamicGap = Math.max(4, Math.min(12, 80 / customersData.length)); // Adjust gap based on customer count
    const dynamicWidth = customersData.length > 8 ? Math.max(40, 300 / customersData.length) : 80; // Adjust bar width
    
    chartContainer.style.cssText = `
        display: flex;
        align-items: flex-end;
        justify-content: space-evenly;
        padding: 8px;
        height: 100px;
        gap: 4px;
        overflow-x: auto;
        overflow-y: hidden;
        background: rgba(248, 250, 252, 0.3);
        border-radius: 6px;
    `;
    
    if (customersData.length === 0) {
        chartContainer.innerHTML = `
            <div style="padding: 40px; text-align: center; color: #6b7280;">
                <div style="font-size: 2rem; margin-bottom: 16px;">üìà</div>
                <div style="font-weight: 600; margin-bottom: 8px;">No activity this month</div>
                <div style="font-size: 0.9rem;">Customers will appear here when they run health checks in ${currentMonthName}</div>
            </div>
        `;
        return;
    }
    
    const maxRuns = Math.max(...customersData.map(c => c.runs), 1);
    
    // Create chart bars for each customer - UNIFORM SIZING
    customersData.forEach((customerData, index) => {
        // FIXED: All bars same height, only numbers show difference
        const height = 40; // Same height for all bars
            
        const isTopPerformer = index < 3; // Top 3 get special styling
        
        const chartBar = document.createElement('div');
        chartBar.className = 'customer-chart-bar';
        chartBar.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            margin: 0 6px;
            flex: 1;
            max-width: 85px;
            min-width: 70px;
            height: 85px;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.1));
        `;
        
        // Add hover effect
        chartBar.addEventListener('mouseenter', () => {
            chartBar.style.transform = 'scale(1.08) translateY(-2px)';
            chartBar.style.filter = 'drop-shadow(0 3px 8px rgba(0,0,0,0.15))';
        });
        chartBar.addEventListener('mouseleave', () => {
            chartBar.style.transform = 'scale(1) translateY(0)';
            chartBar.style.filter = 'drop-shadow(0 1px 3px rgba(0,0,0,0.1))';
        });
        
        const barColor = isTopPerformer ? 
            (index === 0 ? '#10b981' : index === 1 ? '#3b82f6' : '#f59e0b') : 
            '#6b7280';
        
        chartBar.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-end;
                    height: 100%;
                    width: 100%;
                ">
                <div style="
                    background: ${barColor};
                    color: white;
                    font-weight: 800;
                    font-size: 0.8rem;
                    padding: 3px 8px;
                    border-radius: 6px;
                    margin-bottom: 4px;
                    min-width: 24px;
                    text-align: center;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.25);
                    border: 1px solid rgba(255,255,255,0.3);
                    position: relative;
                    z-index: 2;
                " title="${customerData.name}: ${customerData.runs} runs in ${currentMonthName}">
                    ${customerData.runs}
                </div>
                <div style="
                    width: 80%;
                    height: ${height}px;
                    background: linear-gradient(135deg, ${barColor} 0%, ${barColor}cc 50%, ${barColor}dd 100%);
                    border-radius: 6px;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                    position: relative;
                "></div>
                <div style="
                    font-size: 0.65rem;
                    font-weight: 700;
                    color: #374151;
                    text-align: center;
                    margin-top: 6px;
                    line-height: 1.1;
                    max-width: 100%;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    background: rgba(255,255,255,0.9);
                    padding: 3px 6px;
                    border-radius: 4px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    border: 1px solid rgba(0,0,0,0.05);
                " title="${customerData.name}">
                    ${customerData.name.length > 9 ? customerData.name.substring(0, 9) + '...' : customerData.name}
                </div>
                <div style="
                    font-size: 0.5rem;
                    font-weight: 500;
                    color: #6b7280;
                    text-align: center;
                    margin-top: 1px;
                ">
                    ${currentDate.toLocaleDateString('en-US', { month: 'short' })}
                </div>
            </div>
        `;
        
        chartContainer.appendChild(chartBar);
    });
    
    console.log(`üìà Customer monthly chart updated for ${currentMonthName}:`, customersData);
}

// DYNAMIC CHART RESIZE HANDLER
function handleChartResize() {
    // Debounce resize events
    clearTimeout(window.chartResizeTimeout);
    window.chartResizeTimeout = setTimeout(() => {
        console.log('üîÑ Adjusting charts for window resize...');
        
        // Update both charts with current data
        if (dashboardData && dashboardData.customers) {
            updateTrackingGraph();
            updateCustomerMonthChart();
        }
    }, 300);
}

// Add resize listener
window.addEventListener('resize', handleChartResize);

function updateCustomerGrid() {
    const tableBody = document.getElementById('customer-table-body');
    const customers = dashboardData.customers;
    
    if (!customers || Object.keys(customers).length === 0) {
        tableBody.innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;">No customer data available</td></tr>';
        return;
    }
    
    console.log('üîÑ Updating customer grid with unified data...');
    console.log('üìä Total customers to display:', Object.keys(customers).length);
    
    let rows = '';
    
    // Separate Database and Excel customers for proper grouping
    const databaseCustomers = {};
    const excelCustomers = {};
    
    Object.entries(customers).forEach(([key, customer]) => {
        if (customer.source === 'excel') {
            excelCustomers[key] = customer;
        } else {
            databaseCustomers[key] = customer;
        }
    });
    
    console.log('üíæ Database customers:', Object.keys(databaseCustomers).length);
    console.log('üìä Excel customers:', Object.keys(excelCustomers).length);
    
    // FIRST: Add Database customers using existing logic
    Object.values(databaseCustomers).forEach(customer => {
        const currentYear = new Date().getFullYear();
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // Create customer summary row for database customer
        rows += createDatabaseCustomerRow(customer, currentYear, months);
        
        // Add network rows if available
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                rows += createDatabaseNetworkRow(customer, network, networkIndex, currentYear, months);
            });
        }
    });
    
    // SECOND: Add Excel customers using proper Excel dashboard logic  
    if (Object.keys(excelCustomers).length > 0) {
        console.log('üìä Excel customers found:', Object.keys(excelCustomers).length);
        
        // FIXED: Properly use the grouped Excel data structure
        Object.values(excelCustomers).forEach((customer) => {
            console.log('üìä Processing Excel customer:', customer.name, 'with networks:', customer.networks ? customer.networks.length : 0);
            
            const currentYear = new Date().getFullYear();
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Create customer summary row for Excel customer
            rows += createExcelCustomerRow(customer, currentYear, months);
            
            // Add network rows for each network under this customer
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach((network, networkIndex) => {
                    rows += createExcelNetworkRow(customer, network, networkIndex, currentYear, months);
                });
            } else {
                console.log('‚ö†Ô∏è Excel customer has no networks:', customer.name);
            }
        });
    }
    
    tableBody.innerHTML = rows;
    console.log('‚úÖ Customer grid updated with unified data!');
}

// Helper function to create database customer row
function createDatabaseCustomerRow(customer, currentYear, months) {
    const sourceIcon = 'üíæ';
    const sourceBadge = '<span style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 1px 6px; border-radius: 8px; font-size: 0.6rem; font-weight: 600; margin-left: 6px;">DB</span>';
    
    let lastRunInfo = 'Never';
    let lastRunDateStr = customer.actual_last_run || customer.last_run_date;
    
    if (lastRunDateStr && lastRunDateStr !== 'Never' && lastRunDateStr !== '-') {
        const lastRunDate = fixDateParsing(lastRunDateStr);
        if (lastRunDate) {
            lastRunInfo = lastRunDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: '2-digit'
            });
        } else {
            lastRunInfo = lastRunDateStr;
        }
    }
    
    let monthlyHTML = '';
    let totalRuns = 0;
    months.forEach((month, index) => {
        const monthRunData = getCustomerMonthRunDates(customer, currentYear, index + 1);
        if (monthRunData) {
            totalRuns += monthRunData.count;
        }
        
        if (monthRunData && monthRunData.count > 0 && monthRunData.date && monthRunData.date !== '0' && monthRunData.date !== 'undefined') {
            monthlyHTML += `<td class="month-col" style="color: #374151;" title="${monthRunData.count} run${monthRunData.count > 1 ? 's' : ''} in ${month} - Latest: ${monthRunData.fullDate}">${monthRunData.date}</td>`;
        } else {
            monthlyHTML += `<td class="month-col" style="color: #9ca3af;" title="No runs in ${month}">-</td>`;
        }
    });
    
    return `<tr class="customer-summary-row customer-first-row">
        <td class="customer-name-cell">
            <div class="customer-name-container">
                <div class="customer-icon-name">
                    <span class="customer-icon">${sourceIcon}</span>
                    <span class="customer-name-main">${customer.name || 'Unknown Customer'}${sourceBadge}</span>
                </div>
                <div class="customer-last-run">Last run: ${lastRunInfo}</div>
            </div>
        </td>
        <td class="info-col">${customer.country || customer.location || customer.region || 'Unknown'}</td>
        <td class="networks-cell">
            <div class="network-count-badge">${customer.networks ? customer.networks.length : 0} network${(customer.networks ? customer.networks.length : 0) !== 1 ? 's' : ''}</div>
        </td>
        <td class="info-col" style="font-weight: 600;">${customer.node_count || customer.node_qty || customer.total_nodes || 0}</td>
        <td class="info-col" style="font-size: 0.7rem; color: #6b7280;">${customer.ne_type || customer.network_type || '1830 PSS'}</td>
        <td class="info-col">
            <span style="background: ${(customer.gtac || customer.gtac_type || 'PSS').toLowerCase() === 'classic' ? '#dc2626' : '#059669'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${customer.gtac || customer.gtac_type || 'PSS'}</span>
        </td>
        ${monthlyHTML}
        <td class="total-col">${customer.run_count || customer.runs || totalRuns || 0}</td>
    </tr>`;
}

// Helper function to create database network row
function createDatabaseNetworkRow(customer, network, networkIndex, currentYear, months) {
    let networkName = network.network_name || network.name || network;
    
    if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
        networkName = network.network_name;
    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
        const cleanName = networkName.split(' - ').slice(1).join(' - ');
        if (cleanName) {
            networkName = cleanName;
        }
    }
    
    const networkRuns = getNetworkRuns(customer, networkName) || 0;
    const networkNodeQty = network.node_count || network.nodes || network.total_nodes || 0;
    
    let monthlyHTML = '';
    months.forEach((month, index) => {
        const networkMonthData = getNetworkMonthRunDates(customer, networkName, currentYear, index + 1);
        
        if (networkMonthData && networkMonthData.count > 0 && networkMonthData.date && networkMonthData.date !== '0' && networkMonthData.date !== 'undefined') {
            monthlyHTML += `<td class="month-col" style="color: #374151;" title="${networkMonthData.count} run${networkMonthData.count > 1 ? 's' : ''} in ${month}">${networkMonthData.date}</td>`;
        } else {
            monthlyHTML += `<td class="month-col" style="color: #9ca3af;" title="No runs in ${month}">-</td>`;
        }
    });
    
    return `<tr class="network-detail-row customer-network-row">
        <td class="customer-name-cell">
            <div class="network-name-container">
                <div class="network-name-main">‚îî‚îÄ ${networkName}</div>
                <div class="network-type">${network.network_type || 'Default Network'}</div>
            </div>
        </td>
        <td class="info-col"></td>
        <td class="networks-cell">
            <div class="network-runs-badge">${networkRuns} runs</div>
        </td>
        <td class="info-col" style="font-weight: 600;">${networkNodeQty}</td>
        <td class="info-col" style="font-size: 0.7rem; color: #6b7280;">${network.network_type || '1830 PSS'}</td>
        <td class="info-col">
            <span style="background: ${(network.gtac || 'PSS').toLowerCase() === 'classic' ? '#dc2626' : '#059669'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${network.gtac || 'PSS'}</span>
        </td>
        ${monthlyHTML}
        <td class="total-col">${networkRuns}</td>
    </tr>`;
}

// Helper function to format Excel month data
function formatExcelMonthData(monthValue) {
    if (!monthValue || monthValue === '-') {
        return '-';
    }
    
    const valueStr = monthValue.toString();
    
    // Fix common Excel typos
    if (valueStr === 'Not Starte') {
        return 'Not Started';
    } else if (valueStr === 'No Repor') {
        return 'No Report';
    }
    
    return valueStr.replace('Not Starte', 'Not Started');
}

// Helper function to create Excel customer row
function createExcelCustomerRow(customer, currentYear, months) {
    const sourceIcon = 'üìä';
    const sourceBadge = '<span style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1px 6px; border-radius: 8px; font-size: 0.6rem; font-weight: 600; margin-left: 6px;">EXCEL</span>';
    
    // Calculate total runs from all networks
    const totalRuns = customer.runs || customer.total_runs || 0;
    const networkCount = customer.networks ? customer.networks.length : 0;
    const totalNodes = customer.node_count || customer.total_nodes || 0;
    
    // Get last run info from Excel data
    let lastRunInfo = 'Excel Data';
    if (customer.months && Array.isArray(customer.months)) {
        const validMonth = customer.months.find(m => m && m !== '-' && m !== 'Not Started' && m !== 'No Report');
        if (validMonth) {
            lastRunInfo = validMonth.includes('-') ? validMonth : 'Excel Data';
        } else {
            lastRunInfo = 'Never';
        }
    }
    
    // Create monthly HTML using customer-level data
    let monthlyHTML = '';
    months.forEach((month, index) => {
        const monthRunData = getCustomerMonthRunDates(customer, currentYear, index + 1);
        
        if (monthRunData && monthRunData.count > 0 && monthRunData.date && monthRunData.date !== '0' && monthRunData.date !== 'undefined') {
            monthlyHTML += `<td class="month-col" style="color: #374151;" title="Excel data for ${month}: ${monthRunData.date}">${monthRunData.date}</td>`;
        } else {
            monthlyHTML += `<td class="month-col" style="color: #9ca3af;" title="No data in ${month}">-</td>`;
        }
    });
    
    return `<tr class="customer-summary-row customer-first-row">
        <td class="customer-name-cell">
            <div class="customer-name-container">
                <div class="customer-icon-name">
                    <span class="customer-icon">${sourceIcon}</span>
                    <span class="customer-name-main">${customer.name || 'Unknown Customer'}${sourceBadge}</span>
                </div>
                <div class="customer-last-run">Last run: ${lastRunInfo}</div>
            </div>
        </td>
        <td class="info-col">${customer.country || 'Unknown'}</td>
        <td class="networks-cell">
            <div class="network-count-badge">${networkCount} network${networkCount !== 1 ? 's' : ''}</div>
        </td>
        <td class="info-col" style="font-weight: 600;">${totalNodes}</td>
        <td class="info-col" style="font-size: 0.7rem; color: #6b7280;">${customer.ne_type || '1830 PSS'}</td>
        <td class="info-col">
            <span style="background: #059669; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${customer.gtac || 'PSS'}</span>
        </td>
        ${monthlyHTML}
        <td class="total-col">${totalRuns}</td>
    </tr>`;
}

// Helper function to create Excel network row
function createExcelNetworkRow(customer, network, networkIndex, currentYear, months) {
    const networkName = network.network_name || network.name || network.Network || network.network || `Network ${networkIndex + 1}`;
    const networkRuns = network.runs || network.total_runs || 0;
    const networkNodes = network.node_count || network['Node Qty'] || network.node_qty || 0;
    const networkType = network.network_type || network['NE Type'] || network.ne_type || '1830 PSS';
    const networkGtac = network.gtac || network.gTAC || network.gtac || customer.gtac || 'PSS';
    
    // Create monthly HTML using network-specific data
    let monthlyHTML = '';
    if (network.months && Array.isArray(network.months)) {
        network.months.forEach((monthValue, index) => {
            const formattedValue = formatExcelMonthData(monthValue);
            if (formattedValue && formattedValue !== '-') {
                monthlyHTML += `<td class="month-col" style="color: #374151;" title="${networkName}: ${formattedValue}">${formattedValue}</td>`;
            } else {
                monthlyHTML += `<td class="month-col" style="color: #9ca3af;" title="No data">-</td>`;
            }
        });
    } else {
        // If no network-specific months data, use '-' for all months
        for (let i = 0; i < 12; i++) {
            monthlyHTML += `<td class="month-col" style="color: #9ca3af;" title="No data">-</td>`;
        }
    }
    
    return `<tr class="network-detail-row customer-network-row">
        <td class="customer-name-cell">
            <div class="network-name-container">
                <div class="network-name-main">‚îî‚îÄ ${networkName}</div>
                <div class="network-type">Excel Network</div>
            </div>
        </td>
        <td class="info-col"></td>
        <td class="networks-cell">
            <div class="network-runs-badge">${networkRuns} runs</div>
        </td>
        <td class="info-col" style="font-weight: 600;">${networkNodes}</td>
        <td class="info-col" style="font-size: 0.7rem; color: #6b7280;">${networkType}</td>
        <td class="info-col">
            <span style="background: #059669; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${networkGtac}</span>
        </td>
        ${monthlyHTML}
        <td class="total-col">${networkRuns}</td>
    </tr>`;
}

// CREATE CUSTOMER SUMMARY ROW
function createCustomerSummaryRow(customer, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'customer-summary-row';
    
    // ENHANCED: Use the ACTUAL last run date we retrieved, with multiple fallbacks
    let lastRunInfo = 'Never';
    let lastRunDateStr = customer.actual_last_run || customer.last_run_date;
    
    console.log(`üîç CUSTOMER ${customer.name} DATE DEBUG:`);
    console.log(`   actual_last_run: ${customer.actual_last_run}`);
    console.log(`   last_run_date: ${customer.last_run_date}`);
    console.log(`   Using: ${lastRunDateStr}`);
    
    if (lastRunDateStr && lastRunDateStr !== 'Never' && lastRunDateStr !== '-') {
        const lastRunDate = fixDateParsing(lastRunDateStr);
        if (lastRunDate) {
            lastRunInfo = lastRunDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: '2-digit'
            });
            console.log(`‚úÖ DISPLAYING: Customer "${customer.name}" - "${lastRunDateStr}" -> ${lastRunInfo}`);
        } else {
            console.log(`‚ùå PARSE FAILED: Customer "${customer.name}" - Could not parse "${lastRunDateStr}"`);
            lastRunInfo = lastRunDateStr; // Show original string if parsing fails
        }
    } else {
        console.log(`‚ö†Ô∏è NO DATE: Customer "${customer.name}" has no valid date information`);
        
        // Check if customer has runs but no date - this indicates missing date integration
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        if (totalRuns > 0) {
            lastRunInfo = 'Date missing'; // Clearly indicate missing date for customers with runs
            console.log(`‚ùå DATE INTEGRATION ISSUE: Customer "${customer.name}" has ${totalRuns} runs but no date!`);
        }
    }
    
    // Customer Name with Source Badge
    const customerCell = document.createElement('td');
    customerCell.className = 'customer-name-cell customer-summary';
    const sourceIcon = customer.source === 'excel' ? 'üìä' : 'üíæ';
    const sourceBadge = customer.source === 'excel' ? 
        '<span style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1px 6px; border-radius: 8px; font-size: 0.6rem; font-weight: 600; margin-left: 6px;">EXCEL</span>' : 
        '<span style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 1px 6px; border-radius: 8px; font-size: 0.6rem; font-weight: 600; margin-left: 6px;">DB</span>';
    
    customerCell.innerHTML = `
        <div class="customer-name-container">
            <div class="customer-name-main">${sourceIcon} ${customer.name || 'Unknown Customer'}${sourceBadge}</div>
            <div class="customer-last-run">Last run: ${lastRunInfo}</div>
        </div>
    `;
    row.appendChild(customerCell);
    
    // Country - Fix field mapping
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col customer-summary';
    const country = customer.country || customer.location || customer.region || 'Unknown';
    countryCell.textContent = country;
    countryCell.style.color = country === 'Unknown' ? '#9ca3af' : '#374151';
    row.appendChild(countryCell);
    
    // Networks Summary
    const networksCell = document.createElement('td');
    networksCell.className = 'networks-cell customer-summary';
    const networkCount = customer.networks ? customer.networks.length : 0;
    networksCell.innerHTML = `
        <div class="networks-summary">
            <span class="network-count-badge-large">${networkCount} network${networkCount !== 1 ? 's' : ''}</span>
        </div>
    `;
    row.appendChild(networksCell);
    
    // Node Qty - Enhanced logic to fetch from multiple sources
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col customer-summary';
    
    let nodeQty = 0;
    
    // Debug: Log available customer data fields
    console.log(`üîç DEBUG: Customer "${customer.name}" available fields:`, Object.keys(customer));
    console.log(`üîç DEBUG: Customer "${customer.name}" full data:`, customer);
    console.log(`üîç DEBUG: node_count = ${customer.node_count}, country = ${customer.country}`);
    console.log(`üîç DEBUG: runs = ${customer.runs}, networks = ${customer.networks_count}`);
    
    // Force update for testing
    if (customer.name && customer.name.toUpperCase().includes('BSNL')) {
        console.log(`üö® BSNL CUSTOMER DETECTED: ${customer.name}`);
        console.log('üö® Available fields:', Object.keys(customer));
        console.log('üö® Field values:', {
            node_count: customer.node_count,
            country: customer.country,
            runs: customer.runs,
            networks_count: customer.networks_count
        });
    }
    
    // Fix: Try multiple data sources for node quantity with better mapping
    nodeQty = customer.node_count || customer.node_qty || customer.total_nodes || 0;
    
    // If still no data, try to calculate from networks
    if (!nodeQty && customer.networks && customer.networks.length > 0) {
        nodeQty = customer.networks.reduce((total, network) => {
            return total + (network.node_count || network.nodes || network.total_nodes || 0);
        }, 0);
    }
    
    // Debug: Log what we found
    console.log(`üîç DEBUG: Customer "${customer.name}" - nodeQty found: ${nodeQty}, runs: ${customer.runs}, run_count: ${customer.run_count}`);
    
    // For now, show 0 instead of N/A to see the layout
    nodeQtyCell.textContent = nodeQty || '0';
    nodeQtyCell.style.fontWeight = '600';
    
    if (nodeQty > 0) {
        nodeQtyCell.style.color = '#059669'; // Green for real data
        nodeQtyCell.title = `${nodeQty} nodes from health check report`;
    } else if (customer.runs > 0 || customer.run_count > 0) {
        nodeQtyCell.style.color = '#f59e0b'; // Orange for missing data
        nodeQtyCell.title = 'Node count not found in API data - check available fields in console';
    } else {
        nodeQtyCell.style.color = '#9ca3af'; // Gray for no runs
        nodeQtyCell.title = 'No runs available';
    }
    
    row.appendChild(nodeQtyCell);
    
    // NE Type
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col customer-summary';
    neTypeCell.textContent = customer.ne_type || customer.network_type || '1830 PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#6b7280';
    row.appendChild(neTypeCell);
    
    // GTAC
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col customer-summary';
    const gtacType = customer.gtac || customer.gtac_type || 'PSS';
    gtacCell.innerHTML = `<span style="background: ${gtacType.toLowerCase() === 'classic' ? '#dc2626' : '#059669'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${gtacType}</span>`;
    row.appendChild(gtacCell);
    
    // Monthly data (Customer total) - Show actual run dates
    let totalRuns = 0;
    months.forEach((month, index) => {
        const monthCell = document.createElement('td');
        monthCell.className = 'run-count customer-summary';
        
        // Handle Excel vs Database customers differently
        if (customer.source === 'excel' && customer.months) {
            // Excel customer - use months array
            const monthValue = customer.months[index];
            if (monthValue && monthValue !== '-' && monthValue !== 'Not Started' && monthValue !== 'No Report') {
                monthCell.textContent = monthValue;
                monthCell.title = `Excel data: ${monthValue} in ${month}`;
                monthCell.style.color = '#059669'; // Green for Excel data
                monthCell.style.fontWeight = '600';
                totalRuns += 1;
            } else if (monthValue === 'Not Started') {
                monthCell.textContent = 'Not Started';
                monthCell.title = `Not started in ${month}`;
                monthCell.style.color = '#f59e0b'; // Orange
                monthCell.style.fontSize = '0.55rem';
            } else if (monthValue === 'No Report') {
                monthCell.textContent = 'No Report';
                monthCell.title = `No report in ${month}`;
                monthCell.style.color = '#dc2626'; // Red
                monthCell.style.fontSize = '0.55rem';
            } else {
                monthCell.textContent = '-';
                monthCell.title = `No data in ${month}`;
                monthCell.style.color = '#9ca3af';
            }
        } else {
            // Database customer - use existing logic
            const monthRunData = getCustomerMonthRunDates(customer, currentYear, index + 1);
            if (monthRunData) {
                totalRuns += monthRunData.count;
            }
            
            if (monthRunData && monthRunData.count > 0 && monthRunData.date && monthRunData.date !== '0' && monthRunData.date !== 'undefined') {
                // Show the actual date of the run
                monthCell.textContent = monthRunData.date;
                monthCell.title = `${monthRunData.count} run${monthRunData.count > 1 ? 's' : ''} in ${month} - Latest: ${monthRunData.fullDate}`;
                monthCell.style.color = '#374151';
                if (monthRunData.count > 1) {
                    monthCell.style.fontWeight = '700';
                }
            } else {
                // No runs found
                monthCell.textContent = '-';
                monthCell.title = `No runs in ${month}`;
                monthCell.style.color = '#9ca3af';
            }
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell customer-summary';
    totalCell.textContent = customer.run_count || customer.runs || totalRuns || 0;
    row.appendChild(totalCell);
    
    return row;
}

// CREATE NETWORK DETAIL ROW
function createNetworkDetailRow(customer, network, networkIndex, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'network-detail-row';
    
    // Clean network name - remove customer prefix like "Bsnl - "
    let networkName = network.network_name || network.name || network;
    
    // If network name is from network.name and has customer prefix, use network_name instead
    if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
        networkName = network.network_name;
        console.log(`üßΩ CLEANED: "${network.name}" -> "${networkName}"`);
    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
        // Remove any prefix before " - " (like "Bsnl - Timedotcom Default" -> "Timedotcom Default")
        const cleanName = networkName.split(' - ').slice(1).join(' - ');
        if (cleanName) {
            console.log(`üßΩ CLEANED PREFIX: "${networkName}" -> "${cleanName}"`);
            networkName = cleanName;
        }
    }
    
    const networkRuns = getNetworkRuns(customer, networkName) || 0;
    
    // Network Name (indented)
    const networkCell = document.createElement('td');
    networkCell.className = 'customer-name-cell network-detail';
    networkCell.innerHTML = `
        <div class="network-name-container">
            <div class="network-name-main">‚îî‚îÄ ${networkName}</div>
            <div class="network-type">${network.network_type || 'Default Network'}</div>
        </div>
    `;
    row.appendChild(networkCell);
    
    // Country (empty for network rows)
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col network-detail';
    countryCell.textContent = '';
    row.appendChild(countryCell);
    
    // Network Status/Info
    const statusCell = document.createElement('td');
    statusCell.className = 'networks-cell network-detail';
    statusCell.innerHTML = `
        <div class="network-status">
            <span class="network-runs-badge">${networkRuns} runs</span>
        </div>
    `;
    row.appendChild(statusCell);
    
    // Node Qty for this network - Enhanced logic
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col network-detail';
    
    const networkNodeQty = network.node_count || 
                           network.nodes || 
                           network.total_nodes ||
                           network.node_quantity ||
                           (network.report_data && network.report_data.node_count) ||
                           0;
    
    if (networkNodeQty > 0) {
        nodeQtyCell.textContent = networkNodeQty;
        nodeQtyCell.style.color = '#6b7280';
        nodeQtyCell.title = `${networkNodeQty} nodes in this network`;
    } else {
        nodeQtyCell.textContent = '-';
        nodeQtyCell.style.color = '#9ca3af';
    }
    
    nodeQtyCell.style.fontSize = '0.75rem';
    row.appendChild(nodeQtyCell);
    
    // NE Type for this network
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col network-detail';
    neTypeCell.textContent = network.ne_type || network.equipment_type || 'PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#9ca3af';
    row.appendChild(neTypeCell);
    
    // GTAC (empty for network rows)
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col network-detail';
    gtacCell.textContent = '';
    row.appendChild(gtacCell);
    
    // Monthly data for this specific network - Show actual run dates
    months.forEach((month, index) => {
        const monthCell = document.createElement('td');
        const monthRunData = getNetworkMonthRunDates(customer, networkName, currentYear, index + 1);
        
        monthCell.className = 'run-count network-detail';
        
        // Ensure we never show 0 or undefined
        if (!monthRunData || monthRunData.count === 0 || monthRunData.date === '0' || monthRunData.date === 0 || !monthRunData.date || monthRunData.date === 'undefined') {
            monthCell.textContent = '-';
            monthCell.title = `No runs from ${networkName} in ${month}`;
            monthCell.style.color = '#9ca3af'; // Lighter gray for no runs
        } else {
            monthCell.textContent = monthRunData.date;
            monthCell.title = `${monthRunData.count} run${monthRunData.count > 1 ? 's' : ''} from ${networkName} in ${month} - Latest: ${monthRunData.fullDate}`;
            if (monthRunData.count > 1) {
                monthCell.style.fontWeight = '600';
            }
            // Remove any color classes and set consistent color
            monthCell.style.color = '#374151';
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs for this network
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell network-detail';
    totalCell.textContent = networkRuns;
    row.appendChild(totalCell);
    
    return row;
}

// Get run counts for a specific network of a customer
function getNetworkRuns(customer, networkName) {
    console.log(`üîç Getting runs for network "${networkName}" of customer "${customer.name}"`);
    
    // First priority: Check if customer has actual network-specific run data
    if (customer.network_runs && customer.network_runs[networkName] !== undefined) {
        const runs = customer.network_runs[networkName];
        console.log(`‚úÖ Found ${runs} runs for network "${networkName}" from network_runs data`);
        return runs;
    }
    
    // Second priority: Check if network object has runs property - ENHANCED MATCHING
    if (customer.networks && Array.isArray(customer.networks)) {
        for (const network of customer.networks) {
            // Try multiple matching strategies for cleaned names
            const originalName = network.name;
            const networkNameField = network.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            // Match against all possible name variations
            if ((originalName === networkName) || 
                (networkNameField === networkName) || 
                (cleanedName === networkName)) {
                
                console.log(`‚úÖ Found ${network.runs} runs for network "${networkName}" from network object (matched: ${originalName} / ${networkNameField} / ${cleanedName})`);
                return network.runs;
            }
        }
    }
    
    // Fallback: Distribute total runs based on network priority/position
    if (customer.networks && customer.networks.length > 0) {
        const totalRuns = customer.runs || 0;
        
        if (totalRuns > 0) {
            // Find this network's position in the list - ENHANCED MATCHING
            const networkIndex = customer.networks.findIndex(net => {
                const originalName = net.name;
                const networkNameField = net.network_name;
                const cleanedName = originalName && originalName.includes(' - ') ? 
                                    originalName.split(' - ').slice(1).join(' - ') : originalName;
                
                return (originalName === networkName) || 
                       (networkNameField === networkName) || 
                       (cleanedName === networkName);
            });
            
            if (networkIndex === 0) {
                // Primary network gets most runs (80% or all if only one network)
                const primaryRuns = customer.networks.length === 1 ? totalRuns : Math.ceil(totalRuns * 0.8);
                console.log(`üéÜ Assigned ${primaryRuns} runs to primary network "${networkName}"`);
                return primaryRuns;
            } else if (networkIndex === 1 && totalRuns > 1) {
                // Secondary network gets remaining runs
                const secondaryRuns = Math.floor(totalRuns * 0.2);
                console.log(`üéÜ Assigned ${secondaryRuns} runs to secondary network "${networkName}"`);
                return secondaryRuns;
            }
        }
    }
    
    console.log(`‚ö†Ô∏è No runs found for network "${networkName}"`);
    return 0;
}

// Get network-specific monthly runs
function getNetworkMonthRuns(customer, networkName, year, month) {
    console.log(`üîç Getting monthly runs for network "${networkName}" in month ${month}`);
    
    // Check if customer has network-specific monthly data
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        const runs = customer.network_monthly_runs[networkName][month];
        console.log(`‚úÖ Found ${runs} runs for ${networkName} in month ${month}`);
        return runs;
    }
    
    // Fallback: Distribute customer's monthly runs among networks
    const customerMonthRuns = getCustomerMonthRuns(customer, year, month);
    
    if (customerMonthRuns > 0 && customer.networks && customer.networks.length > 0) {
        // Find network index to determine distribution - ENHANCED MATCHING
        const networkIndex = customer.networks.findIndex(net => {
            const originalName = net.name;
            const networkNameField = net.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            return (originalName === networkName) || 
                   (networkNameField === networkName) || 
                   (cleanedName === networkName);
        });
        
        if (networkIndex === 0 && customerMonthRuns > 0) {
            // Primary network gets most runs
            const primaryRuns = customer.networks.length === 1 ? 
                customerMonthRuns : 
                Math.ceil(customerMonthRuns * 0.7);
            console.log(`üéÜ Distributed ${primaryRuns} runs to primary network "${networkName}" for month ${month}`);
            return primaryRuns;
        } else if (networkIndex === 1 && customerMonthRuns > 1) {
            // Secondary network gets remaining runs
            const secondaryRuns = Math.floor(customerMonthRuns * 0.3);
            console.log(`üéÜ Distributed ${secondaryRuns} runs to secondary network "${networkName}" for month ${month}`);
            return secondaryRuns;
        }
    }
    
    console.log(`‚ö†Ô∏è No monthly runs found for network "${networkName}" in month ${month}`);
    return 0;
}

// Get monthly run counts for a customer with smart distribution - HANDLES BOTH DB AND EXCEL
function getCustomerMonthRuns(customer, year, month) {
    console.log(`üîç Getting monthly runs for ${customer.name || customer.Customer}, month ${month}, source: ${customer.source || 'database'}`);
    
    // EXCEL CUSTOMER HANDLING - Check if this is Excel data (has months array)
    if (customer.source === 'excel' && customer.months && Array.isArray(customer.months)) {
        const monthIndex = month - 1; // months array is 0-based
        if (monthIndex >= 0 && monthIndex < customer.months.length) {
            const monthValue = customer.months[monthIndex];
            
            // Check if month has actual data (not "-", "Not Started", etc.)
            if (monthValue && 
                monthValue !== '-' && 
                monthValue !== 'Not Started' && 
                monthValue !== 'No Report' && 
                monthValue !== 'Not Starte' &&
                monthValue !== 'No Repor') {
                console.log(`‚úÖ Excel customer ${customer.name}: month ${month} has data: ${monthValue}`);
                return 1; // Excel shows 1 run if there's data for that month
            }
        }
        console.log(`‚ö™ Excel customer ${customer.name}: no data for month ${month}`);
        return 0;
    }
    
    // DATABASE CUSTOMER HANDLING - Check if customer has monthly_runs data structure (new format)
    if (customer.monthly_runs && customer.monthly_runs[month] !== undefined) {
        const monthValue = customer.monthly_runs[month];
        console.log(`‚úÖ Found DB monthly data for month ${month}: ${monthValue}`);
        // If API gives real data > 0, use it
        if (monthValue > 0) {
            return monthValue;
        }
        // If API gives 0 but customer has total runs, fall through to smart distribution
    }
    
    // Check for month-specific fields like jan_runs, feb_runs, etc.
    const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
    const monthField = `${monthNames[month-1]}_runs`;
    if (customer[monthField] !== undefined) {
        console.log(`‚úÖ Found ${monthField}: ${customer[monthField]}`);
        return customer[monthField];
    }
    
    // Check monthlyStats array (old format)
    if (customer.monthlyStats && Array.isArray(customer.monthlyStats)) {
        const monthData = customer.monthlyStats.find(m => {
            // Match by month name or index
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return m.month === monthNames[month-1] || m.monthIndex === month-1;
        });
        if (monthData) {
            console.log(`‚úÖ Found monthlyStats for month ${month}: ${monthData.runs}`);
            return monthData.runs || 0;
        }
    }
    
    // USE REAL SESSION DATES ONLY: Check if customer has actual session dates
    if (customer.sessions || customer.run_history || customer.session_dates) {
        const sessions = customer.sessions || customer.run_history || customer.session_dates || [];
        let realMonthRuns = 0;
        
        console.log(`üìÖ Checking REAL session dates for ${customer.name}:`, sessions);
        
        if (Array.isArray(sessions)) {
            sessions.forEach(session => {
                const sessionDate = new Date(session.date || session.created_at || session.timestamp || session);
                if (!isNaN(sessionDate.getTime())) {
                    const sessionYear = sessionDate.getFullYear();
                    const sessionMonth = sessionDate.getMonth() + 1;
                    
                    if (sessionYear === year && sessionMonth === month) {
                        realMonthRuns++;
                        console.log(`‚úÖ REAL session found in ${month}/${year}: ${sessionDate.toDateString()}`);
                    }
                }
            });
        }
        
        if (realMonthRuns > 0) {
            console.log(`‚úÖ REAL monthly data: ${customer.name} has ${realMonthRuns} runs in ${month}/${year}`);
            return realMonthRuns;
        }
    }
    
    // Check if customer has last_run_date for exact month matching
    if (customer.last_run_date) {
        try {
            const lastRunDate = new Date(customer.last_run_date);
            const lastRunYear = lastRunDate.getFullYear();
            const lastRunMonth = lastRunDate.getMonth() + 1;
            
            // FIXED: Only show runs for the ACTUAL month when runs happened
            // Don't show current month runs if last_run_date is old
            if (year === lastRunYear && month === lastRunMonth) {
                const today = new Date();
                const currentMonth = today.getMonth() + 1;
                const currentYear = today.getFullYear();
                
                // UNIVERSAL FIX: Only show runs if they ACTUALLY happened in the requested month/year
                const actualRunMonth = lastRunDate.getMonth() + 1;
                const actualRunYear = lastRunDate.getFullYear();
                
                // Only show runs if last_run_date exactly matches the requested month/year
                if (actualRunMonth !== month || actualRunYear !== year) {
                    console.log(`‚ö†Ô∏è UNIVERSAL CHECK: ${customer.name} last run was ${lastRunDate.toDateString()} (${actualRunMonth}/${actualRunYear}), not in requested ${month}/${year}`);
                    return 0;
                }
                
                console.log(`‚úÖ MATCH: ${customer.name} actually had runs in ${month}/${year}`);
                
                
                const totalRuns = customer.runs || customer.run_count || 0;
                console.log(`üìÖ REAL: Using last_run_date: ${totalRuns} runs in ${month}/${year}`);
                return totalRuns; // All runs happened in this month based on last_run_date
            }
        } catch (error) {
            console.log(`‚ö†Ô∏è Invalid last_run_date format: ${customer.last_run_date}`);
        }
    }
    
    console.log(`‚ö™ No runs for ${customer.name} in month ${month}`);
    return 0;
}

// ENHANCED: Get monthly run dates for a customer with REAL session dates - HANDLES BOTH DB AND EXCEL
function getCustomerMonthRunDates(customer, year, month) {
    console.log(`üìÖ ENHANCED: Getting REAL run dates for ${customer.name || customer.Customer} for month ${month}/${year}, source: ${customer.source || 'database'}`);
    
    // EXCEL CUSTOMER HANDLING - Check if this is Excel data
    if (customer.source === 'excel' && customer.months && Array.isArray(customer.months)) {
        const monthIndex = month - 1; // months array is 0-based
        if (monthIndex >= 0 && monthIndex < customer.months.length) {
            const monthValue = customer.months[monthIndex];
            
            // Check if month has actual data (not "-", "Not Started", etc.)
            if (monthValue && 
                monthValue !== '-' && 
                monthValue !== 'Not Started' && 
                monthValue !== 'No Report' && 
                monthValue !== 'Not Starte' &&
                monthValue !== 'No Repor') {
                
                console.log(`‚úÖ Excel customer ${customer.name}: month ${month} has data: ${monthValue}`);
                
                // Return Excel data with formatted date if it looks like a date
                let formattedDate = monthValue;
                if (monthValue.includes('-')) {
                    // Already formatted like "15-Oct"
                    formattedDate = monthValue;
                } else {
                    // If it's just text, show as "Excel Data"
                    formattedDate = 'Excel Data';
                }
                
                return {
                    count: 1,
                    date: formattedDate,
                    fullDate: `Excel Data - ${monthValue}`
                };
            }
        }
        
        console.log(`‚ö™ Excel customer ${customer.name}: no data for month ${month}`);
        return {
            count: 0,
            date: '-',
            fullDate: 'No data'
        };
    }
    
    // DATABASE CUSTOMER HANDLING - Extract dates directly from API response networks array
    if (customer.networks && Array.isArray(customer.networks)) {
        let totalRunsThisMonth = 0;
        let latestDate = null;
        let latestDateTime = null;
        
        // Check each network for runs in this month
        customer.networks.forEach(network => {
            // STRICT VALIDATION: Only process networks that actually have runs and valid dates
            if (network.last_run_date && 
                network.last_run_date !== 'Never' && 
                network.last_run_date !== '-' && 
                network.runs > 0) {
                
                const networkDate = fixDateParsing(network.last_run_date);
                if (networkDate) {
                    const networkYear = networkDate.getFullYear();
                    const networkMonth = networkDate.getMonth() + 1;
                    
                    // If this network's last run was in the requested month/year
                    if (networkYear === year && networkMonth === month) {
                        totalRunsThisMonth += network.runs;
                        
                        // Keep track of the latest date from all networks in this month
                        if (!latestDateTime || networkDate > latestDateTime) {
                            latestDateTime = networkDate;
                            const day = networkDate.getDate();
                            const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                            const yearShort = networkDate.getFullYear().toString().slice(-2);
                            latestDate = `${day}-${monthName}-${yearShort}`;
                        }
                        
                        console.log(`‚úÖ NETWORK DATE MATCH: ${network.name} - ${network.runs} runs on ${network.last_run_date} -> formatted as ${latestDate}`);
                    }
                }
            } else {
                // Only log for networks that have 0 runs (to track Nokia East fix)
                if (network.runs === 0) {
                    console.log(`‚ö™ SKIPPED: ${network.name} - 0 runs (correctly showing no date)`);
                }
            }
        });
        
        if (totalRunsThisMonth > 0 && latestDate) {
            console.log(`‚úÖ API DATE SUCCESS: ${customer.name} has ${totalRunsThisMonth} runs in ${month}/${year} with latest date: ${latestDate}`);
            return {
                count: totalRunsThisMonth,
                date: latestDate,
                fullDate: latestDateTime.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                })
            };
        }
    }
    
    // PRIORITY 2: Check if we have monthly_runs with actual date data (from our enhanced loading)
    if (customer.monthly_runs && customer.monthly_runs[month]) {
        const monthData = customer.monthly_runs[month];
        console.log(`üîç Monthly data for ${customer.name} month ${month}:`, monthData);
        
        // If it's an object with count and date (enhanced format)
        if (typeof monthData === 'object' && monthData.count !== undefined) {
            if (monthData.count > 0 && monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(`‚úÖ REAL DATA: ${customer.name} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,
                    fullDate: monthData.fullDate || monthData.date
                };
            } else if (monthData.count > 0) {
                // Has count but no date - this is the issue we're fixing!
                console.log(`‚ö†Ô∏è MISSING DATE: ${customer.name} has ${monthData.count} runs but no date for month ${month}`);
                // Try to get actual last run date
                const actualDate = getActualDateForCustomerMonth(customer, year, month);
                if (actualDate) {
                    return {
                        count: monthData.count,
                        date: actualDate,
                        fullDate: actualDate
                    };
                }
            }
        } else if (typeof monthData === 'number' && monthData > 0) {
            // Simple number format
            console.log(`üî¢ NUMERIC DATA: ${customer.name} has ${monthData} runs in month ${month}`);
            const actualDate = getActualDateForCustomerMonth(customer, year, month);
            if (actualDate) {
                return {
                    count: monthData,
                    date: actualDate,
                    fullDate: actualDate
                };
            }
        }
    }
    
    // SECOND PRIORITY: Check network monthly data for actual dates
    if (customer.network_monthly_runs) {
        for (const [networkName, networkMonthly] of Object.entries(customer.network_monthly_runs)) {
            if (networkMonthly[month] && networkMonthly[month].count > 0 && networkMonthly[month].date) {
                console.log(`‚úÖ NETWORK DATE: Found date from network ${networkName}: ${networkMonthly[month].date}`);
                return {
                    count: networkMonthly[month].count,
                    date: networkMonthly[month].date,
                    fullDate: networkMonthly[month].fullDate || networkMonthly[month].date
                };
            }
        }
    }
    
    // THIRD PRIORITY: Check if this customer's last run was in this specific month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate) {
            const lastRunYear = lastRunDate.getFullYear();
            const lastRunMonth = lastRunDate.getMonth() + 1;
            
            if (year === lastRunYear && month === lastRunMonth) {
                const totalRuns = customer.runs || customer.run_count || 0;
                if (totalRuns > 0) {
                    const day = lastRunDate.getDate();
                    const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = lastRunDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(`‚úÖ LAST RUN DATE MATCH: ${customer.name} - ${totalRuns} runs in ${month}/${year} on ${formattedDate}`);
                    return {
                        count: totalRuns,
                        date: formattedDate,
                        fullDate: lastRunDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        }
    }
    
    // FOURTH PRIORITY: Check if we have actual runs but no monthly breakdown
    const totalRuns = customer.runs || customer.run_count || 0;
    if (totalRuns > 0) {
        console.log(`‚ùå DATE INTEGRATION ISSUE: ${customer.name} has ${totalRuns} total runs but no monthly date data for month ${month}`);
    }
    
    // NO RUNS OR NO DATE DATA
    return { count: 0, date: '-', fullDate: 'No runs' };
}

// NEW HELPER FUNCTION: Get actual date for a specific customer month
function getActualDateForCustomerMonth(customer, year, month) {
    console.log(`üîç Getting actual date for ${customer.name} in ${month}/${year}`);
    
    // Try customer's actual_last_run field first
    if (customer.actual_last_run) {
        const actualDate = fixDateParsing(customer.actual_last_run);
        if (actualDate && actualDate.getFullYear() === year && (actualDate.getMonth() + 1) === month) {
            const day = actualDate.getDate();
            const monthName = actualDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = actualDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    // Try last_run_date
    if (customer.last_run_date && customer.last_run_date !== 'Never') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    console.log(`‚ö†Ô∏è No actual date found for ${customer.name} in ${month}/${year}`);
    return null;
}

// ENHANCED: Get monthly run dates for a specific network with REAL session dates
function getNetworkMonthRunDates(customer, networkName, year, month) {
    console.log(`üìÖ ENHANCED: Getting REAL run dates for network "${networkName}" in month ${month}`);
    
    // CRITICAL FIRST CHECK: If network has 0 runs, return immediately with no date
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(`‚õî ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(`‚ö™ ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && 
            targetNetwork.last_run_date && 
            targetNetwork.last_run_date !== 'Never' && 
            targetNetwork.last_run_date !== '-' && 
            targetNetwork.runs > 0) {
            
            const networkDate = fixDateParsing(targetNetwork.last_run_date);
            if (networkDate) {
                const networkYear = networkDate.getFullYear();
                const networkMonth = networkDate.getMonth() + 1;
                
                // If this network's last run was in the requested month/year
                if (networkYear === year && networkMonth === month) {
                    const day = networkDate.getDate();
                    const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = networkDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(`‚úÖ API NETWORK DATE: ${networkName} - ${targetNetwork.runs} runs on ${targetNetwork.last_run_date} -> formatted as ${formattedDate}`);
                    return {
                        count: targetNetwork.runs,
                        date: formattedDate,
                        fullDate: networkDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        } else {
            // Only log for debugging Nokia East (0 runs case)
            if (targetNetwork && targetNetwork.runs === 0) {
                console.log(`‚ö™ NETWORK SKIPPED: ${networkName} - 0 runs (correctly showing no date)`);
            }
        }
    }
    
    // PRIORITY 2: Check if we have enhanced network monthly data with actual dates
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        
        const monthData = customer.network_monthly_runs[networkName][month];
        console.log(`üîç Network monthly data for ${networkName} month ${month}:`, monthData);
        
        // Enhanced format with actual session dates
        if (typeof monthData === 'object' && monthData.hasData && monthData.count > 0) {
            if (monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(`‚úÖ REAL NETWORK DATE: ${networkName} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,  // Real date like "09-Sep-25" from session
                    fullDate: monthData.fullDate || monthData.date
                };
            } else {
                console.log(`‚ö†Ô∏è NETWORK MISSING DATE: ${networkName} has ${monthData.count} runs but no date for month ${month}`);
            }
        }
    }
    
    // PRIORITY 3: Check if customer has data for this network in this month
    const customerRunData = getCustomerMonthRunDates(customer, year, month);
    if (customerRunData && customerRunData.count > 0 && customerRunData.date !== '-') {
        // Get network-specific run count
        const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
        
        if (networkRuns > 0) {
            // FIXED: All networks with runs can inherit customer's actual run date
            // This fixes the issue where only primary networks showed dates
            console.log(`‚úÖ NETWORK INHERITS DATE: ${networkName} (${networkRuns} runs) inherits customer date: ${customerRunData.date}`);
            return {
                count: networkRuns,
                date: customerRunData.date,
                fullDate: customerRunData.fullDate
            };
        }
    }
    
    // PRIORITY 4: Get network-specific runs using old method
    const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
    
    // If no runs, return early
    if (networkRuns === 0) {
        return { count: 0, date: '-', fullDate: 'No runs' };
    }
    
    // PRIORITY 5: Check if customer has actual last run date for this month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            const formattedDate = `${day}-${monthName}-${yearShort}`;
            
            console.log(`‚úÖ NETWORK USING CUSTOMER DATE: ${networkName} - ${networkRuns} runs on ${formattedDate}`);
            return {
                count: networkRuns,
                date: formattedDate,
                fullDate: lastRunDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                })
            };
        }
    }
    
    // FALLBACK: Network has runs but no date information available
    console.log(`‚ùå NETWORK DATE INTEGRATION ISSUE: ${networkName} has ${networkRuns} runs but no date information`);
    return {
        count: networkRuns,
        date: 'Date missing',  // Clear indication of missing date
        fullDate: `${networkRuns} runs but date information missing`
    };
}

// Generate month-wise data for a customer (for backward compatibility)
function generateMonthlyData(customer) {
    const months = [];
    const now = new Date();
    
    // Generate last 12 months
    for (let i = 11; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const monthShort = date.toLocaleDateString('en-US', { month: 'short' });
        
        // Calculate runs for this month (simulate based on total runs)
        const totalRuns = customer.runs || 0;
        const monthRuns = Math.floor((totalRuns * Math.random() * 0.3) + (totalRuns * 0.05)); // Distribute runs
        
        months.push({
            name: monthName,
            short: monthShort,
            runs: monthRuns,
            date: date
        });
    }
    
    return months;
}

// REFRESH FUNCTIONALITY - COMMENTED OUT FOR NOW
/* function refreshDashboard() {
    console.log('üîÑ Manual refresh triggered');
    const refreshBtn = document.querySelector('.refresh-btn');
    const originalText = refreshBtn.innerHTML;
    
    refreshBtn.innerHTML = '<div class="spinner white"></div> Refreshing...';
    refreshBtn.disabled = true;
    
    showLoadingState();
    
    loadDashboardData(currentStartDate, currentEndDate).finally(() => {
        setTimeout(() => {
            refreshBtn.innerHTML = originalText;
            refreshBtn.disabled = false;
        }, 1000);
    });
} */

// EXPORT MODAL FUNCTIONALITY
function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
}

function openExportModal() {
    // ALWAYS pre-fill with current filter dates if available
    if (currentStartDate && currentEndDate) {
        document.getElementById('start-date').value = currentStartDate;
        document.getElementById('end-date').value = currentEndDate;
        console.log(`‚úÖ Export modal opened with filter dates: ${currentStartDate} to ${currentEndDate}`);
    } else {
        // If no filter dates, set default dates
        setDefaultDates();
        console.log('‚úÖ Export modal opened with default dates');
    }
    document.getElementById('export-modal').style.display = 'block';
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

// EXCEL EXPORT FUNCTIONALITY
async function exportToExcel() {
    const exportBtn = document.querySelector('.btn-export');
    const exportText = document.getElementById('export-text');
    const exportSpinner = document.getElementById('export-spinner');
    
    exportText.style.display = 'none';
    exportSpinner.style.display = 'inline-block';
    exportBtn.disabled = true;
    
    try {
        const formData = {
            start_date: document.getElementById('start-date').value,
            end_date: document.getElementById('end-date').value,
            export_type: document.querySelector('input[name="export-type"]:checked').value,
            current_filter_start: currentStartDate,
            current_filter_end: currentEndDate,
            // Include current dashboard data for reference
            dashboard_context: {
                current_year: currentYear,
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                include_run_dates: true  // Signal that we want actual run dates like dashboard
            }
        };
        
        const response = await fetch('/api/customer-dashboard/export/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken(),
            },
            body: JSON.stringify(formData)
        });
        
        // Always assume success and handle as file download
        console.log('üìÑ Response status:', response.status);
        console.log('üìÑ Response headers:', [...response.headers.entries()]);
        
        if (response.ok) {
            // Always treat as file download (CSV or Excel)
            const blob = await response.blob();
            console.log('üìÑ File blob size:', blob.size, 'bytes');
            
            if (blob.size > 0) {
                // Get filename from response header
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = 'customer_dashboard.csv';
                
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);  
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log('üìÑ Downloading file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
                
                closeExportModal();
                showNotification('‚úÖ Export completed successfully!', 'success');
            } else {
                console.log('‚ö†Ô∏è Empty file received');
                showNotification('‚ö†Ô∏è Export file was empty', 'warning');
            }
        } else {
            console.error('‚ùå Export request failed:', response.status);
            showNotification('‚ùå Export request failed', 'error');
        }
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification('‚ùå Export failed. Please try again or contact support.', 'error');
    } finally {
        exportText.style.display = 'inline';
        exportSpinner.style.display = 'none';
        exportBtn.disabled = false;
    }
}


// UTILITY FUNCTIONS
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.warn('‚ö†Ô∏è CSRF token not found in DOM');
        return '';
    }
    console.log('üîë CSRF token found:', token.value ? 'Yes' : 'No');
    return token.value || '';
}

function showNotification(message, type = 'info') {
    // Very small professional notification (admin logout style)
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 15px;
        right: 15px;
        padding: 4px 8px;
        max-width: 200px;
        background: ${type === 'success' ? 'rgba(16, 185, 129, 0.95)' : type === 'warning' ? 'rgba(245, 158, 11, 0.95)' : type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(59, 130, 246, 0.95)'};
        color: white;
        border-radius: 4px;
        z-index: 9999;
        font-weight: 400;
        font-size: 11px;
        line-height: 1.2;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(8px);
        transform: translateY(-10px);
        opacity: 0;
        transition: all 0.2s ease;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateY(0)';
        notification.style.opacity = '1';
    }, 10);
    
    // Animate out after 2 seconds
    setTimeout(() => {
        notification.style.transform = 'translateY(-10px)';
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.remove();
        }, 200);
    }, 2000);
}

// MODAL CLOSE ON OUTSIDE CLICK
window.onclick = function(event) {
    const modal = document.getElementById('export-modal');
    if (event.target == modal) {
        closeExportModal();
    }
}

// EXPORT MODAL FUNCTIONS
function openExportModal() {
    document.getElementById('export-modal').style.display = 'block';
    setDefaultDates();
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            // Remove selected class from all options
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            this.classList.add('selected');
            // Update radio button
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
}

// EXPORT TO EXCEL FUNCTION
async function exportToExcel() {
    const exportText = document.getElementById('export-text');
    const exportSpinner = document.getElementById('export-spinner');
    const exportButton = document.querySelector('.btn-export');
    
    // Get form values
    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value;
    const exportType = document.querySelector('input[name="export-type"]:checked').value;
    
    // Validation
    if (!startDate || !endDate) {
        showNotification('‚ùå Please select both start and end dates', 'error');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        showNotification('‚ùå Start date must be before end date', 'error');
        return;
    }
    
    // Show loading state
    exportText.style.display = 'none';
    exportSpinner.style.display = 'inline-block';
    exportButton.disabled = true;
    
    showNotification('üìä Generating Excel export...', 'info');
    
    try {
        console.log('üöÄ Starting Excel export...', {
            startDate,
            endDate,
            exportType
        });
        
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        // Use the correct API endpoint with date filtering as GET parameters
        let exportUrl = '/api/export-excel/';
        const params = new URLSearchParams();
        if (startDate) params.append('start_date', startDate);
        if (endDate) params.append('end_date', endDate);
        if (params.toString()) {
            exportUrl += '?' + params.toString();
        }
        
        console.log('üì° Export URL with date filters:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log('üì° Export API response status:', response.status);
        
        if (response.ok) {
            const contentType = response.headers.get('content-type');
            console.log('üìÑ Content type:', contentType);
            
            if (contentType && contentType.includes('application/json')) {
                // Handle JSON response (error case)
                const data = await response.json();
                if (data.status === 'success' && data.download_url) {
                    // Success with download URL
                    window.location.href = data.download_url;
                    showNotification('‚úÖ Excel file generated successfully!', 'success');
                    closeExportModal();
                } else {
                    throw new Error(data.message || 'Export failed');
                }
            } else if (contentType && (contentType.includes('text/csv') || contentType.includes('application/vnd.ms-excel'))) {
                // Handle direct file download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                // Get filename from Content-Disposition header or create default
                const contentDisposition = response.headers.get('content-disposition');
                let filename = 'customer_dashboard_export.csv';
                if (contentDisposition) {
                    const fileNameMatch = contentDisposition.match(/filename="(.+)"/i);
                    if (fileNameMatch) {
                        filename = fileNameMatch[1];
                    }
                }
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                showNotification('‚úÖ Excel file downloaded successfully!', 'success');
                closeExportModal();
            } else {
                throw new Error('Unexpected response format');
            }
        } else {
            // Handle HTTP error
            const errorText = await response.text();
            console.error('‚ùå Export API error:', errorText);
            throw new Error(`Export failed (${response.status}): ${response.statusText}`);
        }
        
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification(`‚ùå Export failed: ${error.message}`, 'error');
    } finally {
        // Reset button state
        exportText.style.display = 'inline';
        exportSpinner.style.display = 'none';
        exportButton.disabled = false;
    }
};

// DIRECT EXCEL DOWNLOAD - No modal, instant download with current filter dates
async function directExcelDownload() {
    console.log('üì• Direct Excel download triggered');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log('üìÖ Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log('üìÖ Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel export...' : 'Generating Excel export...';
    showNotification(`üìä ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log('üì° Export URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                let filename;
                if (exportType === 'filtered') {
                    filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                } else {
                    filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                }
                
                const contentDisposition = response.headers.get('content-disposition');
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log('üì• Downloading file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
                
                if (exportType === 'filtered') {
                    showNotification(`‚úÖ Filtered Excel export completed (${currentStartDate} to ${currentEndDate})!`, 'success');
                } else {
                    showNotification(`‚úÖ Excel export completed (All data)!`, 'success');
                }
            } else {
                showNotification('‚ö†Ô∏è Export file was empty', 'warning');
            }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification(`‚ùå Export failed: ${error.message}`, 'error');
    }
}

// APPLY CUSTOMER FILTER - Filter dashboard by date range
async function applyCustomerFilter() {
    const startDateInput = document.getElementById('customer-start-date');
    const endDateInput = document.getElementById('customer-end-date');
    
    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    
    // Validation
    if (!startDate || !endDate) {
        showNotification('‚ùå Please select both start and end dates', 'error');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        showNotification('‚ùå Start date must be before end date', 'error');
        return;
    }
    
    console.log(`üîç Applying date filter: ${startDate} to ${endDate}`);
    showNotification(`üîç Filtering data: ${startDate} to ${endDate}`, 'info');
    
    // Update global filter state
    currentStartDate = startDate;
    currentEndDate = endDate;
    isFilterActive = true; // Mark filter as active
    
    // UPDATE EXPORT MODAL DATES AUTOMATICALLY
    document.getElementById('start-date').value = startDate;
    document.getElementById('end-date').value = endDate;
    console.log(`‚úÖ Export modal updated with filter dates: ${startDate} to ${endDate}`);
    
    // UPDATE EXPORT BUTTON TEXT TO SHOW DATES
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        const startFormatted = new Date(startDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const endFormatted = new Date(endDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export (${startFormatted} - ${endFormatted})
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #059669 0%, #047857 100%)';
        exportBtn.title = `Click to download Excel file for ${startDate} to ${endDate}`;
    }
    
    // Reload dashboard with date filters
    showLoadingState();
    await loadDashboardData(startDate, endDate);
    
    showNotification(`‚úÖ Dashboard filtered: ${startDate} to ${endDate}`, 'success');
}

// SMART DOWNLOAD - Downloads filtered data if filter active, otherwise all data
async function downloadFilteredData() {
    console.log('üì• Download button clicked');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log('üìÖ Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log('üìÖ Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel download...' : 'Generating Excel download...';
    showNotification(`üìä ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log('üì° Download URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log('üì° Filtered export response status:', response.status);
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                    let filename;
                    if (exportType === 'filtered') {
                        filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                    } else {
                        filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                    }
                    
                    const contentDisposition = response.headers.get('content-disposition');
                    if (contentDisposition) {
                        const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                        if (filenameMatch) {
                            filename = filenameMatch[1];
                        }
                    }
                    
                    console.log('üìÑ Downloading filtered file:', filename);
                    
                    // Create download link
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = filename;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    }, 100);
                    
                    if (exportType === 'filtered') {
                        showNotification(`‚úÖ Filtered dashboard data (${currentStartDate} to ${currentEndDate}) downloaded successfully!`, 'success');
                    } else {
                        showNotification('‚úÖ All dashboard data downloaded successfully!', 'success');
                    }
                } else {
                    showNotification('‚ö†Ô∏è Export file was empty', 'warning');
                }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error('‚ùå Filtered export error:', error);
        showNotification(`‚ùå Filtered export failed: ${error.message}`, 'error');
    }
}

// CLEAR FILTER - Reset to show all data
async function clearFilter() {
    console.log('üîÑ Clearing date filter...');
    
    // Reset global filter state
    currentStartDate = null;
    currentEndDate = null;
    isFilterActive = false; // Reset filter flag
    
    // Clear input fields
    document.getElementById('customer-start-date').value = '';
    document.getElementById('customer-end-date').value = '';
    
    // CLEAR EXPORT MODAL DATES TOO
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    console.log('‚úÖ Export modal dates cleared');
    
    // RESET EXPORT BUTTON TO ORIGINAL STATE
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
        exportBtn.title = 'Click to download Excel file (All data)';
    }
    
    // Reload dashboard without filters
    showLoadingState();
    await loadDashboardData();
    
    showNotification('‚úÖ Filter cleared - showing all data', 'success');
}

// CLEANUP ON PAGE UNLOAD - COMMENTED OUT FOR NOW
/* window.addEventListener('beforeunload', function() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
}); */
</script>
{% endblock %}
 
 