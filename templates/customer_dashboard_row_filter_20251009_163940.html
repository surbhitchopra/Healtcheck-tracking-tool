



{% extends 'base.html' %}

{% block title %}Customer Dashboard - Health Check Overview{% endblock %}

{% block extra_head %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
    body {
        background: #f8fafc;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        color: #1e293b;
        line-height: 1.6;
    }
    
    .dashboard-container {
        min-height: 100vh;
        padding: 4px;
        max-width: 1400px;
        margin: 0 auto;
        background: transparent;
    }
    
    /* HEADER - COMPACT */
    .dashboard-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 6px;
        padding: 4px 8px;
        margin-bottom: 1px;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.06), 0 2px 6px rgba(0, 0, 0, 0.03);
        border: 1px solid rgba(59, 130, 246, 0.2);
        position: relative;
        backdrop-filter: blur(20px);
    }
    
    .dashboard-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        border-radius: 12px 12px 0 0;
        opacity: 0.9;
    }
    
    @keyframes shimmer {
        0% { background-position: -200% 0; }
        100% { background-position: 200% 0; }
    }
    
    .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .header-title h1 {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        line-height: 1.1;
        letter-spacing: -0.025em;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .header-subtitle {
        color: #64748b;
        font-size: 0.7rem;
        margin-top: 2px;
        font-weight: 400;
    }
    
    .live-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        box-shadow: 0 2px 6px rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .live-dot {
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    .header-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }
    
    .refresh-btn, .export-btn, .back-btn {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.65rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        text-decoration: none;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(8px);
        text-transform: uppercase;
        letter-spacing: 0.02em;
        min-height: 24px;
        white-space: nowrap;
    }
    
    .refresh-btn {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(59, 130, 246, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .refresh-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(37, 99, 235, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .export-btn {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        box-shadow: 0 3px 10px rgba(16, 185, 129, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .export-btn:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4), 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    
    .refresh-btn:active, .export-btn:active, .back-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .refresh-btn:active {
        box-shadow: 0 1px 3px rgba(59, 130, 246, 0.4);
    }
    
    .export-btn:active {
        box-shadow: 0 1px 3px rgba(16, 185, 129, 0.4);
    }
    
    .back-btn:active {
        box-shadow: 0 1px 3px rgba(107, 114, 128, 0.4);
    }
    
    .back-btn {
        background: rgba(248, 250, 252, 0.9);
        color: #475569;
        box-shadow: 0 2px 8px rgba(107, 114, 128, 0.15), 0 1px 3px rgba(0, 0, 0, 0.06);
        border: 1px solid #e2e8f0;
    }
    
    .back-btn:hover {
        background: rgba(241, 245, 249, 0.95);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(107, 114, 128, 0.2), 0 2px 6px rgba(0, 0, 0, 0.08);
        text-decoration: none;
        color: #334155;
    }
    
    /* HEADER STATS CARDS - COMPACT */
    .header-stats-grid {
        display: flex;
        gap: 6px;
        align-items: center;
        margin-right: 8px;
    }
    
    .header-stat-card {
        display: flex;
        align-items: center;
        gap: 3px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid rgba(59, 130, 246, 0.15);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.04), 0 1px 4px rgba(0, 0, 0, 0.02);
        min-width: 70px;
        min-height: 24px;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
    }
    
    .header-stat-icon {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        flex-shrink: 0;
    }
    
    .header-stat-info {
        display: flex;
        flex-direction: column;
        gap: 0;
    }
    
    .header-stat-title {
        font-size: 0.55rem;
        color: #6b7280;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        line-height: 1;
    }
    
    .header-stat-value {
        font-size: 0.75rem;
        font-weight: 700;
        color: #1f2937;
        line-height: 1;
    }
    
    .header-stat-card:hover {
        transform: translateY(-2px);
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08), 0 4px 12px rgba(0, 0, 0, 0.06);
        border-color: rgba(59, 130, 246, 0.25);
    }
    
    .header-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    /* DATE FILTER SECTION */
    .filter-section {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 2px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .filter-content {
        display: flex;
        align-items: end;
        gap: 1px;
        flex: 1;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .filter-label {
        font-size: 0.9rem;
        font-weight: 600;
        color: #374151;
    }

    .filter-input {
        padding: 8px 12px;
        border: 2px solid #e5e7eb;
        border-radius: 6px;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        min-width: 130px;
    }

    .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }

    .filter-btn {
        padding: 8px 16px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.55rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        align-self: end;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        min-width: 80px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
    }

    .filter-btn:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4), 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .filter-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(59, 130, 246, 0.3);
    }
    
    /* STATS FLEXBOX - More Responsive */
    .stats-grid {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        gap: 6px;
        margin-bottom: 2px;
        width: 100%;
        flex-wrap: wrap;
    }
    
    .stat-card {
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(20px);
        border-radius: 12px;
        padding: 20px 16px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        flex: 1;
        min-width: 200px;
        max-width: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 25px;
    }
    
    .stat-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.18), 0 4px 16px rgba(0, 0, 0, 0.08);
    }
    
    .stat-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
    }
    
    .stat-card:hover::before {
        left: 100%;
    }
    
    .stat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    
    .stat-icon {
        width: 14px;
        height: 14px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
    }
    
    .stat-title {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 600;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .stat-value {
        font-size: 2rem;
        font-weight: 800;
        color: #1f2937;
        margin: 8px 0;
        line-height: 1;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        position: relative;
        z-index: 1;
    }
    
    .stat-change {
        font-size: 0.8rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 4px;
    }
    
    .stat-change.positive {
        color: #10b981;
    }
    
    .stat-change.neutral {
        color: #6b7280;
    }
    
    /* Circular Progress Indicators */
    .stat-visual {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 16px 0;
        position: relative;
    }
    
    .circular-progress {
        position: relative;
        width: 12px;
        height: 12px;
    }
    
    .circular-progress svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }
    
    .progress-bg {
        fill: none;
        stroke: rgba(0, 0, 0, 0.1);
        stroke-width: 1.5;
    }
    
    .progress-fill {
        fill: none;
        stroke-width: 1.5;
        stroke-linecap: round;
        transition: stroke-dasharray 1.5s ease-in-out;
    }
    
    .progress-customers {
        stroke: url(#gradient-customers);
    }
    
    .progress-runs {
        stroke: url(#gradient-runs);
    }
    
    .progress-trackers {
        stroke: url(#gradient-trackers);
    }
    
    .progress-value {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.95rem;
        font-weight: 700;
        color: #1f2937;
    }
    
    /* Animated dots decoration */
    .stat-decoration {
        position: absolute;
        top: 0;
        right: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
    }
    
    .floating-dots {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        opacity: 0.3;
        animation: floatDots 3s ease-in-out infinite;
    }
    
    .dot-1 {
        top: 20%;
        right: 15%;
        background: #cbd5e1;
        animation-delay: 0s;
    }
    
    .dot-2 {
        top: 60%;
        right: 25%;
        background: #10b981;
        animation-delay: 0.5s;
    }
    
    .dot-3 {
        top: 40%;
        right: 8%;
        background: #f59e0b;
        animation-delay: 1s;
    }
    
    @keyframes floatDots {
        0%, 100% {
            transform: translateY(0px) scale(1);
            opacity: 0.3;
        }
        50% {
            transform: translateY(-8px) scale(1.2);
            opacity: 0.6;
        }
    }
    
    /* Professional stat card layout */
    .stat-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .stat-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .stat-info {
        flex: 1;
    }
    
    /* PROFESSIONAL TRACKING GRAPH */
    .tracking-graph-container {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
        backdrop-filter: blur(24px);
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 1px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.4);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    .tracking-graph-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #e2e8f0 0%, #cbd5e1 50%, #f1f5f9 100%);
        border-radius: 16px 16px 0 0;
        opacity: 0.8;
    }
    
    .tracking-graph-container:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.12), 
                    0 8px 16px rgba(0, 0, 0, 0.07);
    }
    
    .tracking-graph-title {
        font-size: 1.4rem;
        font-weight: 800;
        background: linear-gradient(135deg, #1e293b 0%, #64748b 60%, #94a3b8 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 20px 0;
        letter-spacing: -0.01em;
        line-height: 1.2;
        position: relative;
        z-index: 1;
    }
    
    .tracking-graph {
        display: flex;
        align-items: end;
        gap: 1px;
        height: 45px;
        padding: 4px 8px;
        background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
        border-radius: 6px;
        position: relative;
        z-index: 1;
        overflow-x: auto;
        overflow-y: hidden;
    }
    
    /* Dynamic sizing for tracking graphs based on content */
    .tracking-graph-container.dynamic {
        min-width: 400px;
        flex: none;
    }
    
    .tracking-graph-container.compact {
        min-width: 300px;
        max-width: 600px;
    }
    
    .tracking-graph-container.expanded {
        min-width: 800px;
        max-width: none;
    }
    
    .tracking-graph::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
    }
    
    .graph-bar {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 70px;
        position: relative;
    }
    
    .bar {
        width: 50%;
        background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        border-radius: 8px 8px 4px 4px;
        min-height: 6px;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        box-shadow: 0 4px 12px rgba(203, 213, 225, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
        cursor: pointer;
    }
    
    .bar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.3) 100%);
        border-radius: 8px 8px 0 0;
    }
    
    .bar:hover {
        background: linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%);
        transform: translateY(-4px) scaleY(1.08) scaleX(1.1);
        box-shadow: 0 8px 20px rgba(148, 163, 184, 0.4),
                    0 4px 8px rgba(148, 163, 184, 0.2);
    }
    
    .bar-value {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.8rem;
        font-weight: 700;
        color: #1e293b;
        opacity: 0;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .bar:hover .bar-value {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
    }
    
    .month-label {
        margin-top: 12px;
        font-size: 0.8rem;
        color: #64748b;
        font-weight: 600;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        transition: color 0.3s ease;
    }
    
    .graph-bar:hover .month-label {
        color: #4f46e5;
        font-weight: 700;
    }
    
    /* PROFESSIONAL CHART LOADING */
    .tracking-graph .loading {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        color: #64748b;
        font-weight: 500;
    }
    
    .tracking-graph .spinner {
        width: 32px;
        height: 32px;
        border: 3px solid rgba(203, 213, 225, 0.1);
        border-radius: 50%;
        border-top: 3px solid #cbd5e1;
        border-right: 3px solid #94a3b8;
        animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
        box-shadow: 0 0 20px rgba(203, 213, 225, 0.3);
    }
    
    /* PROFESSIONAL CHART ANIMATIONS */
    @keyframes chartSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .tracking-graph-container {
        animation: chartSlideUp 0.8s ease-out;
    }
    
    .bar {
        animation: chartSlideUp 0.6s ease-out;
        animation-fill-mode: both;
    }
    
    .graph-bar:nth-child(1) .bar { animation-delay: 0.1s; }
    .graph-bar:nth-child(2) .bar { animation-delay: 0.2s; }
    .graph-bar:nth-child(3) .bar { animation-delay: 0.3s; }
    .graph-bar:nth-child(4) .bar { animation-delay: 0.4s; }
    .graph-bar:nth-child(5) .bar { animation-delay: 0.5s; }
    .graph-bar:nth-child(6) .bar { animation-delay: 0.6s; }
    
    /* CUSTOMER OVERVIEW */
    .customer-section {
        margin-top: 2px;
        margin-bottom: 2px;
    }
    
    .section-header {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 6px 6px 0 0;
        padding: 3px 8px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-bottom: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        overflow: hidden;
        flex-wrap: wrap;
        gap: 6px;
    }
    
    .section-header-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    .customer-filter-section {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        border-radius: 6px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        backdrop-filter: blur(20px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.04);
    }
    
    .customer-filter-section .filter-group {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        margin: 0;
    }
    
    .customer-filter-section .filter-label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #6b7280;
        margin: 0;
        white-space: nowrap;
        min-width: auto;
    }
    
    .customer-filter-section .filter-input {
        padding: 4px 8px;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        font-size: 0.8rem;
        min-width: 110px;
        max-width: 130px;
        transition: all 0.2s ease;
    }
    
    .customer-filter-section .filter-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .filter-divider {
        width: 1px;
        height: 20px;
        background: rgba(0, 0, 0, 0.1);
        margin: 0 4px;
    }
    
    .customer-filter-section .filter-btn,
    .customer-filter-section .download-btn {
        padding: 5px 8px;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        font-size: 0.6rem;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        white-space: nowrap;
        min-width: 55px;
    }
    
    .customer-filter-section .filter-btn {
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: white;
        box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3), 0 1px 4px rgba(59, 130, 246, 0.2);
    }
    
    .customer-filter-section .download-btn {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        color: white;
        box-shadow: 0 1px 4px rgba(5, 150, 105, 0.3);
    }
    
    .customer-filter-section .filter-btn:hover {
        background: linear-gradient(135deg, #1d4ed8, #2563eb);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.25), 0 3px 10px rgba(59, 130, 246, 0.15);
    }
    
    .customer-filter-section .download-btn:hover {
        background: linear-gradient(135deg, #047857 0%, #065f46 100%);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4);
    }
    
    .customer-filter-section .filter-btn:active,
    .customer-filter-section .download-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .section-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #34d399 100%);
        opacity: 0.8;
    }
    
    .section-title {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0;
        letter-spacing: -0.02em;
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .customer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 0;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 16px 16px;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
        max-height: 600px;
        overflow-y: auto;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.08);
    }
    
    .customer-card {
        padding: 20px;
        border-right: 1px solid rgba(0, 0, 0, 0.05);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        transition: background-color 0.3s ease;
    }
    
    .customer-card:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 4px solid #3b82f6;
        transform: translateX(4px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.08);
    }
    
    .customer-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 12px;
    }
    
    .customer-stats {
        margin-bottom: 16px;
    }
    
    .stats-header {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 12px;
    }
    
    .customer-stat {
        text-align: center;
        padding: 8px;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(96, 165, 250, 0.05));
        border-radius: 8px;
        border: 1px solid rgba(59, 130, 246, 0.1);
    }
    
    .customer-stat-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: #1e40af;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .customer-stat-label {
        font-size: 0.7rem;
        color: #6b7280;
        text-transform: uppercase;
        font-weight: 600;
    }
    
    /* TABLE CONTAINER - Light & Compact */
    .table-container {
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(20px);
        border-radius: 0 0 8px 8px;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.06), 0 2px 8px rgba(0, 0, 0, 0.04);
        overflow: hidden;
        border: 1px solid rgba(59, 130, 246, 0.2);
        border-top: none;
    }
    
    /* CUSTOMER TABLE */
    .customer-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.875rem;
    }
    
    .customer-table thead {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(96, 165, 250, 0.05) 100%);
        color: #1e40af;
        position: relative;
        font-weight: 600;
    }
    
    .customer-table thead::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.4), transparent);
    }
    
    .customer-table th {
        padding: 4px 6px;
        text-align: left;
        font-weight: 600;
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .customer-table td {
        padding: 3px 6px;
        border-bottom: 1px solid #e5e7eb;
        vertical-align: middle;
        font-size: 0.7rem;
        line-height: 1.2;
    }
    
    .customer-table tbody tr:hover {
        background: linear-gradient(145deg, rgba(59, 130, 246, 0.02), rgba(96, 165, 250, 0.02));
        border-left: 3px solid #3b82f6;
        transform: translateX(2px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .customer-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    /* TABLE COLUMN STYLES - COMPACT */
    .customer-col {
        width: 160px;
        min-width: 120px;
    }
    
    .networks-col {
        width: 180px;
        min-width: 140px;
        max-width: 200px;
    }
    
    .info-col {
        width: 60px;
        text-align: center;
        font-size: 0.65rem;
        font-weight: 500;
        padding: 2px 4px;
    }
    
    .month-col {
        width: 45px;
        text-align: center;
        font-size: 0.6rem;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        color: #374151 !important;
        padding: 2px 3px;
    }
    
    .total-col {
        width: 70px;
        text-align: center;
        font-weight: 600;
        background-color: rgba(16, 185, 129, 0.05);
        font-size: 0.7rem;
        padding: 2px 4px;
    }
    
    /* CUSTOMER NAME CELL - COMPACT */
    .customer-name-cell {
        font-weight: 600;
        color: #1f2937;
        font-size: 0.75rem;
        padding: 2px;
        max-width: 180px;
    }
    
    .customer-name-container {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    
    .customer-name-main {
        font-weight: 700;
        color: #1f2937;
        font-size: 0.75rem;
        line-height: 1.1;
    }
    
    .customer-last-run {
        font-size: 0.6rem;
        color: #6b7280;
        font-weight: 500;
        line-height: 1;
    }
    
    /* NETWORKS CELL - COMPACT */
    .networks-cell {
        font-size: 0.65rem;
        color: #6b7280;
        line-height: 1.2;
        max-width: 180px;
        padding: 2px 6px;
    }
    
    .networks-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .networks-header {
        display: flex;
        align-items: center;
        margin-bottom: 2px;
    }
    
    .network-count-badge {
        background: #f3f4f6;
        color: #374151;
        padding: 1px 6px;
        border-radius: 8px;
        font-size: 0.6rem;
        font-weight: 600;
        text-transform: uppercase;
        line-height: 1;
    }
    
    .networks-list {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    
    .network-item-row {
        display: flex;
        align-items: center;
    }
    
    .network-tag {
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        background: #e0e7ff;
        color: #3730a3;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.6rem;
        font-weight: 500;
        border: 1px solid #c7d2fe;
        min-width: 0;
        max-width: 160px;
        gap: 4px;
        line-height: 1;
    }
    
    .network-name {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        min-width: 0;
    }
    
    .network-runs-count {
        background: #3730a3;
        color: white;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.55rem;
        font-weight: 600;
        min-width: 14px;
        text-align: center;
        flex-shrink: 0;
        line-height: 1;
    }
    
    .no-networks {
        color: #9ca3af;
        font-style: italic;
        font-size: 0.7rem;
    }
    
    /* CUSTOMER SUMMARY ROWS */
    .customer-summary-row {
        background-color: #f8fafc;
        border-left: 4px solid #3b82f6;
        font-weight: 600;
    }
    
    .customer-summary-row:hover {
        background-color: #f1f5f9;
    }
    
    .customer-summary .customer-name-main {
        font-size: 1rem;
        font-weight: 700;
        color: #1e40af;
    }
    
    .network-count-badge-large {
        background: #3b82f6;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .customer-summary .run-count {
        font-weight: 700;
        background-color: rgba(59, 130, 246, 0.1);
    }
    
    .customer-summary .total-runs-cell {
        background-color: rgba(59, 130, 246, 0.2);
        font-weight: 800;
        color: #1e40af;
    }
    
    /* NETWORK DETAIL ROWS */
    .network-detail-row {
        background-color: #ffffff;
        border-left: 2px solid #e5e7eb;
    }
    
    .network-detail-row:hover {
        background-color: #f9fafb;
    }
    
    .network-detail .network-name-main {
        font-size: 0.85rem;
        color: #6b7280;
        font-weight: 500;
        padding-left: 8px;
    }
    
    .network-type {
        font-size: 0.65rem;
        color: #9ca3af;
        font-weight: 400;
        padding-left: 16px;
        font-style: italic;
    }
    
    .network-runs-badge {
        background: #10b981;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65rem;
        font-weight: 600;
    }
    
    .network-detail .run-count {
        font-size: 0.8rem;
        color: #6b7280;
    }
    
    .network-detail .total-runs-cell {
        background-color: rgba(16, 185, 129, 0.1);
        color: #059669;
        font-weight: 600;
    }
    
    /* MONTH RUN COUNTS */
    .run-count {
        text-align: center;
        font-weight: 600;
        color: #059669;
    }
    
    .run-count.zero {
        color: #9ca3af;
    }
    
    .run-count.high {
        color: #dc2626;
        background-color: rgba(220, 38, 38, 0.1);
        border-radius: 4px;
        padding: 2px 4px;
    }
    
    /* TOTAL RUNS CELL */
    .total-runs-cell {
        text-align: center;
        font-weight: 700;
        font-size: 1rem;
        color: #10b981;
        background-color: rgba(16, 185, 129, 0.1);
    }
    
    .customer-networks {
        margin-top: 8px;
    }
    
    .network-badge {
        display: inline-block;
        background: #e5e7eb;
        color: #374151;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        margin: 2px;
    }
    
    .last-run {
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 8px;
    }
    
    /* CHARTS */
    .chart-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        margin-bottom: 30px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .chart-title {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 20px;
        text-align: center;
    }
    
    /* EXCEL EXPORT MODAL */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
    }
    
    .modal-content {
        background: white;
        margin: 5% auto;
        padding: 30px;
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        position: relative;
        box-shadow: 0 20px 80px rgba(0, 0, 0, 0.2);
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .modal-title {
        font-size: 1.4rem;
        font-weight: 700;
        color: #1f2937;
        margin: 0;
    }
    
    .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    
    .close:hover {
        background: #f3f4f6;
        color: #374151;
    }
    
    .form-group {
        margin-bottom: 20px;
    }
    
    .form-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #374151;
        font-size: 0.9rem;
    }
    
    .form-input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.3s ease;
    }
    
    .form-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        outline: none;
    }
    
    .form-checkbox {
        margin-right: 8px;
    }
    
    .export-options {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
    }
    
    .export-option {
        display: flex;
        align-items: center;
        padding: 12px;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .export-option:hover {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.05);
    }
    
    .export-option.selected {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.1);
    }
    
    .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 24px;
    }
    
    .btn-cancel, .btn-export {
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: all 0.3s ease;
    }
    
    .btn-cancel {
        background: #6b7280;
        color: white;
    }
    
    .btn-cancel:hover {
        background: #4b5563;
    }
    
    .btn-export {
        background: #10b981;
        color: white;
    }
    
    .btn-export:hover {
        background: #059669;
    }
    
    /* LOADING STATES */
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    
    .spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #e5e7eb;
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
    }
    
    .spinner.white {
        border: 2px solid #ffffff;
        border-top-color: transparent;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        }
        70% {
            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        }
    }
    
    /* RESPONSIVE */
    @media (max-width: 768px) {
        .dashboard-container {
            padding: 10px;
        }
        
        .header-content {
            flex-direction: column;
            text-align: center;
        }

        .filter-content {
            flex-direction: column;
            align-items: stretch;
        }

        .filter-group {
            width: 100%;
        }

        .filter-input {
            min-width: auto;
            width: 100%;
        }
        
        .stats-grid {
            flex-direction: column;
            justify-content: center;
            gap: 12px;
        }
        
        .stat-card {
            min-width: 100%;
            max-width: none;
            padding: 16px 12px;
        }
        
        .stat-value {
            font-size: 1.5rem;
        }
        
        .stat-icon {
            width: 28px;
            height: 28px;
            font-size: 1.2rem;
        }
        
        .charts-grid {
            grid-template-columns: 1fr;
        }
        
        .charts-row {
            flex-direction: column !important;
            gap: 16px !important;
        }
        
        .tracking-graph-container {
            min-width: auto !important;
            flex: none !important;
        }
        
        .tracking-graph-container {
            padding: 16px !important;
        }
        
        /* Dynamic sizing adjustments for mobile */
        .tracking-graph-container.expanded,
        .tracking-graph-container.dynamic {
            min-width: auto !important;
            max-width: none !important;
        }
        
        .tracking-graph {
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch;
        }
        
        .tracking-graph-title {
            font-size: 1.2rem !important;
        }
        
        .tracking-graph {
            height: 120px !important;
            padding: 12px 4px !important;
        }
        
        .table-container {
            overflow-x: auto;
        }
        
        .customer-table {
            min-width: 700px;
        }
        
        .customer-table th,
        .customer-table td {
            padding: 2px 4px;
            font-size: 0.65rem;
        }
        
        .month-col {
            width: 35px;
        }
        
        .customer-col {
            width: 130px;
            min-width: 100px;
        }
        
        .networks-col {
            width: 150px;
            min-width: 120px;
        }
        
        .info-col {
            width: 50px;
        }
        
        .modal-content {
            width: 95%;
            margin: 10% auto;
            padding: 20px;
        }
        
        .section-header-controls {
            flex-direction: column;
            gap: 16px;
            align-items: stretch;
        }
        
        .customer-filter-section {
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
            padding: 6px 8px;
        }
        
        .customer-filter-section .filter-group {
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }
        
        .customer-filter-section .filter-input {
        min-width: 140px;
            max-width: 120px;
        }
        
        .customer-filter-section .filter-btn,
        .customer-filter-section .download-btn {
            min-width: 60px;
            padding: 5px 8px;
            font-size: 0.65rem;
        }
        
        .filter-divider {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Add CSRF token for API calls -->
{% csrf_token %}
<div class="dashboard-container">
    <!-- DASHBOARD HEADER -->
    <div class="dashboard-header">
        <div class="header-content">
            <div class="header-title">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z" fill="url(#gradient)"/>
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#1e40af"/>
                            <stop offset="100%" style="stop-color:#3b82f6"/>
                        </linearGradient>
                    </defs>
                </svg>
                <div>
                    <h1>Customer Dashboard</h1>
                    <div class="header-subtitle">Network Health Check Management & Analytics</div>
                </div>
                <div class="live-badge">
                    <div class="live-dot"></div>
                    Live Updates
                </div>
            </div>
            
            <div class="header-controls">
                <!-- STATS CARDS IN HEADER -->
                <div class="header-stats-grid">
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white;">
                            üë•
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">CUSTOMERS</div>
                            <div class="header-stat-value" id="header-total-customers">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white;">
                            üèÉ‚Äç‚ôÇÔ∏è
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TOTAL RUNS</div>
                            <div class="header-stat-value" id="header-total-runs">--</div>
                        </div>
                    </div>
                    
                    <div class="header-stat-card">
                        <div class="header-stat-icon" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white;">
                            üìà
                        </div>
                        <div class="header-stat-info">
                            <div class="header-stat-title">TRACKERS</div>
                            <div class="header-stat-value" id="header-total-trackers">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- EXPORT AND BACK BUTTONS -->
                <div class="header-buttons">
                    <button class="export-btn" onclick="directExcelDownload()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                        </svg>
                        Export
                    </button>
                    <a href="{% url 'customer_selection' %}" class="back-btn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                        </svg>
                        Back
                    </a>
                </div>
            </div>
        </div>
    </div>

    
    <!-- CHARTS SECTION -->
    <div class="charts-row" style="
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
        margin: 0;
        justify-content: space-between;
        align-items: stretch;
    ">
        <!-- LAST 6 MONTHS TRACKING GRAPH -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 6px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" style="font-size: 0.8rem; margin: 0 0 2px 0;">üìà Last 6 Months Activity</h3>
            <div class="tracking-graph" id="tracking-graph" style="height: 45px;">
                <!-- Graph will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading tracking data...</span>
                </div>
            </div>
        </div>
        
        <!-- CUSTOMER MONTHLY BREAKDOWN CHART -->
        <div class="tracking-graph-container" style="flex: 1; min-width: 240px; padding: 6px; background: rgba(248, 250, 252, 0.95); border-radius: 6px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);">
            <h3 class="tracking-graph-title" id="customer-chart-title" style="font-size: 0.8rem; margin: 0 0 2px 0;">üë• Active Customers - Loading...</h3>
            <div class="tracking-graph" id="customer-month-chart" style="height: 45px;">
                <!-- Customer monthly chart will be populated by JavaScript -->
                <div class="loading" style="width: 100%; display: flex; justify-content: center; align-items: center; height: 35px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Loading customer data...</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- CUSTOMER OVERVIEW -->
    <div class="customer-section">
        <div class="section-header">
            <h2 class="section-title">Customer Overview</h2>
           <a href="{% url 'customer_dashboard_excel_page' %}" class="filter-btn" id="nav-to-excel-btn" style="margin-left: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; font-weight: 700; text-decoration: none;" onclick="console.log('Navigation to Excel page triggered');">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 4px;">
        <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
    </svg>
    Summary
</a>
            <div class="section-header-controls">
                <!-- Date Filter Controls -->
                <div class="customer-filter-section">
                    <div class="filter-group">
                        <label class="filter-label">From</label>
                        <input type="date" id="customer-start-date" class="filter-input">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">To</label>
                        <input type="date" id="customer-end-date" class="filter-input">
                    </div>
                    <div class="filter-divider"></div>
                    <button class="filter-btn" onclick="applyCustomerFilter()">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                        </svg>
                        Filter
                    </button>
                    <button class="filter-btn" onclick="clearFilter()" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                        Clear
                    </button>
                    <button class="download-btn" onclick="downloadFilteredData()">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                        </svg>
                        Download
                    </button>
                    <button class="filter-btn" onclick="openBulkEditModal()" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7m-5.5-9.5L18 7.5m0 0L7.5 18M18 7.5H12M18 7.5v6"/>
                        </svg>
                        Edit
                    </button>
                    <button class="filter-btn" onclick="revertAllChanges()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                        </svg>
                        Revert
                    </button>
                </div>
                <div class="live-badge">
                    <div class="live-dot"></div>
                    <span id="customer-count">Loading...</span>
                </div>
                
            </div>
        </div>
        <!-- CUSTOMER TABLE -->
        <div class="table-container">
            <table class="customer-table" id="customer-table">
                <thead>
                    <tr>
                        <th class="customer-col">Customer</th>
                        <th class="info-col">Country</th>
                        <th class="networks-col">Networks</th>
                        <th class="info-col">Node Qty</th>
                        <th class="info-col">NE Type</th>
                        <th class="info-col">GTAC</th>
                        <th class="info-col" id="filter-date-header" style="background: #e3f2fd; color: #1976d2; display: none;">Filter Date Range</th>
                        <th class="month-col">Jan</th>
                        <th class="month-col">Feb</th>
                        <th class="month-col">Mar</th>
                        <th class="month-col">Apr</th>
                        <th class="month-col">May</th>
                        <th class="month-col">Jun</th>
                        <th class="month-col">Jul</th>
                        <th class="month-col">Aug</th>
                        <th class="month-col">Sep</th>
                        <th class="month-col">Oct</th>
                        <th class="month-col">Nov</th>
                        <th class="month-col">Dec</th>
                        <th class="total-col">Total Runs</th>
                    </tr>
                </thead>
                <tbody id="customer-table-body">
                    <!-- Customer rows will be populated here -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- EXCEL EXPORT MODAL - HIDDEN (NOT USED ANYMORE) -->
<div id="export-modal" class="modal" style="display: none !important;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Export to Excel</h3>
            <button class="close" onclick="closeExportModal()">&times;</button>
        </div>
        
        <form id="export-form">
            <div class="form-group">
                <label class="form-label">Date Range</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">Start Date</label>
                        <input type="date" id="start-date" class="form-input">
                    </div>
                    <div>
                        <label class="form-label" style="font-size: 0.8rem; color: #6b7280;">End Date</label>
                        <input type="date" id="end-date" class="form-input">
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label class="form-label">Export Options</label>
                <div class="export-options">
                    <div class="export-option selected" data-option="all">
                        <input type="radio" name="export-type" value="all" class="form-checkbox" checked>
                        <label>All Data</label>
                    </div>
                    <div class="export-option" data-option="customer">
                        <input type="radio" name="export-type" value="customer" class="form-checkbox">
                        <label>Customer Details</label>
                    </div>
                </div>
            </div>
        </form>
        
        <div class="modal-actions">
            <button class="btn-cancel" onclick="closeExportModal()">Cancel</button>
            <button class="btn-export" onclick="exportToExcel()">
                <span id="export-text">Export Excel</span>
                <span id="export-spinner" class="spinner white" style="display: none;"></span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
// GLOBAL VARIABLES
let dashboardData = {
    customers: {},
    statistics: {},
    filteredData: {}
};

let refreshInterval;
let currentStartDate = null;
let currentEndDate = null;
let isFilterActive = false; // Track if user has applied a date filter

// GET ACTUAL LAST RUN DATE FOR A CUSTOMER (NEW FUNCTION)
async function getActualLastRunDate(customerName, csrfToken) {
    console.log(`üìÖ Getting ACTUAL last run date for: ${customerName}`);
    
    try {
        // FIRST: Try customer monthly sessions API which might have better date data
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear(),
                include_latest_date: true
            })
        });
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(`üìÖ Monthly sessions API response for ${customerName}:`, monthlyData);
            
            if (monthlyData.latest_run_date && monthlyData.latest_run_date !== '-' && monthlyData.latest_run_date !== 'Never') {
                const actualDate = fixDateParsing(monthlyData.latest_run_date);
                if (actualDate) {
                    const formattedDate = actualDate.toISOString().split('T')[0];
                    console.log(`‚úÖ LATEST RUN from monthly API: ${customerName} -> ${formattedDate}`);
                    return formattedDate;
                }
            }
            
            // Check monthly_sessions for the most recent date
            if (monthlyData.monthly_sessions) {
                let latestDate = null;
                let latestMonth = null;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    if (sessionData.count > 0 && sessionData.date && sessionData.date !== '-') {
                        const sessionDate = fixDateParsing(sessionData.date);
                        if (sessionDate && (!latestDate || sessionDate > latestDate)) {
                            latestDate = sessionDate;
                            latestMonth = month;
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(`‚úÖ LATEST from monthly sessions: ${customerName} -> ${formattedDate} (month ${latestMonth})`);
                    return formattedDate;
                }
            }
        }
        // FIRST: Try customer sessions API to get the most recent session
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                get_latest_only: true,
                include_dates: true,
                force_real_data: true  // Force backend to return actual session data
            })
        });
        
        console.log(`üìÖ API REQUEST: customer-sessions for ${customerName}`);
        if (!sessionsResponse.ok) {
            console.log(`‚ö†Ô∏è API customer-sessions failed with status: ${sessionsResponse.status}`);
        }
        
        if (sessionsResponse.ok) {
            const data = await sessionsResponse.json();
            console.log(`üìÖ Customer sessions response for ${customerName}:`, data);
            
            if (data.latest_session && data.latest_session.created_at) {
                const lastRunDate = fixDateParsing(data.latest_session.created_at);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from ${data.latest_session.created_at})`);
                    return formattedDate;
                }
            }
            
            // Try sessions array if latest_session not available
            if (data.sessions && Array.isArray(data.sessions) && data.sessions.length > 0) {
                // Get the most recent session (sessions should be sorted by date)
                const latestSession = data.sessions[0];
                const lastRunDate = fixDateParsing(latestSession.created_at || latestSession.date || latestSession.timestamp);
                if (lastRunDate) {
                    const formattedDate = lastRunDate.toISOString().split('T')[0];
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from sessions array)`);
                    return formattedDate;
                }
            }
        }
        
        // SECOND: Try to get from customer dashboard API
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const customerData = await customerResponse.json();
            if (customerData.customers && customerData.customers[customerName]) {
                const customer = customerData.customers[customerName];
                if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
                    const lastRunDate = fixDateParsing(customer.last_run_date);
                    if (lastRunDate) {
                        const formattedDate = lastRunDate.toISOString().split('T')[0];
                        console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from customer API)`);
                        return formattedDate;
                    }
                }
            }
        }
        
        // THIRD: Try to get from networks for this customer
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            if (networksData.networks && networksData.networks.length > 0) {
                let latestDate = null;
                
                // Check each network for the latest session date
                for (const network of networksData.networks) {
                    const networkResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: network.id,
                            get_latest_only: true
                        })
                    });
                    
                    if (networkResponse.ok) {
                        const networkData = await networkResponse.json();
                        if (networkData.latest_session_date) {
                            const networkDate = fixDateParsing(networkData.latest_session_date);
                            if (networkDate && (!latestDate || networkDate > latestDate)) {
                                latestDate = networkDate;
                            }
                        }
                    }
                }
                
                if (latestDate) {
                    const formattedDate = latestDate.toISOString().split('T')[0];
                    console.log(`‚úÖ ACTUAL Last Run Date for ${customerName}: ${formattedDate} (from network sessions)`);
                    return formattedDate;
                }
            }
        }
        
        console.log(`‚ö†Ô∏è No actual last run date found for ${customerName}`);
        return null;
        
    } catch (error) {
        console.error(`‚ùå Error getting actual last run date for ${customerName}:`, error);
        return null;
    }
}

// UNIVERSAL DATE FIXING FUNCTION
function fixDateParsing(dateString) {
    if (!dateString || dateString === '-' || dateString === 'Never') {
        return null;
    }
    
    try {
        let fixedDate;
        
        // Handle different date formats
        if (dateString.includes('T')) {
            // ISO format: 2024-09-10T10:30:00Z or 2024-09-10T00:00:00
            fixedDate = new Date(dateString);
        } else if (dateString.includes('-') && dateString.length === 10) {
            // Date format: 2024-09-10 - ADD EXPLICIT TIME to avoid timezone issues
            fixedDate = new Date(dateString + 'T12:00:00');
        } else if (dateString.includes('/')) {
            // US format: 09/10/2024
            fixedDate = new Date(dateString + ' 12:00:00');
        } else {
            // Fallback
            fixedDate = new Date(dateString + ' 12:00:00');
        }
        
        // Verify the date is valid
        if (isNaN(fixedDate.getTime())) {
            console.warn(`‚ö†Ô∏è Could not parse date: ${dateString}`);
            return null;
        }
        
        console.log(`üîß DATE FIX: "${dateString}" -> ${fixedDate.toDateString()} (${fixedDate.getDate()})`);
        return fixedDate;
        
    } catch (error) {
        console.error(`‚ùå Error parsing date "${dateString}":`, error);
        return null;
    }
}

// INITIALIZE DASHBOARD
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOM loaded, initializing dashboard with REAL data only...');
    
    initializeDashboard();
    startLiveUpdates();
    setupExportModal();
    setDefaultDates();
    setDefaultFilterDates();
});

function initializeDashboard() {
    console.log('üöÄ Initializing customer dashboard...');
    showLoadingState();
    // First test what endpoints work
    testEndpoints().then(() => {
        // FILTER FIX: Only load data if no filter is currently active
        if (!isFilterActive) {
            loadDashboardData();
        } else {
            console.log('üìÖ Filter is active, skipping initial load to preserve filtered data');
            hideLoadingState();
        }
    });
}

// Test available endpoints to find what works
async function testEndpoints() {
    console.log('üìû Testing available endpoints...');
    
    const testUrls = [
        '/api/customer-dashboard/customers/',
        '/api/dashboard/statistics/',
        '/api/run-statistics/',
        '/admin/', // Just to test basic connectivity
    ];
    
    for (const url of testUrls) {
        try {
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'same-origin'
            });
            console.log(`üìû ${url} -> ${response.status} ${response.statusText}`);
        } catch (error) {
            console.log(`üìû ${url} -> Error: ${error.message}`);
        }
    }
}

function startLiveUpdates() {
    // AUTO-REFRESH COMMENTED OUT FOR NOW
    /* refreshInterval = setInterval(() => {
        console.log('üîÑ Auto-refreshing dashboard data...');
        loadDashboardData();
    }, 30000); */
    console.log('‚ö†Ô∏è Auto-refresh disabled for now');
}

// LOAD MONTHLY DATA FOR CUSTOMERS WITH DATE FILTERING - ENHANCED FOR CORRECT DATE RETRIEVAL
async function loadMonthlyDataForCustomers(customers, csrfToken, startDate = null, endDate = null) {
    const customersWithMonthly = {};
    const currentYear = new Date().getFullYear();
    
    console.log('üîç Loading monthly data for customers:', Object.keys(customers));
    console.log('üìÖ Date filter applied:', { startDate, endDate });
    
    for (const [customerName, customerData] of Object.entries(customers)) {
        console.log(`üìÖ Processing monthly data for: ${customerName}`);
        
        try {
            // STEP 1: Get the REAL last run date first for this customer
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            
            // Get network-specific run data first (with date filtering)
            const networkRuns = await fetchCustomerNetworkRuns(customerName, csrfToken, startDate, endDate);
            
            // Then get monthly data based on network runs (with date filtering)
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken, startDate, endDate);
            
            // Get network monthly data with dates for each network
            const networkMonthlyData = {};
            for (const [networkName, networkInfo] of Object.entries(networkRuns)) {
                if (networkInfo.id) {
                    try {
                        console.log(`üó∫Ô∏è Getting monthly dates for network: ${networkName}`);
                        const networkResponse = await fetch('/api/network-sessions/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken,
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify({
                                'network_id': networkInfo.id,
                                'cache_bust': Date.now(),  // Force fresh data
                                'include_last_run_date': true  // Request actual last run date
                            })
                        });
                        
                        if (networkResponse.ok) {
                            const networkData = await networkResponse.json();
                            console.log(`üîç RAW API Response for ${networkName}:`, networkData);
                            if (networkData.monthly_sessions) {
                                // Convert to the format expected by frontend
                                const formattedData = {};
                                for (const [month, sessionData] of Object.entries(networkData.monthly_sessions)) {
                                    if (sessionData.count > 0) {
                                        // ENHANCED: Use ACTUAL session dates, not defaults
                                        let correctDate = sessionData.date;
                                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                                            try {
                                                // Parse the ACTUAL date from database
                                                const parsedDate = fixDateParsing(sessionData.date);
                                                if (parsedDate) {
                                                    correctDate = parsedDate.toLocaleDateString('en-US', {
                                                        month: 'short',
                                                        day: 'numeric'
                                                    });
                                                    console.log(`‚úÖ REAL DATE: Original "${sessionData.date}" -> Parsed "${correctDate}"`);
                                                } else {
                                                    correctDate = sessionData.date; // Keep original if parsing fails
                                                }
                                            } catch (error) {
                                                console.warn(`‚ö†Ô∏è Could not parse date: ${sessionData.date}`);
                                                correctDate = sessionData.date;
                                            }
                                        } else {
                                            // NO DEFAULT DATES - only use if we have actual session data
                                            correctDate = '-';
                                            console.log(`üö´ No actual date for month ${month}, keeping as '-'`);
                                        }
                                        
                                        formattedData[parseInt(month)] = {
                                            count: sessionData.count,
                                            date: correctDate,
                                            hasData: true
                                        };
                                    }
                                }
                                networkMonthlyData[networkName] = formattedData;
                                console.log(`‚úÖ Got REAL monthly dates for ${networkName}:`, formattedData);
                            }
                        }
                    } catch (error) {
                        console.error(`‚ùå Error getting monthly data for ${networkName}:`, error);
                    }
                }
            }
            
            // ENHANCED: Copy the original customer data and add CORRECT last run date
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: monthlyData,
                network_runs: networkRuns,
                network_monthly_runs: networkMonthlyData,
                // Use ACTUAL last run date, not fallback to current date
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate  // Keep separate field for debugging
            };
            
            console.log(`‚úÖ Added data for ${customerName}:`);
            console.log(`   Monthly:`, monthlyData);
            console.log(`   Network runs:`, networkRuns);
            console.log(`   ACTUAL Last Run Date: ${actualLastRunDate}`);
            console.log(`   FINAL Last Run Date: ${customersWithMonthly[customerName].last_run_date}`);
            
        } catch (error) {
            console.error(`‚ùå Failed to load data for ${customerName}:`, error);
            
            // ENHANCED: Keep customer data but mark the integration issue
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken).catch(() => null);
            
            customersWithMonthly[customerName] = {
                ...customerData,
                monthly_runs: {}, // Empty monthly data
                network_runs: {}, // Empty network data
                // Still try to get the actual last run date even if monthly data fails
                last_run_date: actualLastRunDate || customerData.last_run_date || 'Never',
                actual_last_run: actualLastRunDate,
                data_integration_error: true // Flag for debugging
            };
            
            console.log(`‚ö†Ô∏è Customer ${customerName} added with minimal data due to error. Last run: ${actualLastRunDate || 'Not found'}`);
        }
    }
    
    return customersWithMonthly;
}

// FETCH ACTUAL NETWORK-WISE RUN DATA FOR A CUSTOMER
async function fetchCustomerNetworkRuns(customerName, csrfToken) {
    try {
        console.log(`üîç Fetching ALL networks and real runs for customer: ${customerName}`);
        
        // Get all networks for this customer using correct API endpoint
        const response = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`üåê Found ${data.networks ? data.networks.length : 0} networks for ${customerName}:`, data.networks);
            
            const networkRuns = {};
            
            if (data.networks && Array.isArray(data.networks)) {
                console.log(`üîç Processing ${data.networks.length} networks for ${customerName}...`);
                
                // Get actual session counts for EACH network
                for (let i = 0; i < data.networks.length; i++) {
                    const network = data.networks[i];
                    const networkName = network.network_name || network.display_name || `${customerName} Network ${i+1}`;
                    const networkId = network.id;
                    
                    console.log(`üîç [${i+1}/${data.networks.length}] Checking network: ${networkName} (ID: ${networkId})`);
                    
                    try {
                        // Get REAL session count for this specific network
                        const realRuns = await getActualNetworkRuns(networkId, csrfToken);
                        networkRuns[networkName] = realRuns;
                        
                        if (realRuns > 0) {
                            console.log(`‚úÖ Network "${networkName}" has ${realRuns} REAL runs`);
                        } else {
                            console.log(`‚ö™ Network "${networkName}" has 0 runs`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error getting real runs for network ${networkName}:`, error);
                        networkRuns[networkName] = 0;
                    }
                    
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log(`‚úÖ Final network breakdown for ${customerName}:`, networkRuns);
                const totalRuns = Object.values(networkRuns).reduce((sum, runs) => sum + runs, 0);
                console.log(`üìà Total runs across all networks: ${totalRuns}`);
                
                return networkRuns;
            } else {
                console.log(`‚ö†Ô∏è No networks array found for ${customerName}`);
            }
        } else {
            console.error(`‚ùå Failed to fetch networks for ${customerName}. Status: ${response.status}`);
        }
    } catch (error) {
        console.error(`‚ùå Error fetching network runs for ${customerName}:`, error);
    }
    
    console.log(`‚ùå Returning empty network data for ${customerName}`);
    return {};
}

// GET ACTUAL RUN COUNT FOR A SPECIFIC NETWORK ID FROM DATABASE
async function getActualNetworkRuns(networkId, csrfToken) {
    try {
        console.log(`üî¢ Getting REAL session count for network ID: ${networkId}`);
        
        // Use the new network sessions API
        const response = await fetch('/api/network-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                network_id: parseInt(networkId)
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`‚úÖ Real session data for network ${networkId}:`, data);
            return data.total_sessions || 0;
        } else {
            console.log(`‚ùå Network sessions API failed with status: ${response.status}`);
            const errorText = await response.text();
            console.log(`Error details: ${errorText}`);
            return 0;
        }
        
    } catch (error) {
        console.error(`‚ùå Error getting real sessions for network ${networkId}:`, error);
        return 0;
    }
}

// FALLBACK: Get network runs from existing statistics
async function getNetworkRunsFromStats(networkId, csrfToken) {
    try {
        console.log(`üîÑ Fallback: Getting network ${networkId} runs from statistics`);
        
        const response = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            const data = await response.json();
            // Use total_runs and distribute based on network priority
            const totalRuns = data.total_runs || 0;
            
            if (totalRuns > 0) {
                // Network ID 1 gets most runs, others get proportional amounts
                if (networkId === 1) {
                    return Math.ceil(totalRuns * 0.7); // 70% to primary
                } else if (networkId === 2) {
                    return Math.ceil(totalRuns * 0.2); // 20% to secondary  
                } else if (networkId === 3) {
                    return Math.ceil(totalRuns * 0.1); // 10% to tertiary
                }
            }
        }
        
        return 0;
        
    } catch (error) {
        console.error(`‚ùå Fallback method failed:`, error);
        return 0;
    }
}

// FETCH REAL MONTHLY RUNS FROM DATABASE SESSIONS USING ACTUAL DATES WITH DATE FILTERING
async function fetchCustomerMonthlyRuns(customerName, year, csrfToken, startDate = null, endDate = null) {
    const monthlyRuns = {};
    
    // Initialize all months to 0
    for (let month = 1; month <= 12; month++) {
        monthlyRuns[month] = 0;
    }
    
    console.log(`üìÖ Getting REAL monthly session data for ${customerName} in ${year}`);
    console.log(`üìÖ Date filter: ${startDate} to ${endDate}`);
    
    try {
        // FIRST: Try to get real session dates from session history API
        const sessionsResponse = await fetch('/api/customer-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                include_dates: true,
                year: year,
                start_date: startDate,
                end_date: endDate
            })
        });
        
        if (sessionsResponse.ok) {
            const sessionsData = await sessionsResponse.json();
            console.log(`üìÖ REAL session data for ${customerName}:`, sessionsData);
            
            // Process each session and count by month using REAL dates
            if (sessionsData.sessions && Array.isArray(sessionsData.sessions)) {
                console.log(`üìÖ Processing ${sessionsData.sessions.length} REAL sessions for ${customerName}`);
                
                sessionsData.sessions.forEach((session, index) => {
                    const sessionDate = new Date(session.created_at || session.date || session.timestamp);
                    const sessionYear = sessionDate.getFullYear();
                    const sessionMonth = sessionDate.getMonth() + 1;
                    
                    // ENHANCED: Only count sessions that match the filtering criteria
                    if (sessionYear === year) {
                        // Additional date filtering if startDate/endDate provided
                        let includeSession = true;
                        if (startDate || endDate) {
                            const sessionDateStr = sessionDate.toISOString().split('T')[0];
                            if (startDate && sessionDateStr < startDate) includeSession = false;
                            if (endDate && sessionDateStr > endDate) includeSession = false;
                        }
                        
                        if (includeSession) {
                            monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                            console.log(`‚úÖ REAL: Session ${index + 1} on ${sessionDate.toDateString()} -> Month ${sessionMonth} (${sessionDate.toISOString().split('T')[0]})`);
                        }
                    }
                });
                
                console.log(`‚úÖ REAL monthly distribution for ${customerName}:`, monthlyRuns);
                return monthlyRuns;
            }
        }
        
        // SECOND: Try the monthly sessions API (with date filtering) - ENHANCED
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: year,
                start_date: startDate,
                end_date: endDate,
                include_actual_dates: true,  // Request actual session dates
                format_dates: true  // Request properly formatted dates
            })
        });
        
        console.log(`üìä API REQUEST: customer-monthly-sessions for ${customerName}`);
        
        if (monthlyResponse.ok) {
            const monthlyData = await monthlyResponse.json();
            console.log(`üìä REAL monthly API data for ${customerName}:`, monthlyData);
            
            if (monthlyData.monthly_sessions) {
                let hasRealData = false;
                
                for (const [month, sessionData] of Object.entries(monthlyData.monthly_sessions)) {
                    const monthNum = parseInt(month);
                    
                    if (sessionData.count > 0) {
                        hasRealData = true;
                        
                        // Enhanced date processing
                        let processedDate = '-';
                        if (sessionData.date && sessionData.date !== '-' && sessionData.date !== 'Never') {
                            // Try to parse and format the date correctly
                            const parsedDate = fixDateParsing(sessionData.date);
                            if (parsedDate) {
                                const day = parsedDate.getDate();
                                const monthName = parsedDate.toLocaleDateString('en-US', { month: 'short' });
                                const yearShort = parsedDate.getFullYear().toString().slice(-2);
                                processedDate = `${day}-${monthName}-${yearShort}`;
                                console.log(`‚úÖ PROCESSED DATE: ${customerName} month ${month}: "${sessionData.date}" -> "${processedDate}"`);
                            } else {
                                console.log(`‚ö†Ô∏è FAILED TO PARSE: ${customerName} month ${month}: "${sessionData.date}"`);
                                processedDate = sessionData.date; // Keep original if parsing fails
                            }
                        }
                        
                        monthlyRuns[monthNum] = {
                            count: sessionData.count,
                            date: processedDate,
                            hasData: true,
                            originalDate: sessionData.date  // Keep original for debugging
                        };
                    } else {
                        monthlyRuns[monthNum] = {
                            count: 0,
                            date: '-',
                            hasData: false
                        };
                    }
                }
                
                if (hasRealData) {
                    console.log(`‚úÖ SUCCESS: Using REAL monthly API data with processed dates for ${customerName}:`, monthlyRuns);
                    return monthlyRuns;
                } else {
                    console.log(`‚ö†Ô∏è NO REAL DATA: ${customerName} monthly API returned no sessions with dates`);
                }
            } else {
                console.log(`‚ö†Ô∏è NO MONTHLY SESSIONS: ${customerName} API response has no monthly_sessions`);
            }
        } else {
            const errorText = await monthlyResponse.text();
            console.log(`‚ùå API FAILED: customer-monthly-sessions for ${customerName} - ${monthlyResponse.status}: ${errorText}`);
        }
        
        // THIRD: Get network sessions with dates as fallback
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
        
    } catch (error) {
        console.error(`‚ùå Error fetching REAL monthly runs for ${customerName}:`, error);
        await fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate, endDate);
    }
    
    return monthlyRuns;
}

// FALLBACK: Get real monthly data using existing APIs with date filtering
async function fetchRealMonthlyDataFallback(customerName, year, monthlyRuns, csrfToken, startDate = null, endDate = null) {
    try {
        console.log(`üîÑ Fallback: Getting session dates for ${customerName} from database`);
        console.log(`üìÖ Fallback date filter: ${startDate} to ${endDate}`);
        
        // Try to get network IDs for this customer first
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const networksData = await networksResponse.json();
            console.log(`üåê Found networks for ${customerName}:`, networksData);
            
            if (networksData.networks && networksData.networks.length > 0) {
                // For each network, get real sessions and their dates
                for (const network of networksData.networks) {
                    const networkId = network.id;
                    console.log(`üîç Getting real sessions for network ID: ${networkId}`);
                    
                    // Get actual sessions for this network
                    const sessionsResponse = await fetch('/api/network-sessions/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken,
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({
                            network_id: parseInt(networkId),
                            include_dates: true
                        })
                    });
                    
                    if (sessionsResponse.ok) {
                        const sessionData = await sessionsResponse.json();
                        console.log(`‚úÖ Real sessions for network ${networkId}:`, sessionData);
                        
                        // If we have session dates, use them for monthly distribution
                        if (sessionData.recent_sessions && sessionData.recent_sessions.length > 0) {
                            console.log(`üìÖ Processing ${sessionData.recent_sessions.length} real sessions...`);
                            
                            sessionData.recent_sessions.forEach(session => {
                                // Use universal date fix function
                                const sessionDate = fixDateParsing(session.created_at);
                                
                                if (sessionDate) {
                                    const sessionMonth = sessionDate.getMonth() + 1;
                                    const sessionYear = sessionDate.getFullYear();
                                    const sessionDay = sessionDate.getDate();
                                    
                                    console.log(`üìÖ SESSION: "${session.created_at}" -> Month: ${sessionMonth}, Day: ${sessionDay}, Year: ${sessionYear}`);
                                    
                                    if (sessionYear === year) {
                                        monthlyRuns[sessionMonth] = (monthlyRuns[sessionMonth] || 0) + 1;
                                        console.log(`‚úÖ Added 1 run to month ${sessionMonth} from session on ${sessionDate.toDateString()} (Day: ${sessionDay})`);
                                    }
                                }
                            });
                        }
                    }
                }
                
                console.log(`‚úÖ Final real monthly distribution for ${customerName}:`, monthlyRuns);
                return;
            }
        }
        
        console.log(`‚ö†Ô∏è Could not get network data for ${customerName}, using basic fallback`);
        
        // ENHANCED: Only use real dates, no fallback to current month
        const customerResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customerResponse.ok) {
            const data = await customerResponse.json();
            const customerData = data.customers[customerName];
            
            if (customerData && customerData.runs > 0) {
                // ONLY assign runs if we have an actual last_run_date from the API
                if (customerData.last_run_date && customerData.last_run_date !== 'Never' && customerData.last_run_date !== '-') {
                    const actualDate = fixDateParsing(customerData.last_run_date);
                    if (actualDate && actualDate.getFullYear() === year) {
                        const actualMonth = actualDate.getMonth() + 1;
                        monthlyRuns[actualMonth] = customerData.runs;
                        console.log(`‚úÖ Using REAL date from API: assigned ${customerData.runs} runs to month ${actualMonth} based on actual date ${customerData.last_run_date}`);
                    } else {
                        console.log(`‚ö†Ô∏è Customer ${customerName} has runs but date is from different year or invalid: ${customerData.last_run_date}`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Customer ${customerName} has ${customerData.runs} runs but NO valid last_run_date - not assigning to any month`);
                }
            }
        }
        
    } catch (error) {
        console.error(`‚ùå Error in real monthly data fallback:`, error);
    }
}

function setDefaultFilterDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    // Set default dates for customer overview filter (but don't apply them automatically)
    const customerStartInput = document.getElementById('customer-start-date');
    const customerEndInput = document.getElementById('customer-end-date');
    
    if (customerStartInput && customerEndInput) {
        customerEndInput.value = today.toISOString().split('T')[0];
        customerStartInput.value = firstDayOfMonth.toISOString().split('T')[0];
    }
    
    // FILTER FIX: Don't automatically set filter dates - let user apply them
    // currentStartDate = firstDayOfMonth.toISOString().split('T')[0];
    // currentEndDate = today.toISOString().split('T')[0];
}

// Duplicate function removed - using the one defined later

// Duplicate function removed - using the one defined later


// INTEGRATED: Load dashboard data from DATABASE + EXCEL SOURCES
// Helper function to generate hash codes for network IDs
String.prototype.hashCode = function() {
    var hash = 0;
    if (this.length === 0) return hash;
    for (var i = 0; i < this.length; i++) {
        var char = this.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
};

async function loadDashboardData(startDate = null, endDate = null) {
    console.log('üöÄ Loading DATABASE + EXCEL CUSTOMERS (Integrated)...');
    
    // CRITICAL FIX: Use current filter dates if no parameters provided
    if (!startDate && !endDate && (currentStartDate || currentEndDate)) {
        startDate = currentStartDate;
        endDate = currentEndDate;
        console.log(`üîÑ Using existing filter dates: ${startDate} to ${endDate}`);
    }
    
    // Store current filter dates for customer overview
    if (startDate && endDate) {
        console.log(`üìÖ Applying date filter to customer data: ${startDate} to ${endDate}`);
        currentStartDate = startDate;
        currentEndDate = endDate;
    }
    
    // Check CSRF token first
    const csrfToken = getCsrfToken();
    if (!csrfToken) {
        console.error('‚ùå No CSRF token found!');
        showNotification('‚ö†Ô∏è Security error: Missing CSRF token. Please refresh the page.', 'error');
        return;
    }
    console.log('üîê CSRF token found:', csrfToken.substring(0, 10) + '...');
    
    try {
        console.log('üì° CALLING DATABASE CUSTOMERS API ONLY...');
        
        // DATABASE ONLY: Load customers from database API with date filtering
        let apiUrl = '/api/customer-dashboard/customers/';
        
        // Add date filtering parameters if provided
        if (startDate || endDate) {
            const params = new URLSearchParams();
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            apiUrl += '?' + params.toString();
            console.log('üìÖ Added date filters to API URL:', apiUrl);
        }
        
        console.log('üì° DASHBOARD API REQUEST WITH FILTERS:', apiUrl);
        
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        console.log('üìä SIMPLE API Response Status:', response.status);
        console.log('üìä SIMPLE API Response Headers:', [...response.headers.entries()]);
        
        if (response.ok) {
            const data = await response.json();
            console.log('üìä SIMPLE API Response Data:', data);
            
            // Check if we have customers data
            if (data.status === 'success' && data.customers) {
                console.log('‚úÖ SUCCESS: Got DATABASE CUSTOMERS from API:', Object.keys(data.customers));
                console.log('üóÑÔ∏è EXCEL DISABLED - Only showing database customers');
                
                // ULTRA STRICT FILTERING - Block ALL Unknown Customers completely
                const filteredCustomers = {};
                console.log('üìù STARTING FILTER PROCESS - Checking all customers...');
                Object.entries(data.customers).forEach(([customerName, customerData]) => {
                    console.log(`üîç CHECKING: ${customerName}`);
                    
                // MODERATE FILTERING - Block only obvious fake entries
                if (customerName.toLowerCase().includes('unknown') ||
                    customerName.toLowerCase().includes('timedotcom') ||
                    customerName.toLowerCase().includes('default') ||
                    customerName === 'Default' ||
                    customerName === 'Timedotcom' ||
                    customerName === 'Timedotcom Default' ||
                    customerName === 'Unknown Customer' ||
                    customerName.startsWith('Unknown') ||
                    customerName.trim().length <= 2) {
                    console.log(`‚ùå BLOCKED Fake/Unknown: ${customerName}`);
                    return; // Exit immediately
                }
                    
                    // SIMPLE CHECK - Allow any customer with some data
                    const hasData = (customerData.runs && customerData.runs > 0) ||
                                   (customerData.total_runs && customerData.total_runs > 0) ||
                                   (customerData.networks && customerData.networks.length > 0);
                    
                    // Keep all customers that have some data (including new ones)
                    filteredCustomers[customerName] = customerData;
                    console.log(`‚úÖ KEEPING DB Customer: ${customerName} - Runs: ${customerData.runs || customerData.total_runs || 0}, Networks: ${customerData.networks?.length || 0}`);
                    
                    if (!hasData) {
                        console.log(`‚ö†Ô∏è Note: ${customerName} has no run data yet`);
                    }
                });
                
                console.log(`üìã FINAL FILTERED RESULTS: ${Object.keys(filteredCustomers).length} real DB customers (blocked all Unknown entries)`);
                console.log(`üéØ REAL CUSTOMERS FOUND:`, Object.keys(filteredCustomers));
                
                if (Object.keys(filteredCustomers).length === 0) {
                    console.log('‚ö†Ô∏è NO REAL CUSTOMERS FOUND - Only Unknown entries were available');
                }
                
                // Store filtered customer data
                dashboardData.customers = filteredCustomers;
                
                // Calculate statistics from FILTERED customer data
                let customerCount = Object.keys(filteredCustomers).length;
                let totalRuns = 0;
                let totalTrackers = 0;
                
                Object.values(filteredCustomers).forEach(customer => {
                    totalRuns += parseInt(customer.runs || customer.total_runs || customer.run_count || 0);
                    totalTrackers += parseInt(customer.trackers_generated || customer.total_trackers || customer.trackers || 0);
                });
                
                console.log(`üìà DATABASE STATS: ${customerCount} customers, ${totalRuns} runs, ${totalTrackers} trackers`);
                
                // STEP 2: EXCEL INTEGRATION COMPLETELY DISABLED
                console.log('üìä Excel integration disabled - using database-only data');
                /*
                // EXCEL INTEGRATION DISABLED - DO NOT LOAD EXCEL DATA
                try {
                    // Pass date filters to Excel API (same as DB API)
                    let excelApiUrl = '/customer-dashboard/excel/';
                    if (startDate && endDate) {
                        const params = new URLSearchParams();
                        params.append('start_date', startDate);
                        params.append('end_date', endDate);
                        excelApiUrl += '?' + params.toString();
                        console.log(`üìä Excel API with filters: ${excelApiUrl}`);
                    }
                    
                    const excelResponse = await fetch(excelApiUrl, {
                        method: 'GET',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (excelResponse.ok) {
                        const excelData = await excelResponse.json();
                        console.log('‚úÖ Excel response received:', Object.keys(excelData));
                        
                        // Extract Excel customers from response
                        let excelCustomers = {};
                        if (excelData.data && excelData.data.customers) {
                            excelCustomers = excelData.data.customers;
                        } else if (excelData.customers) {
                            excelCustomers = excelData.customers;
                        }
                        
                        if (Object.keys(excelCustomers).length > 0) {
                            console.log(`üìÑ Found ${Object.keys(excelCustomers).length} Excel entries:`, Object.keys(excelCustomers));
                            console.log(`üìÖ Excel date filter: ${startDate} to ${endDate || 'No end date'}`);
                            
                            // DEBUG TATA: Check all Excel customers
                            console.log(`üîç Checking for TATA in Excel data...`);
                            Object.entries(excelCustomers).forEach(([key, customer]) => {
                                if (customer.Customer && customer.Customer.toLowerCase().includes('tata')) {
                                    console.log(`üéØ FOUND TATA: ${key} -> Customer: ${customer.Customer}, Network: ${customer.Network}`);
                                }
                            });
                            
                            // GROUPING - Group Excel by Customer name with Networks as sub-parts
                            console.log(`üöÄ Grouping Excel customers by Customer name (like database structure)...`);
                            
                            // Step 1: Group Excel entries by Customer name
                            const customerGroups = {};
                            Object.values(excelCustomers).forEach((excelEntry) => {
                                const customerName = excelEntry.Customer || 'Unknown';
                                const networkName = excelEntry.Network || excelEntry.network || `${customerName}_Network`;
                                
                                if (!customerGroups[customerName]) {
                                    customerGroups[customerName] = {
                                        customerName: customerName,
                                        networks: [],
                                        country: excelEntry.Country || excelEntry.country || '',
                                        ne_type: excelEntry['NE Type'] || excelEntry.ne_type || '1830 PSS',
                                        gtac: excelEntry.gTAC || excelEntry.gtac || 'PSS'
                                    };
                                }
                                
                                // Add this network entry to the customer group
                                customerGroups[customerName].networks.push({
                                    ...excelEntry,
                                    networkName: networkName
                                });
                            });
                            
                            console.log(`üìÅ Grouped ${Object.keys(excelCustomers).length} Excel entries into ${Object.keys(customerGroups).length} customers`);
                            
                            // Step 2: Process each customer group (like database customers)
                            Object.values(customerGroups).forEach((group) => {
                                const customerName = group.customerName;
                                const networkEntries = group.networks;
                                console.log(`\nüîç Processing Excel customer: ${customerName} with ${networkEntries.length} networks`);
                                
                                // BLOCK FAKE ENTRIES
                                if (customerName === 'He' || customerName === 'KYUUII' || 
                                    customerName === 'OPT_NC' || customerName === 'subu-east' ||
                                    customerName === 'Bsnl' || customerName.toLowerCase().includes('unknown')) {
                                    console.log(`   ‚ùå Blocking fake Excel customer: ${customerName}`);
                                    return;
                                }
                                
                                // Apply DATE FILTERING to customer group
                                if (startDate && endDate) {
                                    const filterStart = new Date(startDate).getMonth() + 1; 
                                    const filterEnd = new Date(endDate).getMonth() + 1;
                                    
                                    console.log(`   üìÖ Checking Excel customer date filter: months ${filterStart}-${filterEnd}`);
                                    
                                    // Check if ANY network in this customer has data in filter range
                                    const hasDataInRange = networkEntries.some(networkEntry => {
                                        const months = networkEntry.months || [];
                                        return months.some((monthValue, index) => {
                                            const monthNum = index + 1;
                                            const hasValidData = monthValue && monthValue !== '-' && monthValue !== 'Not Started' && monthValue !== 'Not Run';
                                            const inRange = monthNum >= filterStart && monthNum <= filterEnd;
                                            if (hasValidData && inRange) {
                                                console.log(`     ‚úÖ Network ${networkEntry.networkName} has data in month ${monthNum} (${monthValue})`);
                                            }
                                            return hasValidData && inRange;
                                        });
                                    });
                                    
                                    if (!hasDataInRange) {
                                        console.log(`   ‚ùå Excel customer filtered out: ${customerName} (no networks have data in selected date range)`);
                                        return; // Skip this customer group
                                    }
                                    console.log(`   ‚úÖ Excel customer passes date filter: ${customerName}`);
                                }
                                
                                // Create Excel customer with networks as sub-parts (like database structure)
                                const excelCustomerKey = customerName + "_excel_" + Date.now();
                                console.log(`   ‚ûï Creating grouped Excel customer: ${customerName} with ${networkEntries.length} networks`);
                                
                                // Step 3: Create networks array from all network entries in this customer group
                                let networks = [];
                                let customerTotalRuns = 0;
                                let customerTotalNodes = 0;
                                
                                networkEntries.forEach((networkEntry, index) => {
                                    const networkName = networkEntry.networkName;
                                    console.log(`     üîó Processing network: ${networkName}`);
                                    
                    // Clean up monthly data and fix typos
                    let monthlyRuns = (networkEntry.months || []).map(m => {
                        if (typeof m === 'string') {
                            return m.replace('Not Starte', 'Not Started')
                                    .replace('No Repor', 'No Report')
                                    .replace('No Reportt', 'No Report'); // Fix double 't' typo
                        }
                        return m;
                    });
                    
                    // BSNL specific: Replace Not Started and No Report with dash
                    if (customerName === 'BSNL' || customerName === 'Bsnl') {
                        monthlyRuns = monthlyRuns.map(m => {
                            if (m === 'Not Started' || m === 'No Report') {
                                return '-';
                            }
                            return m;
                        });
                        console.log(`     üîß BSNL: Replaced Not Started/No Report with dash`);
                    }
                                    
                                    // Calculate filtered runs for this network
                                    let networkTotalRuns;
                                    if (startDate && endDate) {
                                        const filterStart = new Date(startDate).getMonth() + 1;
                                        const filterEnd = new Date(endDate).getMonth() + 1;
                                        
                                        networkTotalRuns = monthlyRuns.filter((m, monthIndex) => {
                                            const monthNum = monthIndex + 1;
                                            const hasValidData = m && m !== '-' && 
                                                                m !== 'Not Run' && m !== 'Not Started' && 
                                                                m !== 'No Report' &&
                                                                (m.includes('-') && !m.toLowerCase().includes('not'));
                                            const inRange = monthNum >= filterStart && monthNum <= filterEnd;
                                            return hasValidData && inRange;
                                        }).length;
                                    } else {
                                        networkTotalRuns = monthlyRuns.filter(m => 
                                            m && m !== '-' && 
                                            m !== 'Not Run' && m !== 'Not Started' && 
                                            m !== 'No Report' &&
                                            (m.includes('-') && !m.toLowerCase().includes('not'))
                                        ).length;
                                    }
                                    
                                    const lastRunDate = monthlyRuns.find(m => m !== '-' && m !== 'Not Started') ? 'Recent' : 'Not Started';
                                    const nodeCount = networkEntry['Node Qty'] || networkEntry.node_qty || 0;
                                    
                                    // Add to customer totals
                                    customerTotalRuns += networkTotalRuns;
                                    customerTotalNodes += nodeCount;
                                    
                                    // Create network object (sub-part of customer)
                                    networks.push({
                                        id: (customerName + networkName).hashCode() % 10000,
                                        name: networkName,
                                        network_name: networkName,
                                        Network: networkName,
                                        runs: networkTotalRuns,
                                        total_runs: networkTotalRuns,
                                        last_run_date: lastRunDate,
                                        node_count: nodeCount,
                                        months: monthlyRuns,
                                        monthly_runs: monthlyRuns,
                                        ne_type: networkEntry['NE Type'] || networkEntry.ne_type || '1830 PSS',
                                        gtac: networkEntry.gTAC || networkEntry.gtac || 'PSS',
                                        country: networkEntry.Country || networkEntry.country || group.country,
                                        status: networkTotalRuns > 0 ? 'completed' : 'not started'
                                    });
                                    
                                    console.log(`     ‚úÖ Created network: ${networkName} - Runs: ${networkTotalRuns}, Nodes: ${nodeCount}`);
                                });
                                
                                console.log(`   üìä Customer totals: ${customerTotalRuns} runs, ${customerTotalNodes} nodes from ${networks.length} networks`);
                                
                                
                                // Create grouped Excel customer with SAME FORMAT as DB customers
                                filteredCustomers[excelCustomerKey] = {
                                    // Basic info - SAME AS DB FORMAT
                                    name: customerName,
                                    customer_name: customerName,
                                    
                                    // Run data - AGGREGATED FROM ALL NETWORKS
                                    runs: customerTotalRuns,
                                    total_runs: customerTotalRuns,
                                    run_count: customerTotalRuns,
                                    
                                    // Date info - Use most recent from networks
                                    last_run_date: networks.find(n => n.last_run_date !== 'Not Started')?.last_run_date || 'Never',
                                    actual_last_run: null,
                                    first_run_date: null,
                                    
                                    // Location - Use group data
                                    country: group.country,
                                    location: group.country,
                                    region: '-',
                                    
                                    // Node info - AGGREGATED FROM ALL NETWORKS
                                    node_count: customerTotalNodes,
                                    node_qty: customerTotalNodes,
                                    total_nodes: customerTotalNodes,
                                    nodes: customerTotalNodes,
                                    
                                    // Technical specs - Use group data
                                    ne_type: group.ne_type,
                                    nw_type: group.ne_type,
                                    network_type: group.ne_type,
                                    technology: group.ne_type,
                                    
                                    // GTAC info - Use group data
                                    gtac: group.gtac,
                                    gtac_team: group.gtac,
                                    gtac_type: group.gtac,
                                    
                                    // Networks - MOST IMPORTANT - CONTAINS ALL SUB-NETWORKS
                                    networks: networks,
                                    networks_count: networks.length,
                                    network_count: networks.length,
                                    
                                    // Network-level data - AGGREGATED
                                    network_runs: {},
                                    network_monthly_runs: {},
                                    
                                    // Monthly data - AGGREGATED FROM NETWORKS
                                    monthly_runs: {},
                                    monthly_data: {},
                                    
                                    // Status info - Based on network aggregation
                                    status: networks.every(n => n.runs > 0) ? 'completed' : (networks.some(n => n.runs > 0) ? 'partial' : 'not started'),
                                    active: true,
                                    enabled: true,
                                    
                                    // Trackers - Based on total nodes
                                    trackers_generated: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    trackers: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    total_trackers: Math.max(1, Math.ceil(customerTotalNodes / 10)),
                                    
                                    // Source flags - TO DISTINGUISH FROM DB
                                    excel_only: true,
                                    excel_source: true,
                                    excel_data: true,
                                    data_source: 'excel'
                                };
                                    
                                console.log(`   ‚úÖ Grouped Excel customer created: ${customerName}`);
                                console.log(`     Networks (${networks.length}):`);
                                networks.forEach((net, i) => {
                                    console.log(`       ${i+1}. ${net.name} - Runs: ${net.runs} - Nodes: ${net.node_count} - Status: ${net.status}`);
                                });
                                console.log(`     Total: ${customerTotalRuns} runs, ${customerTotalNodes} nodes`);
                                console.log(`     Customer Status: ${filteredCustomers[excelCustomerKey].status}`);
                                
                                // Update counters with grouped totals
                                customerCount++;
                                totalRuns += customerTotalRuns;
                                totalTrackers += Math.max(1, Math.ceil(customerTotalNodes / 10));
                            });
                            
                            console.log(`\nüìà FINAL SEPARATED STATS: ${customerCount} total customers (DB + Excel separate), ${totalRuns} runs, ${totalTrackers} trackers`);
                        } else {
                            console.log('‚ö†Ô∏è No Excel customers found in response');
                        }
                    } else {
                        console.log('‚ö†Ô∏è Excel API response failed:', excelResponse.status);
                    }
                } catch (excelError) {
                    console.error('‚ùå Excel integration error:', excelError);
                    console.log('‚ö†Ô∏è Continuing with database-only data');
                }
                */
                // END OF COMMENTED EXCEL INTEGRATION
                
                // Update final data with DATABASE-ONLY customers (Excel integration disabled)
                dashboardData.customers = filteredCustomers;
                
                // Store calculated statistics with DATABASE CUSTOMERS ONLY
                dashboardData.statistics = {
                    total_customers: customerCount,
                    total_runs: totalRuns,
                    total_trackers: totalTrackers,
                    current_month_runs: 0,
                    filtered_runs: totalRuns
                };
                
                console.log('‚úÖ Final DATABASE-ONLY statistics:', dashboardData.statistics);
                
                // Update all dashboard components
                updateDashboard();
                
                // CRITICAL FIX: Restore edited data from localStorage AFTER dashboard loads
                setTimeout(() => {
                    restoreEditedData();
                    // Update dashboard again with restored edited data
                    updateDashboard();
                    console.log('üíæ Edited data restored from localStorage');
                }, 500);
                
                hideLoadingState();
                
                const sourceMsg = ' (Database only - Excel integration disabled)';
                const filterMsg = startDate && endDate ? ` (filtered: ${startDate} to ${endDate})` : '';
                showNotification(`‚úÖ Loaded ${customerCount} customers, ${totalRuns} runs${sourceMsg}${filterMsg}`, 'success');
                return;
            } else {
                console.log('‚ö†Ô∏è API returned success but no customer data');
            }
        }
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Excel API Error:', errorText);
            throw new Error(`Excel API failed (${response.status}): ${response.statusText}`);
        }
        
        // Parse the response - it might be JSON data or an Excel file
        let dashboardDataFromExcelAPI;
        
        const contentType = response.headers.get('content-type');
        console.log('üìä Response Content-Type:', contentType);
        
        if (contentType && contentType.includes('application/json')) {
            // Perfect! Got JSON data with the same processing as Excel export
            dashboardDataFromExcelAPI = await response.json();
            console.log('‚úÖ EXCEL API JSON Response:', dashboardDataFromExcelAPI);
        } else {
            // If we get Excel file, we need to use the regular API but with Excel-compatible parameters
            console.log('‚ö†Ô∏è Got Excel file instead of JSON, falling back to regular API with Excel-compatible request...');
            
            // Try the CORRECT API endpoint for customer dashboard with date filtering
            let fallbackApiUrl = '/api/customer-dashboard/customers/';
            if (startDate || endDate) {
                const params = new URLSearchParams();
                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                fallbackApiUrl += '?' + params.toString();
            }
            
            const fallbackResponse = await fetch(fallbackApiUrl, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'same-origin'
            });
            
            console.log('üì° CALLING CORRECT API: /api/customer-dashboard/customers/');
            console.log('üì° Response status:', fallbackResponse.status);
            
            if (fallbackResponse.ok) {
                const customersData = await fallbackResponse.json();
                console.log('üì° Customer Dashboard API Response:', customersData);
                
                // Get statistics too
                const statsResponse = await fetch('/api/dashboard/statistics/', {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/json',
                        'X-Excel-Compatible': 'true'
                    },
                    credentials: 'same-origin'
                });
                
                const statsData = statsResponse.ok ? await statsResponse.json() : {};
                
                dashboardDataFromExcelAPI = {
                    customers: customersData.customers || {},
                    statistics: statsData
                };
            } else {
                throw new Error('Both Excel API and fallback API failed');
            }
        }
        
        
        // Process the data from Excel API (which should have correct dates)
        console.log('üìÖ Processing Excel API data with REAL dates...');
        
        const processedCustomers = {};
        const customers = dashboardDataFromExcelAPI.customers || dashboardDataFromExcelAPI.data?.customers || {};
        
        console.log('üîç Raw customers from Excel API:', customers);
        
        // Process each customer with Excel API data structure
        for (const [customerName, customerData] of Object.entries(customers)) {
            console.log(`üìÖ Processing ${customerName} from API data...`);
            console.log(`üîç RAW DATA for ${customerName}:`, customerData);
            console.log(`üîç Fields available:`, Object.keys(customerData));
            console.log(`üîç node_count = ${customerData.node_count}, country = ${customerData.country}`);
            
            processedCustomers[customerName] = {
                ...customerData,
                // Ensure we preserve the monthly data with actual dates
                monthly_runs: customerData.monthly_runs || {},
                // Preserve network-level data
                network_runs: customerData.network_runs || {},
                network_monthly_runs: customerData.network_monthly_runs || {},
                // Use the actual date fields from Excel API
                last_run_date: customerData.last_run_date || customerData.actual_last_run || 'Never',
                actual_last_run: customerData.actual_last_run || customerData.last_run_date
            };
            
            console.log(`‚úÖ Processed ${customerName}:`, {
                runs: processedCustomers[customerName].runs,
                last_run_date: processedCustomers[customerName].last_run_date,
                monthly_runs: processedCustomers[customerName].monthly_runs
            });
        }
        
        // Use the processed data from Excel API
        dashboardData.customers = processedCustomers;
        dashboardData.statistics = {
            total_customers: dashboardDataFromExcelAPI.statistics?.total_customers || Object.keys(processedCustomers).length,
            total_runs: dashboardDataFromExcelAPI.statistics?.total_runs || 0,
            total_trackers: dashboardDataFromExcelAPI.statistics?.total_trackers || 0,
            current_month_runs: dashboardDataFromExcelAPI.statistics?.current_month_runs || 0,
            filtered_runs: dashboardDataFromExcelAPI.statistics?.filtered_runs || 0
        };
        
        console.log('‚úÖ Successfully loaded data using Excel API method:', {
            customersCount: Object.keys(processedCustomers).length,
            totalCustomers: dashboardData.statistics.total_customers,
            totalRuns: dashboardData.statistics.total_runs,
            sampleCustomer: Object.keys(processedCustomers)[0] ? processedCustomers[Object.keys(processedCustomers)[0]] : 'None'
        });
        
        updateDashboard();
        
        // Show appropriate message based on data
        if (statsData.total_customers === 0) {
            showNotification('‚ÑπÔ∏è No customers found in database. Add customers to see live statistics.', 'info');
        } else {
            const filterMsg = startDate && endDate ? ` (filtered: ${startDate} to ${endDate})` : '';
            showNotification(`‚úÖ Dashboard loaded: ${statsData.total_customers} customers, ${statsData.total_runs} runs${filterMsg}`, 'success');
        }
        
    } catch (error) {
        console.error('‚ùå Dashboard loading error:', error);
        hideLoadingState();
        showNotification('‚ùå Failed to load data. Please try again.', 'error');
    }
}

// LOAD REAL DATA DIRECTLY FROM YOUR DATABASE
async function loadRealDatabaseData() {
    console.log('üìä Loading REAL data from your database...');
    
    try {
        // Try multiple API endpoints to get your real data
        const endpoints = [
            '/api/customer-dashboard/customers/',
            '/api/dashboard/statistics/',
            '/api/run-statistics/',
            '/get-customer-networks/1/' // Try to get data from first customer
        ];
        
        // Test each endpoint
        for (const endpoint of endpoints) {
            try {
                console.log(`üìû Trying endpoint: ${endpoint}`);
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': getCsrfToken(),
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`‚úÖ Success from ${endpoint}:`, data);
                    
                    // If we got customers data, use it
                    if (data.customers) {
                        dashboardData.customers = data.customers;
                    }
                    
                    // If we got statistics, use them
                    if (data.total_customers !== undefined) {
                        dashboardData.statistics = {
                            total_customers: data.total_customers || 0,
                            total_runs: data.total_runs || 0,
                            total_trackers: data.total_trackers || 0,
                            current_month_runs: data.current_month_runs || 0,
                            filtered_runs: data.current_month_runs || 0
                        };
                    }
                } else {
                    console.log(`‚ö†Ô∏è ${endpoint} returned ${response.status}`);
                }
            } catch (endpointError) {
                console.log(`‚ùå ${endpoint} failed:`, endpointError.message);
            }
        }
        
        // If we have any data, show it
        if (Object.keys(dashboardData.customers).length > 0 || dashboardData.statistics.total_customers > 0) {
            updateDashboard();
            showNotification('‚úÖ Dashboard loaded with REAL database data!', 'success');
        } else {
            // Try one more direct approach - load page data
            await loadFromPageContext();
        }
        
    } catch (error) {
        console.error('‚ùå Real data loading failed:', error);
        await loadFromPageContext();
    }
}

// FALLBACK: Try to load data from page context - only use REAL data
async function loadFromPageContext() {
    console.log('üìä Fallback: Trying to get REAL data from any available source...');
    
    // Try direct API calls to get REAL data
    try {
        const csrfToken = getCsrfToken();
        
        // Try the statistics API first
        const statsResponse = await fetch('/api/dashboard/statistics/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (statsResponse.ok) {
            const statsData = await statsResponse.json();
            console.log('‚úÖ Got REAL statistics from API:', statsData);
            
            dashboardData.statistics = {
                total_customers: statsData.total_customers || 0,
                total_runs: statsData.total_runs || 0,
                total_trackers: statsData.total_trackers || 0,
                current_month_runs: statsData.current_month_runs || 0,
                filtered_runs: statsData.current_month_runs || 0
            };
            
            updateDashboard();
            showNotification('‚úÖ Loaded REAL data from statistics API', 'success');
            return;
        }
        
        console.log('‚ö†Ô∏è Statistics API not available, showing loading state');
        
    } catch (error) {
        console.error('‚ùå Error in fallback data loading:', error);
    }
    
    // If no real data available, show loading state instead of fake data
    dashboardData.statistics = {
        total_customers: 0,
        total_runs: 0,
        total_trackers: 0,
        current_month_runs: 0,
        filtered_runs: 0
    };
    
    dashboardData.customers = {};
    
    updateDashboard();
    showNotification('‚ö†Ô∏è No real data available. Please check API endpoints and database connection.', 'warning');
}

// SHOW LOADING STATE DURING API CALLS
function showLoadingState() {
    // Show loading indicators in statistics
    const loadingHTML = '<div class="spinner"></div>';
    document.getElementById('header-total-customers').innerHTML = loadingHTML;
    document.getElementById('header-total-runs').innerHTML = loadingHTML;
    document.getElementById('header-total-trackers').innerHTML = loadingHTML;
    document.getElementById('customer-count').textContent = 'Loading data...';
    
    // Show loading messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer data...</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading tracking graph...</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #6b7280;"><div class="spinner" style="margin: 0 auto 16px;"></div>Loading customer chart...</div>';
}

// HIDE LOADING STATE - STOPS LOADING SPINNERS
function hideLoadingState() {
    console.log('‚úÖ Hiding loading state');
    // Loading will be cleared when updateDashboard() is called
}

// SHOW ERROR STATE WHEN API FAILS
function showErrorState() {
    // Clear all statistics
    document.getElementById('header-total-customers').textContent = '--';
    document.getElementById('header-total-runs').textContent = '--';
    document.getElementById('header-total-trackers').textContent = '--';
    document.getElementById('customer-count').textContent = 'Unable to load data';
    
    // Show error messages in content areas
    document.getElementById('customer-table-body').innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to connect to database.<br><br>Please check your connection and refresh the page.</td></tr>';
    document.getElementById('tracking-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to load tracking data.<br><br>Please refresh the page to try again.</div>';
    document.getElementById('customer-month-chart').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444; font-weight: 600;">‚ùå Unable to load customer data.<br><br>Please refresh the page to try again.</div>';
}

// UPDATE DASHBOARD
function updateDashboard() {
    console.log('üîÑ Updating dashboard components...');
    
    updateStatistics();
    updateCustomerGrid();
    updateTrackingGraph();
    updateCustomerMonthChart();
    
    // DISABLED: checkDataIntegrationIssues() - can cause performance issues
    
    console.log('‚úÖ Customer dashboard updated successfully');
}

// NEW DEBUG FUNCTION: Inspect customer data structure
function debugCustomerData(customerName) {
    const customers = dashboardData.customers;
    const customer = customers[customerName];
    
    if (!customer) {
        console.log(`‚ùå Customer "${customerName}" not found. Available customers:`, Object.keys(customers));
        return;
    }
    
    console.log(`üîç DEBUGGING CUSTOMER: ${customerName}`);
    console.log('='.repeat(50));
    console.log(`Basic Info:`, {
        name: customer.name,
        runs: customer.runs,
        run_count: customer.run_count,
        last_run_date: customer.last_run_date,
        actual_last_run: customer.actual_last_run
    });
    
    console.log(`Monthly Runs:`, customer.monthly_runs);
    console.log(`Network Runs:`, customer.network_runs);
    console.log(`Network Monthly Runs:`, customer.network_monthly_runs);
    console.log(`Networks:`, customer.networks);
    
    // Test date retrieval for each month
    console.log('\nMonth-by-month data:');
    for (let month = 1; month <= 12; month++) {
        const monthData = getCustomerMonthRunDates(customer, new Date().getFullYear(), month);
        if (monthData.count > 0) {
            console.log(`Month ${month}: ${monthData.count} runs, date: ${monthData.date}`);
        }
    }
    console.log('='.repeat(50));
}

// NEW: Test API endpoints directly
async function testCustomerAPIs(customerName) {
    const csrfToken = getCsrfToken();
    console.log(`üî¨ TESTING APIs for: ${customerName}`);
    console.log('='.repeat(60));
    
    // Test 1: Customer monthly sessions
    try {
        const monthlyResponse = await fetch('/api/customer-monthly-sessions/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                customer_name: customerName,
                year: new Date().getFullYear()
            })
        });
        
        if (monthlyResponse.ok) {
            const data = await monthlyResponse.json();
            console.log(`üìä customer-monthly-sessions RESPONSE:`, data);
        } else {
            console.log(`‚ùå customer-monthly-sessions FAILED: ${monthlyResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå customer-monthly-sessions ERROR:`, error);
    }
    
    // Test 2: Dashboard customers
    try {
        const customersResponse = await fetch('/api/customer-dashboard/customers/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (customersResponse.ok) {
            const data = await customersResponse.json();
            if (data.customers && data.customers[customerName]) {
                console.log(`üìÑ dashboard/customers RESPONSE for ${customerName}:`, data.customers[customerName]);
            } else {
                console.log(`‚ö†Ô∏è dashboard/customers: Customer ${customerName} not found`);
                console.log(`Available customers:`, Object.keys(data.customers || {}));
            }
        } else {
            console.log(`‚ùå dashboard/customers FAILED: ${customersResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå dashboard/customers ERROR:`, error);
    }
    
    // Test 3: Networks for customer
    try {
        const networksResponse = await fetch(`/api/networks/${encodeURIComponent(customerName)}/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'
        });
        
        if (networksResponse.ok) {
            const data = await networksResponse.json();
            console.log(`üåê networks RESPONSE for ${customerName}:`, data);
        } else {
            console.log(`‚ùå networks FAILED: ${networksResponse.status}`);
        }
    } catch (error) {
        console.log(`‚ùå networks ERROR:`, error);
    }
    
    console.log('='.repeat(60));
}

// NEW: Manually refresh specific customers
async function refreshCustomers(customerNames) {
    console.log(`üîÑ MANUALLY REFRESHING customers:`, customerNames);
    
    const csrfToken = getCsrfToken();
    const currentYear = new Date().getFullYear();
    
    for (const customerName of customerNames) {
        console.log(`\nüîÑ Processing: ${customerName}`);
        
        try {
            // Get actual last run date
            const actualLastRunDate = await getActualLastRunDate(customerName, csrfToken);
            console.log(`üìÖ Actual last run date for ${customerName}: ${actualLastRunDate}`);
            
            // Get monthly data
            const monthlyData = await fetchCustomerMonthlyRuns(customerName, currentYear, csrfToken);
            console.log(`üìÖ Monthly data for ${customerName}:`, monthlyData);
            
            // Update customer in dashboardData
            if (dashboardData.customers[customerName]) {
                dashboardData.customers[customerName].monthly_runs = monthlyData;
                dashboardData.customers[customerName].last_run_date = actualLastRunDate || dashboardData.customers[customerName].last_run_date;
                dashboardData.customers[customerName].actual_last_run = actualLastRunDate;
                
                console.log(`‚úÖ Updated ${customerName} with fresh data`);
            }
            
        } catch (error) {
            console.error(`‚ùå Error refreshing ${customerName}:`, error);
        }
    }
    
    // Update the dashboard display
    updateCustomerGrid();
    console.log(`‚úÖ Dashboard updated with refreshed data`);
}

// NEW: Load data using exact Excel export method
async function loadDataUsingExcelMethod() {
    console.log('üì• LOADING DATA USING EXACT EXCEL EXPORT METHOD');
    const csrfToken = getCsrfToken();
    
    try {
        // Use the exact same API endpoint and parameters as exportToExcel()
        const formData = {
            start_date: currentStartDate || new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0],
            end_date: currentEndDate || new Date().toISOString().split('T')[0],
            export_type: 'all',
            current_filter_start: currentStartDate,
            current_filter_end: currentEndDate,
            format: 'json',  // Request JSON instead of Excel file
            dashboard_context: {
                current_year: new Date().getFullYear(),
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                include_run_dates: true,
                return_json: true  // Force JSON return
            }
        };
        
        console.log('üì• Excel method request:', formData);
        
        const response = await fetch('/api/customer-dashboard/export/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest',
                'Accept': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify(formData)
        });
        
        if (response.ok) {
            const contentType = response.headers.get('content-type');
            
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log('‚úÖ Excel method returned JSON data:', data);
                
                // Process and update dashboard
                if (data.customers) {
                    dashboardData.customers = data.customers;
                    dashboardData.statistics = data.statistics || {};
                    updateDashboard();
                    console.log('‚úÖ Dashboard updated with Excel method data!');
                    return true;
                }
            } else {
                console.log('‚ö†Ô∏è Excel method returned file, not JSON');
            }
        } else {
            console.log(`‚ùå Excel method API failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error('‚ùå Excel method failed:', error);
    }
    
    return false;
}

// NEW: Force reload with Excel method
async function forceReloadWithExcelMethod() {
    console.log('üîÑ FORCE RELOADING WITH EXCEL METHOD...');
    showLoadingState();
    
    const success = await loadDataUsingExcelMethod();
    
    if (!success) {
        console.log('‚ö†Ô∏è Excel method failed, falling back to enhanced method...');
        await loadDashboardData(currentStartDate, currentEndDate);
    }
    
    showNotification('‚úÖ Dashboard reloaded with Excel-compatible data', 'success');
}

// Expose debug functions to window for manual testing
window.debugCustomerData = debugCustomerData;
window.testCustomerAPIs = testCustomerAPIs;
window.refreshCustomers = refreshCustomers;
window.loadDataUsingExcelMethod = loadDataUsingExcelMethod;
window.forceReloadWithExcelMethod = forceReloadWithExcelMethod;

// NEW FUNCTION: Check for common data integration issues
function checkDataIntegrationIssues() {
    const customers = dashboardData.customers;
    let issueCount = 0;
    
    Object.values(customers).forEach(customer => {
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        const hasValidDate = customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-';
        
        if (totalRuns > 0 && !hasValidDate) {
            console.log(`‚ùå DATA INTEGRATION ISSUE: ${customer.name} has ${totalRuns} runs but no valid date`);
            issueCount++;
        }
        
        if (customer.data_integration_error) {
            console.log(`‚ùå DATA INTEGRATION ERROR: ${customer.name} had errors during data loading`);
            issueCount++;
        }
    });
    
    if (issueCount > 0) {
        console.log(`‚ö†Ô∏è SUMMARY: Found ${issueCount} data integration issues. Check console for details.`);
        showNotification(`‚ö†Ô∏è Found ${issueCount} data integration issues. Check browser console for details.`, 'warning');
    } else {
        console.log('‚úÖ No data integration issues detected.');
    }
}

// Function to animate header stats
function animateStatCard(type, targetValue, maxValue = 100) {
    const headerValue = document.getElementById(`header-total-${type}`);
    
    if (!headerValue) return;
    
    // Simple animation for header stats
    const duration = 1000; // 1 second
    const steps = 30;
    const stepTime = duration / steps;
    
    let currentStep = 0;
    
    const animate = () => {
        currentStep++;
        const progress = currentStep / steps;
        
        // Smooth ease-out
        const easedProgress = 1 - Math.pow(1 - progress, 2);
        
        // Calculate current value
        const currentValue = Math.round(targetValue * easedProgress);
        
        // Update header value
        headerValue.textContent = currentValue;
        
        // Continue animation
        if (currentStep < steps) {
            setTimeout(animate, stepTime);
        }
    };
    
    // Start animation
    animate();
}

function updateStatistics() {
    const stats = dashboardData.statistics || {};
    console.log('üìä Updating statistics with:', stats);
    
    // Animate statistics displays with circular progress
    // Use reasonable max values for progress calculation
    animateStatCard('customers', stats.total_customers || 0, Math.max(50, stats.total_customers || 0));
    animateStatCard('runs', stats.total_runs || 0, Math.max(1000, stats.total_runs || 0));
    animateStatCard('trackers', stats.total_trackers || 0, Math.max(500, stats.total_trackers || 0));
    
    console.log('üìä Statistics updated on page:', {
        customers: stats.total_customers || 0,
        runs: stats.total_runs || 0,
        trackers: stats.total_trackers || 0
    });
    
    // Update customer count with filter info
    const customerCount = Object.keys(dashboardData.customers).length;
    let customerCountText = `${customerCount} customers`;
    
    // Add filter info if dates are applied
    if (currentStartDate && currentEndDate) {
        const startDate = new Date(currentStartDate).toLocaleDateString();
        const endDate = new Date(currentEndDate).toLocaleDateString();
        customerCountText += ` (${startDate} - ${endDate})`;
    }
    
    document.getElementById('customer-count').textContent = customerCountText;
    
    console.log('üìä Dashboard updated with live data:', {
        customers: customerCount,
        runs: stats.total_runs,
        trackers: stats.total_trackers,
        filtered: currentStartDate && currentEndDate
    });
}

function updateTrackingGraph() {
    const graphContainer = document.getElementById('tracking-graph');
    const trackingContainer = graphContainer.parentElement;
    const customers = dashboardData.customers;
    
    // Get last 6 months data with real data from customers
    const currentDate = new Date();
    const monthsData = [];
    
    // Generate last 6 months
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'short' });
        const monthNumber = monthDate.getMonth() + 1;
        const year = monthDate.getFullYear();
        
        // Calculate total runs for this month from all customers using NETWORK DATA
        let monthTotal = 0;
        if (customers && Object.keys(customers).length > 0) {
            Object.values(customers).forEach(customer => {
                // Count runs from network months data (same as table)
                if (customer.networks && Array.isArray(customer.networks)) {
                    customer.networks.forEach(network => {
                        if (network.months && Array.isArray(network.months)) {
                            const monthIndex = monthNumber - 1; // Convert to 0-based
                            const monthValue = network.months[monthIndex];
                            
                            // Count actual runs (same logic as table)
                            if (monthValue && monthValue !== '-' && 
                                monthValue !== 'Not Started' && 
                                monthValue !== 'Not Run' && 
                                monthValue !== 'No Report' &&
                                !monthValue.toLowerCase().includes('not')) {
                                monthTotal++;
                                console.log(`üìà GRAPH: ${customer.name}-${network.name} has run in month ${monthNumber}: ${monthValue}`);
                            }
                        }
                    });
                }
            });
        }
        
        // UNIVERSAL FIX: No fake data generation - monthTotal remains 0 if no actual data
        // The getCustomerMonthRuns function will handle all month validation properly
        console.log(`üìÖ Month ${monthDate.getMonth() + 1}/${monthDate.getFullYear()}: ${monthTotal} actual runs`);
        
        
        monthsData.push({
            month: monthName,
            runs: monthTotal,
            fullDate: monthDate
        });
    }
    
    const maxRuns = Math.max(...monthsData.map(m => m.runs), 1); // At least 1 to avoid division by zero
    
    graphContainer.innerHTML = '';
    
    // RENDER AS BEAUTIFUL LINE CHART for tracking-graph
    if (graphContainer.id === 'tracking-graph') {
        // Modern line chart container
        graphContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            min-height: 220px;
            padding: 16px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.02) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Calculate total and max values
        const totalRuns = monthsData.reduce((sum, month) => sum + month.runs, 0);
        const maxRuns = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Handle empty data state
        if (totalRuns === 0) {
            graphContainer.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    color: #6b7280;
                    font-weight: 600;
                ">
                    <div style="
                        width: 60px;
                        height: 60px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, #e5e7eb 0%, #f3f4f6 100%);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        margin-bottom: 12px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    ">üìà</div>
                    <div style="font-size: 0.9rem; text-align: center;">No activity data</div>
                    <div style="font-size: 0.7rem; color: #9ca3af; margin-top: 4px;">Start by uploading health checks</div>
                </div>
            `;
            return;
        }
        
        // Create professional line chart container
        graphContainer.innerHTML = '';
        graphContainer.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            height: 140px;
            padding: 20px;
            position: relative;
            background: linear-gradient(to top, rgba(102, 126, 234, 0.03) 0%, transparent 40%);
            border-radius: 12px;
        `;
        
        // Dynamic professional chart dimensions based on data points
        const baseWidth = 320;
        const dataPointWidth = Math.max(60, Math.min(120, baseWidth / monthsData.length)); // 60-120px per data point
        const chartWidth = Math.max(baseWidth, monthsData.length * dataPointWidth);
        const chartHeight = 120;
        const padding = { left: 25, right: 25, top: 25, bottom: 25 };
        const innerWidth = chartWidth - padding.left - padding.right;
        const innerHeight = chartHeight - padding.top - padding.bottom;
        
        // Apply dynamic container sizing
        if (monthsData.length <= 4) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
        } else if (monthsData.length > 8) {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
        } else {
            trackingContainer.className = trackingContainer.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
        }
        
        // Create SVG with proper styling
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', chartHeight);
        svg.setAttribute('viewBox', `0 0 ${chartWidth} ${chartHeight}`);
        svg.style.cssText = 'overflow: visible;';
        
        // Calculate max value for proper scaling
        const maxValue = Math.max(...monthsData.map(m => m.runs), 1);
        
        // Create professional data points with improved positioning
        const points = monthsData.map((month, i) => {
            const x = padding.left + (i / Math.max(monthsData.length - 1, 1)) * innerWidth;
            const normalizedValue = maxValue > 0 ? month.runs / maxValue : 0;
            // Use more chart area for better visualization (90% instead of 80%)
            const y = padding.top + innerHeight - (normalizedValue * innerHeight * 0.9);
            
            return {
                x: x,
                y: Math.max(y, padding.top + 10), // More top padding for labels
                runs: month.runs,
                month: month.month
            };
        });
        
        // Create smooth line path
        let pathData = `M ${points[0].x} ${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
            pathData += ` L ${points[i].x} ${points[i].y}`;
        }
        
        // Add subtle background grid
        for (let i = 0; i <= 4; i++) {
            const y = padding.top + (i / 4) * innerHeight;
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', padding.left + innerWidth);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#f3f4f6');
            gridLine.setAttribute('stroke-width', '0.5');
            if (i > 0) gridLine.setAttribute('stroke-dasharray', '2,2');
            svg.appendChild(gridLine);
        }
        
        // Create professional line with gradient
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', 'lineGradient');
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '100%');
        gradient.setAttribute('y2', '0%');
        
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#667eea');
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#764ba2');
        
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
        svg.appendChild(defs);
        
        // Draw professional line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        line.setAttribute('d', pathData);
        line.setAttribute('stroke', 'url(#lineGradient)');
        line.setAttribute('stroke-width', '2.5');
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-linejoin', 'round');
        line.style.filter = 'drop-shadow(0 1px 3px rgba(102, 126, 234, 0.3))';
        svg.appendChild(line);
        
        // Add professional data points
        points.forEach((point, i) => {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', '3');
            circle.setAttribute('fill', '#ffffff');
            circle.setAttribute('stroke', '#667eea');
            circle.setAttribute('stroke-width', '2');
            circle.style.cssText = `
                cursor: pointer;
                transition: all 0.2s ease;
                filter: drop-shadow(0 1px 2px rgba(102, 126, 234, 0.3));
            `;
            
            // Professional hover effect
            circle.addEventListener('mouseenter', () => {
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', '#667eea');
            });
            circle.addEventListener('mouseleave', () => {
                circle.setAttribute('r', '3');
                circle.setAttribute('fill', '#ffffff');
            });
            
            svg.appendChild(circle);
        });
        
        // Add enhanced professional value labels
        points.forEach((point, i) => {
            const labelText = `${point.runs} runs`;
            const textWidth = Math.max(labelText.length * 6, 40); // Better width calculation
            
            // Create professional background pill
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelBg.setAttribute('x', point.x - textWidth/2 - 3);
            labelBg.setAttribute('y', point.y - 26);
            labelBg.setAttribute('width', textWidth + 6);
            labelBg.setAttribute('height', 18);
            labelBg.setAttribute('rx', '9');
            labelBg.setAttribute('fill', 'rgba(255, 255, 255, 0.95)');
            labelBg.setAttribute('stroke', '#667eea');
            labelBg.setAttribute('stroke-width', '1.5');
            labelBg.style.cssText = `
                filter: drop-shadow(0 2px 6px rgba(102, 126, 234, 0.2));
            `;
            svg.appendChild(labelBg);
            
            // Add enhanced value text
            const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            valueText.setAttribute('x', point.x);
            valueText.setAttribute('y', point.y - 12);
            valueText.setAttribute('text-anchor', 'middle');
            valueText.setAttribute('font-size', '10');
            valueText.setAttribute('font-weight', '700');
            valueText.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            valueText.setAttribute('fill', '#667eea');
            valueText.textContent = labelText;
            svg.appendChild(valueText);
        });
        
        // Add enhanced professional month labels
        points.forEach((point, i) => {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', point.x);
            text.setAttribute('y', chartHeight - 8);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', '600');
            text.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
            text.setAttribute('fill', '#4b5563');
            text.textContent = point.month;
            svg.appendChild(text);
        });
        
        // Append the complete professional chart
        graphContainer.appendChild(svg);
        
    } else {
        // RENDER AS BAR CHART (for other charts)
        monthsData.forEach(monthData => {
            const height = maxRuns > 0 ? Math.max((monthData.runs / maxRuns) * 80, 4) : 4;
            
            const graphBar = document.createElement('div');
            graphBar.className = 'graph-bar';
            
            graphBar.innerHTML = `
                <div class="bar" style="height: ${height}px;" title="${monthData.month}: ${monthData.runs} runs">
                    <div class="bar-value">${monthData.runs}</div>
                </div>
                <div class="month-label">${monthData.month}</div>
            `;
            
            graphContainer.appendChild(graphBar);
        });
    }
    
    console.log('üìä 6-month tracking graph updated:', monthsData);
}

// UPDATE CUSTOMER MONTHLY BREAKDOWN CHART
function updateCustomerMonthChart() {
    const chartContainer = document.getElementById('customer-month-chart');
    const chartContainerParent = chartContainer.parentElement;
    const customers = dashboardData.customers;
    
    // Get current month data for all customers
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    const currentMonthName = currentDate.toLocaleDateString('en-US', { month: 'long' });
    
    // Update the chart title with current month and year
    const chartTitle = document.getElementById('customer-chart-title');
    if (chartTitle) {
        chartTitle.textContent = `üë• Active Customers - ${currentMonthName} ${currentYear}`;
    }
    
    const customersData = [];
    
    if (customers && Object.keys(customers).length > 0) {
        Object.entries(customers).forEach(([customerName, customer]) => {
            const monthRuns = getCustomerMonthRuns(customer, currentYear, currentMonth);
            if (monthRuns > 0) { // Only show customers with runs this month
                customersData.push({
                    name: customerName,
                    runs: monthRuns,
                    customer: customer
                });
            }
        });
        
        // Sort by runs (highest first) and take top 10
        customersData.sort((a, b) => b.runs - a.runs);
        customersData.splice(10); // Keep only top 10
    }
    
    // Apply dynamic container sizing based on number of customers
    if (customersData.length <= 3) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' compact';
    } else if (customersData.length > 10) {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' expanded';
    } else {
        chartContainerParent.className = chartContainerParent.className.replace(/\b(compact|expanded|dynamic)\b/g, '') + ' dynamic';
    }
    
    chartContainer.innerHTML = '';
    
    // Dynamic container styling based on customer count
    const dynamicGap = Math.max(4, Math.min(12, 80 / customersData.length)); // Adjust gap based on customer count
    const dynamicWidth = customersData.length > 8 ? Math.max(40, 300 / customersData.length) : 80; // Adjust bar width
    
    chartContainer.style.cssText = `
        display: flex;
        align-items: flex-end;
        justify-content: space-evenly;
        padding: 8px;
        height: 100px;
        gap: 4px;
        overflow-x: auto;
        overflow-y: hidden;
        background: rgba(248, 250, 252, 0.3);
        border-radius: 6px;
    `;
    
    if (customersData.length === 0) {
        chartContainer.innerHTML = `
            <div style="padding: 40px; text-align: center; color: #6b7280;">
                <div style="font-size: 2rem; margin-bottom: 16px;">üìà</div>
                <div style="font-weight: 600; margin-bottom: 8px;">No activity this month</div>
                <div style="font-size: 0.9rem;">Customers will appear here when they run health checks in ${currentMonthName}</div>
            </div>
        `;
        return;
    }
    
    const maxRuns = Math.max(...customersData.map(c => c.runs), 1);
    
    // Create chart bars for each customer - UNIFORM SIZING
    customersData.forEach((customerData, index) => {
        // FIXED: All bars same height, only numbers show difference
        const height = 40; // Same height for all bars
            
        const isTopPerformer = index < 3; // Top 3 get special styling
        
        const chartBar = document.createElement('div');
        chartBar.className = 'customer-chart-bar';
        chartBar.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            margin: 0 6px;
            flex: 1;
            max-width: 85px;
            min-width: 70px;
            height: 85px;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.1));
        `;
        
        // Add hover effect
        chartBar.addEventListener('mouseenter', () => {
            chartBar.style.transform = 'scale(1.08) translateY(-2px)';
            chartBar.style.filter = 'drop-shadow(0 3px 8px rgba(0,0,0,0.15))';
        });
        chartBar.addEventListener('mouseleave', () => {
            chartBar.style.transform = 'scale(1) translateY(0)';
            chartBar.style.filter = 'drop-shadow(0 1px 3px rgba(0,0,0,0.1))';
        });
        
        const barColor = isTopPerformer ? 
            (index === 0 ? '#10b981' : index === 1 ? '#3b82f6' : '#f59e0b') : 
            '#6b7280';
        
        chartBar.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-end;
                    height: 100%;
                    width: 100%;
                ">
                <div style="
                    background: ${barColor};
                    color: white;
                    font-weight: 800;
                    font-size: 0.8rem;
                    padding: 3px 8px;
                    border-radius: 6px;
                    margin-bottom: 4px;
                    min-width: 24px;
                    text-align: center;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.25);
                    border: 1px solid rgba(255,255,255,0.3);
                    position: relative;
                    z-index: 2;
                " title="${customerData.name}: ${customerData.runs} runs in ${currentMonthName}">
                    ${customerData.runs}
                </div>
                <div style="
                    width: 80%;
                    height: ${height}px;
                    background: linear-gradient(135deg, ${barColor} 0%, ${barColor}cc 50%, ${barColor}dd 100%);
                    border-radius: 6px;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                    position: relative;
                "></div>
                <div style="
                    font-size: 0.65rem;
                    font-weight: 700;
                    color: #374151;
                    text-align: center;
                    margin-top: 6px;
                    line-height: 1.1;
                    max-width: 100%;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    background: rgba(255,255,255,0.9);
                    padding: 3px 6px;
                    border-radius: 4px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    border: 1px solid rgba(0,0,0,0.05);
                " title="${customerData.name}">
                    ${customerData.name.length > 9 ? customerData.name.substring(0, 9) + '...' : customerData.name}
                </div>
                <div style="
                    font-size: 0.5rem;
                    font-weight: 500;
                    color: #6b7280;
                    text-align: center;
                    margin-top: 1px;
                ">
                    ${currentDate.toLocaleDateString('en-US', { month: 'short' })}
                </div>
            </div>
        `;
        
        chartContainer.appendChild(chartBar);
    });
    
    console.log(`üìà Customer monthly chart updated for ${currentMonthName}:`, customersData);
}

// DYNAMIC CHART RESIZE HANDLER
function handleChartResize() {
    // Debounce resize events
    clearTimeout(window.chartResizeTimeout);
    window.chartResizeTimeout = setTimeout(() => {
        console.log('üîÑ Adjusting charts for window resize...');
        
        // Update both charts with current data
        if (dashboardData && dashboardData.customers) {
            updateTrackingGraph();
            updateCustomerMonthChart();
        }
    }, 300);
}

// Add resize listener
window.addEventListener('resize', handleChartResize);

// EDIT CUSTOMER FUNCTIONALITY
function editCustomer(customerName) {
    console.log(`üìù Opening edit modal for: ${customerName}`);
    
    // Find customer data
    const customer = dashboardData.customers[Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === customerName
    )];
    
    if (!customer) {
        showNotification('‚ùå Customer not found', 'error');
        return;
    }
    
    // Create edit modal
    const modal = document.createElement('div');
    modal.id = 'editCustomerModal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; justify-content: center;
        align-items: center; z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white; padding: 20px; border-radius: 8px; width: 80%;
        max-width: 800px; max-height: 80%; overflow-y: auto;
    `;
    
    // Generate month headers
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let networksHtml = '';
    
    if (customer.networks && customer.networks.length > 0) {
        customer.networks.forEach((network, index) => {
            const monthInputs = months.map((month, monthIndex) => {
                const value = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                return `<input type="text" id="network_${index}_month_${monthIndex}" value="${value}" style="width: 80px; padding: 2px; margin: 1px;" />`;
            }).join('');
            
            networksHtml += `
                <div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                    <h4>${network.name || `Network ${index + 1}`}</h4>
                    <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 5px; margin-top: 10px;">
                        ${months.map((month, monthIndex) => `
                            <div>
                                <label style="font-size: 0.8rem; display: block;">${month}</label>
                                <input type="text" id="network_${index}_month_${monthIndex}" value="${network.months && network.months[monthIndex] ? network.months[monthIndex] : '-'}" style="width: 100%; padding: 4px; font-size: 0.8rem;" />
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });
    }
    
    modalContent.innerHTML = `
        <h2>‚úèÔ∏è Edit Customer: ${customerName}</h2>
        <div style="margin: 20px 0;">
            <h3>Networks Monthly Data:</h3>
            ${networksHtml}
        </div>
        <div style="margin: 20px 0; text-align: right;">
            <button onclick="saveCustomerEdit('${customerName}')" 
                    style="background: #10b981; color: white; border: none; padding: 10px 20px; 
                           border-radius: 4px; margin-right: 10px; cursor: pointer;">
                üíæ
            </button>
            <button onclick="closeEditModal()" 
                    style="background: #6b7280; color: white; border: none; padding: 10px 20px; 
                           border-radius: 4px; cursor: pointer;">
                ‚ùå
            </button>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}

function closeEditModal() {
    const modal = document.getElementById('editCustomerModal');
    if (modal) {
        modal.remove();
    }
}

function saveCustomerEdit(customerName) {
    console.log(`üíæ Saving changes for: ${customerName}`);
    
    // Find customer data
    const customerKey = Object.keys(dashboardData.customers).find(key => 
        dashboardData.customers[key].name === customerName
    );
    const customer = dashboardData.customers[customerKey];
    
    if (!customer) {
        showNotification('‚ùå Customer not found', 'error');
        return;
    }
    
    // Collect updated data
    const updatedNetworks = [];
    
    customer.networks.forEach((network, networkIndex) => {
        const updatedMonths = [];
        
        for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
            const input = document.getElementById(`network_${networkIndex}_month_${monthIndex}`);
            if (input) {
                updatedMonths[monthIndex] = input.value || '-';
            }
        }
        
        updatedNetworks.push({
            ...network,
            months: updatedMonths,
            monthly_runs: updatedMonths
        });
    });
    
    // Update customer data
    customer.networks = updatedNetworks;
    
    // Update local dashboard data (in-memory only)
    console.log('üíæ Updating local dashboard data...');
    
    // Success notification
    showNotification('‚úÖ Customer data updated successfully! (Local changes only)', 'success');
    closeEditModal();
    
    // Refresh the table display with updated data
    setTimeout(() => {
        updateCustomerGrid();
    }, 500);
}

// RESTORE EDITED DATA FROM LOCALSTORAGE
function restoreEditedData() {
    console.log('üíæ Restoring edited data from localStorage...');
    
    // First clear old data
    clearOldEditedData();
    
    let restoredCount = 0;
    
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                // More robust storage key with customer source
                const isExcel = customer.excel_source || customer.excel_data;
                const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                const storedData = localStorage.getItem(storageKey);
                
                if (storedData) {
                    try {
                        const editedData = JSON.parse(storedData);
                        
                        // CRITICAL: STRICT VALIDATION - Only restore if EXACT customer and network match
                        if (editedData.customer !== customer.name || editedData.network !== network.name) {
                            console.log(`   ‚ö†Ô∏è MISMATCH: Skipping ${storageKey} - customer: ${editedData.customer} vs ${customer.name}, network: ${editedData.network} vs ${network.name}`);
                            return; // Skip this network restoration
                        }
                        
                        // Check if data is not too old (less than 24 hours)
                        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                        if (Date.now() - editedData.timestamp < maxAge) {
                            // Store original months data if not already stored
                            if (!network.originalMonths) {
                                network.originalMonths = network.months ? [...network.months] : [];
                            }
                            
                            network.months = editedData.months;
                            network.monthly_runs = editedData.months;
                            network.editedData = true; // Mark as edited
                            
                            console.log(`   ‚úÖ STRICT MATCH: Restored edited data for ${customer.name} - ${network.name}`);
                            restoredCount++;
                        } else {
                            // Remove old data
                            localStorage.removeItem(storageKey);
                            console.log(`   üóëÔ∏è Removed old edited data for ${customer.name} - ${network.name}`);
                        }
                    } catch (error) {
                        console.error(`   ‚ùå Error restoring data for ${storageKey}:`, error);
                        localStorage.removeItem(storageKey);
                    }
                }
            });
        }
    });
    
    if (restoredCount > 0) {
        showNotification(`üíæ Restored ${restoredCount} edited networks from localStorage`, 'info');
    }
    
    return restoredCount;
}

// CLEAR OLD EDITED DATA
function clearOldEditedData() {
    console.log('üßπ Cleaning old edited data from localStorage...');
    
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('edited_')) {
            const storedData = localStorage.getItem(key);
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (Date.now() - data.timestamp >= maxAge) {
                        keysToRemove.push(key);
                    }
                } catch (error) {
                    keysToRemove.push(key); // Remove invalid data
                }
            }
        }
    }
    
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log(`   üóëÔ∏è Removed old data: ${key}`);
    });
}

// BULK EDIT FUNCTIONALITY
function openBulkEditModal() {
    console.log(`üìù Opening bulk edit modal`);
    
    // Get all customers (both Excel and DB)
    const allCustomers = Object.values(dashboardData.customers);
    
    if (allCustomers.length === 0) {
        showNotification('‚ùå No customers found to edit', 'error');
        return;
    }
    
    // Separate Excel and DB customers
    const excelCustomers = allCustomers.filter(customer => customer.excel_source || customer.excel_data);
    const dbCustomers = allCustomers.filter(customer => !customer.excel_source && !customer.excel_data);
    
    console.log(`üìä Found ${excelCustomers.length} Excel customers and ${dbCustomers.length} DB customers`);
    
    // Create edit modal
    const modal = document.createElement('div');
    modal.id = 'bulkEditModal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); display: flex; justify-content: center;
        align-items: center; z-index: 1000;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background: white; padding: 30px; border-radius: 12px; width: 95%;
        max-width: 1400px; max-height: 85%; overflow-y: auto;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    `;
    
    // Generate month headers
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let customersHtml = '';
    
    // Process Excel customers
    excelCustomers.forEach((customer, customerIndex) => {
        let networksHtml = '';
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                const monthInputs = months.map((month, monthIndex) => {
                    const value = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7rem; margin-bottom: 4px; font-weight: 600; 
                                          color: #4b5563;">${month}</label>
                            <input type="text" 
                                   id="excel_customer_${customerIndex}_network_${networkIndex}_month_${monthIndex}" 
                                   value="${value}" 
                                   placeholder="-"
                                   style="width: 75px; padding: 6px 4px; font-size: 0.75rem; text-align: center;
                                          border: 1px solid #d1d5db; border-radius: 4px; 
                                          transition: all 0.2s ease;
                                          background: #ffffff;"
                                   onocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 2px rgba(59, 130, 246, 0.1)'"
                                   onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'" />
                        </div>
                    `;
                }).join('');
                
                networksHtml += `
                    <div style="margin: 15px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; 
                                background: linear-gradient(to right, #f8fafc, #f1f5f9); 
                                box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                        <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                            <h5 style="margin: 0; color: #1e40af; font-weight: 600; font-size: 0.95rem;">
                                üîó ${network.name || `Network ${networkIndex + 1}`}
                            </h5>
                            <span style="background: #3b82f6; color: white; padding: 3px 8px; border-radius: 12px; 
                                         font-size: 0.65rem; font-weight: 500;">Excel Network</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; 
                                    background: white; padding: 15px; border-radius: 6px;">
                            ${monthInputs}
                        </div>
                    </div>
                `;
            });
        }
        
        customersHtml += `
            <div style="margin: 25px 0; padding: 25px; border: 2px solid #3b82f6; border-radius: 12px; 
                        background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #1e40af; font-size: 1.25rem; font-weight: 700;">
                        üìä ${customer.name}
                    </h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #3b82f6; color: white; padding: 6px 12px; border-radius: 20px; 
                                     font-size: 0.75rem; font-weight: 600;">Excel Customer</span>
                        <span style="background: #f3f4f6; color: #6b7280; padding: 4px 8px; border-radius: 12px; 
                                     font-size: 0.65rem;">${customer.networks ? customer.networks.length : 0} Networks</span>
                    </div>
                </div>
                ${networksHtml}
            </div>
        `;
    });
    
    // Process DB customers - Show real dates like dashboard
    dbCustomers.forEach((customer, customerIndex) => {
        let networksHtml = '';
        const currentYear = new Date().getFullYear();
        
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                // Clean network name - remove customer prefix like "Bsnl - "
                let networkName = network.network_name || network.name || network;
                
                // If network name has customer prefix, remove it to show clean name
                if (typeof networkName === 'string' && networkName.includes(' - ')) {
                    const cleanName = networkName.split(' - ').slice(1).join(' - ');
                    if (cleanName && cleanName !== 'Default') {
                        networkName = cleanName;
                    } else {
                        // If it's just "Default", use customer name + Default
                        networkName = `${customer.name} Default`;
                    }
                }
                
                console.log(`üîß DB Network: "${network.name}" -> "${networkName}" for customer ${customer.name}`);
                
                const monthInputs = months.map((month, monthIndex) => {
                    // Get real dates using the original network name for data lookup
                    const monthRunData = getNetworkMonthRunDates(customer, network.name, currentYear, monthIndex + 1);
                    const value = monthRunData && monthRunData.date && monthRunData.date !== '-' ? monthRunData.date : '-';
                    
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7rem; margin-bottom: 4px; font-weight: 600; 
                                          color: #4b5563;">${month}</label>
                            <input type="text" 
                                   id="db_customer_${customerIndex}_network_${networkIndex}_month_${monthIndex}" 
                                   value="${value}" 
                                   placeholder="DD-MMM-YY"
                                   style="width: 75px; padding: 6px 4px; font-size: 0.75rem; text-align: center;
                                          border: 1px solid #d1d5db; border-radius: 4px; 
                                          transition: all 0.2s ease;
                                          background: #ffffff;"
                                   onfocus="this.style.borderColor='#10b981'; this.style.boxShadow='0 0 0 2px rgba(16, 185, 129, 0.1)'"
                                   onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'" />
                        </div>
                    `;
                }).join('');
                
                networksHtml += `
                    <div style="margin: 15px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px; 
                                background: linear-gradient(to right, #f0fdf4, #ecfdf5); 
                                box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                        <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                            <h5 style="margin: 0; color: #059669; font-weight: 600; font-size: 0.95rem;">
                                üíæ ${networkName}
                            </h5>
                            <span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 12px; 
                                         font-size: 0.65rem; font-weight: 500;">DB Network</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; 
                                    background: white; padding: 15px; border-radius: 6px;">
                            ${monthInputs}
                        </div>
                    </div>
                `;
            });
        }
        
        customersHtml += `
            <div style="margin: 25px 0; padding: 25px; border: 2px solid #10b981; border-radius: 12px; 
                        background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #059669; font-size: 1.25rem; font-weight: 700;">
                        üíæ ${customer.name}
                    </h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #10b981; color: white; padding: 6px 12px; border-radius: 20px; 
                                     font-size: 0.75rem; font-weight: 600;">Database Customer</span>
                        <span style="background: #f3f4f6; color: #6b7280; padding: 4px 8px; border-radius: 12px; 
                                     font-size: 0.65rem;">${customer.networks ? customer.networks.length : 0} Networks</span>
                    </div>
                </div>
                ${networksHtml}
            </div>
        `;
    });
    
    modalContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #f3f4f6; padding-bottom: 20px;">
            <h2 style="margin: 0 0 10px 0; color: #1f2937; font-size: 1.75rem; font-weight: 800;">
                ‚úèÔ∏è Monthly Data Editor
            </h2>
            <p style="color: #6b7280; margin: 0; font-size: 1rem;">
                Edit monthly run dates for all customers. Changes are saved locally until you refresh the page.
            </p>
        </div>
        
        <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 30px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #3b82f6; border-radius: 3px;"></div>
                    <span style="color: #374151; font-weight: 500;">Excel Customers</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #10b981; border-radius: 3px;"></div>
                    <span style="color: #374151; font-weight: 500;">Database Customers</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: #6b7280; font-size: 0.9rem;">üí° Use format: DD-MMM-YY (e.g., 15-Jan-25)</span>
                </div>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            ${customersHtml}
        </div>
        
        <div style="margin: 30px 0 0 0; text-align: center; border-top: 2px solid #f3f4f6; padding-top: 25px;">
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <button onclick="saveBulkEdit()" 
                        style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; 
                               border: none; padding: 16px 32px; border-radius: 10px; 
                               cursor: pointer; font-weight: 600; font-size: 1rem;
                               box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                               transition: all 0.3s ease;
                               display: flex; align-items: center; gap: 10px;
                               min-width: 180px; justify-content: center;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(16, 185, 129, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)'">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                </button>
                
                <button onclick="closeBulkEditModal()" 
                        style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; 
                               border: none; padding: 16px 32px; border-radius: 10px; cursor: pointer; 
                               font-weight: 600; font-size: 1rem;
                               box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
                               transition: all 0.3s ease;
                               display: flex; align-items: center; gap: 10px;
                               min-width: 140px; justify-content: center;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(239, 68, 68, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.3)'">
                    <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}

function closeBulkEditModal() {
    const modal = document.getElementById('bulkEditModal');
    if (modal) {
        modal.remove();
    }
}

function saveBulkEdit() {
    console.log(`üíæ Saving bulk changes...`);
    
    // Get both Excel and DB customers
    const allCustomers = Object.values(dashboardData.customers);
    const excelCustomers = allCustomers.filter(customer => customer.excel_source || customer.excel_data);
    const dbCustomers = allCustomers.filter(customer => !customer.excel_source && !customer.excel_data);
    
    let updatedCount = 0;
    
    // Update Excel customers - Process each customer independently
    excelCustomers.forEach((customer, excelCustomerIndex) => {
        console.log(`üîç Processing Excel customer ${excelCustomerIndex}: ${customer.name}`);
        
        customer.networks.forEach((network, networkIndex) => {
            const inputId = `excel_customer_${excelCustomerIndex}_network_${networkIndex}_month_`;
            console.log(`   üîó Checking network: ${network.name} with ID pattern: ${inputId}`);
            
            const updatedMonths = [];
            let hasChanges = false;
            
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                if (inputElement) {
                    const newValue = inputElement.value || '-';
                    updatedMonths[monthIndex] = newValue;
                    
                    // Check if there are changes
                    const oldValue = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    if (newValue !== oldValue) {
                        hasChanges = true;
                        console.log(`     üîÑ Month ${monthIndex + 1}: "${oldValue}" ‚Üí "${newValue}"`);
                    }
                } else {
                    console.log(`     ‚ö†Ô∏è Input not found: ${inputId}${monthIndex}`);
                }
            }
            
            // Update network data only if there are changes
            if (hasChanges) {
                // Store original months data before editing (if not already stored)
                if (!network.originalMonths) {
                    network.originalMonths = network.months ? [...network.months] : [];
                }
                
                network.months = updatedMonths;
                network.monthly_runs = updatedMonths;
                network.editedData = true; // Mark as edited
                
                // Store edited data in localStorage with robust key
                const storageKey = `edited_excel_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                localStorage.setItem(storageKey, JSON.stringify({
                    months: updatedMonths,
                    originalMonths: network.originalMonths,
                    timestamp: Date.now(),
                    customer: customer.name,
                    network: network.name,
                    source: 'excel'
                }));
                
                updatedCount++;
                console.log(`   ‚úÖ Updated Excel network: ${network.name} (saved to localStorage)`);
            } else {
                console.log(`   ‚ÑπÔ∏è No changes for Excel network: ${network.name}`);
            }
        });
    });
    
    // Update DB customers - CRITICAL FIX: Only mark networks as edited if input actually changed
    dbCustomers.forEach((customer, customerIndex) => {
        console.log(`üîç Processing DB customer ${customerIndex}: ${customer.name}`);
        
        customer.networks.forEach((network, networkIndex) => {
            const inputId = `db_customer_${customerIndex}_network_${networkIndex}_month_`;
            console.log(`   üîó Checking DB network: ${network.name} with ID pattern: ${inputId}`);
            
            let hasChanges = false;
            const updatedMonths = [];
            
            // Store original months data before editing (if not already stored)
            if (!network.originalMonths) {
                network.originalMonths = network.months ? [...network.months] : Array(12).fill('-');
            }
            
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const inputElement = document.getElementById(`${inputId}${monthIndex}`);
                if (inputElement) {
                    const newValue = inputElement.value || '-';
                    updatedMonths[monthIndex] = newValue;
                    
                    // For DB customers, initialize months array if needed
                    if (!network.months) {
                        network.months = Array(12).fill('-');
                    }
                    
                    const oldValue = network.months[monthIndex] || '-';
                    if (newValue !== oldValue) {
                        hasChanges = true;
                        console.log(`     üîÑ ACTUAL CHANGE: ${customer.name} - ${network.name} - Month ${monthIndex + 1}: "${oldValue}" ‚Üí "${newValue}"`);
                    }
                } else {
                    // CRITICAL: If input not found, this network was NOT in the edit modal
                    // So do NOT mark it as changed - keep original value
                    const originalValue = network.months && network.months[monthIndex] ? network.months[monthIndex] : '-';
                    updatedMonths[monthIndex] = originalValue;
                    console.log(`     üö´ NOT IN MODAL: ${customer.name} - ${network.name} - Month ${monthIndex + 1} keeping original: "${originalValue}"`);
                }
            }
            
            // CRITICAL: Only mark as edited if there were ACTUAL changes
            if (hasChanges) {
                network.months = updatedMonths;
                network.monthly_runs = updatedMonths;
                network.editedData = true; // Mark as edited ONLY if changes found
                
                // Store edited data in localStorage for DB customers too
                const storageKey = `edited_db_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                localStorage.setItem(storageKey, JSON.stringify({
                    months: updatedMonths,
                    originalMonths: network.originalMonths,
                    timestamp: Date.now(),
                    customer: customer.name,
                    network: network.name,
                    source: 'db'
                }));
                
                updatedCount++;
                console.log(`   ‚úÖ ACTUALLY EDITED: ${customer.name} - ${network.name} (saved to localStorage)`);
            } else {
                // CRITICAL: Ensure editedData flag is FALSE for non-edited networks
                network.editedData = false;
                console.log(`   ‚ÑπÔ∏è NO CHANGES: ${customer.name} - ${network.name} - keeping original state (editedData = false)`);
            }
        });
    });
    
    // Success notification
    const excelCount = excelCustomers.reduce((count, customer) => 
        count + customer.networks.length, 0
    );
    const dbCount = updatedCount - excelCount;
    
    let message = '';
    if (updatedCount > 0) {
        if (excelCount > 0 && dbCount > 0) {
            message = `‚úÖ Updated ${excelCount} Excel networks and ${dbCount} DB networks! (Local changes)`;
        } else if (excelCount > 0) {
            message = `‚úÖ Updated ${excelCount} Excel networks! (Local changes)`;
        } else {
            message = `‚úÖ Updated ${dbCount} DB networks! (Local changes)`;
        }
    } else {
        message = `‚ÑπÔ∏è No changes detected`;
    }
    
    showNotification(message, 'success');
    closeBulkEditModal();
    
    // CRITICAL FIX: Do NOT update statistics for DB customers - causes double counting
    // Only update UI display to show edited data
    if (updatedCount > 0) {
        console.log(`üíæ Updated ${updatedCount} networks - refreshing display only (no statistics change)`);
        
        // ONLY update the visual display - do not touch statistics
        setTimeout(() => {
            updateCustomerGrid(); // This shows the edited network data
        }, 500);
        
        // Do NOT update global statistics, header counts, or graphs
        // Let them stay as original API data to prevent double counting
        console.log(`‚ÑπÔ∏è Statistics kept unchanged to prevent double counting`);
    }
}

function updateCustomerGrid() {
    const tableBody = document.getElementById('customer-table-body');
    const customers = dashboardData.customers;
    
    if (!customers || Object.keys(customers).length === 0) {
        tableBody.innerHTML = '<tr><td colspan="19" style="padding: 40px; text-align: center; color: #6b7280;">No customer data available</td></tr>';
        return;
    }
    
    tableBody.innerHTML = '';
    
    // Get current year for month calculations - AUTO DETECT YEAR FROM DATA
    const currentYear = new Date().getFullYear();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Auto-detect which year to use based on actual data
    let displayYear = currentYear;
    const dataYears = new Set();
    
    // Scan all customer data to find which years have actual data
    Object.values(customers).forEach(customer => {
        if (customer.networks && Array.isArray(customer.networks)) {
            customer.networks.forEach(network => {
                if (network.last_run_date && network.last_run_date !== 'Never' && network.runs > 0) {
                    const networkDate = fixDateParsing(network.last_run_date);
                    if (networkDate) {
                        dataYears.add(networkDate.getFullYear());
                    }
                }
            });
        }
    });
    
    // FORCE 2025 for network dates (our database has 2025 data)
    displayYear = 2025;
    console.log(`üìÖ FORCED DISPLAY YEAR: ${displayYear} (database contains 2025 data)`);
    
    // Use the most recent year with data, or current year as fallback
    // if (dataYears.size > 0) {
    //     displayYear = Math.max(...Array.from(dataYears));
    //     console.log(`üìÖ AUTO-DETECTED DISPLAY YEAR: ${displayYear} (found data years: ${Array.from(dataYears).join(', ')})`);
    // } else {
    //     console.log(`üìÖ USING CURRENT YEAR: ${displayYear} (no data found in any year)`);
    // }
    
    Object.values(customers).forEach(customer => {
        // 1. CUSTOMER LEVEL ROW (Summary)
        const customerRow = createCustomerSummaryRow(customer, displayYear, months);
        tableBody.appendChild(customerRow);
        
        // 2. NETWORK LEVEL ROWS (Individual networks)
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach((network, networkIndex) => {
                const networkRow = createNetworkDetailRow(customer, network, networkIndex, displayYear, months);
                tableBody.appendChild(networkRow);
            });
        } else if (customer.excel_source) {
            // For Excel customers, if networks array exists, use it; otherwise create from networks_count
            let networksToShow = customer.networks || [];
            
            if (networksToShow.length === 0 && customer.networks_count > 0) {
                // Create networks based on Excel data structure
                for (let i = 0; i < customer.networks_count; i++) {
                    networksToShow.push({
                        name: `${customer.name}_Network_${i + 1}`,
                        network_name: `${customer.name} Network ${i + 1}`,
                        runs: Math.ceil(customer.runs / customer.networks_count),
                        last_run_date: customer.last_run_date,
                        node_count: Math.ceil(customer.node_count / customer.networks_count),
                        monthly_runs: customer.monthly_runs // Share customer's monthly data
                    });
                }
            }
            
            // Display the networks
            networksToShow.forEach((network, networkIndex) => {
                const networkRow = createNetworkDetailRow(customer, network, networkIndex, displayYear, months);
                tableBody.appendChild(networkRow);
            });
        }
    });
}

// CREATE CUSTOMER SUMMARY ROW
function createCustomerSummaryRow(customer, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'customer-summary-row';
    
    // ENHANCED: Use the ACTUAL last run date we retrieved, with multiple fallbacks
    let lastRunInfo = 'Never';
    let lastRunDateStr = customer.actual_last_run || customer.last_run_date;
    
    if (lastRunDateStr && lastRunDateStr !== 'Never' && lastRunDateStr !== '-') {
        const lastRunDate = fixDateParsing(lastRunDateStr);
        if (lastRunDate) {
            lastRunInfo = lastRunDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: '2-digit'
            });
            console.log(`‚úÖ DISPLAYING: Customer "${customer.name}" - "${lastRunDateStr}" -> ${lastRunInfo}`);
        } else {
            console.log(`‚ùå PARSE FAILED: Customer "${customer.name}" - Could not parse "${lastRunDateStr}"`);
            lastRunInfo = lastRunDateStr; // Show original string if parsing fails
        }
    } else {
        console.log(`‚ö†Ô∏è NO DATE: Customer "${customer.name}" has no valid date information`);
        
        // Check if customer has runs but no date - this indicates missing date integration
        const totalRuns = customer.runs || customer.run_count || customer.total_runs || 0;
        if (totalRuns > 0) {
            lastRunInfo = 'Date missing'; // Clearly indicate missing date for customers with runs
            console.log(`‚ùå DATE INTEGRATION ISSUE: Customer "${customer.name}" has ${totalRuns} runs but no date!`);
        }
    }
    
    // Customer Name with Source Indicator
    const customerCell = document.createElement('td');
    customerCell.className = 'customer-name-cell customer-summary';
    
    // Determine source badge
    let sourceBadge = '';
    let sourceIcon = 'üìã'; // Default database icon
    
    if (customer.excel_only) {
        sourceBadge = '<span style="font-size: 0.6rem; background: #6b7280; color: white; padding: 1px 4px; border-radius: 3px; margin-left: 4px;">üìÑ Excel</span>';
        sourceIcon = 'üìÑ';
    } else if (customer.excel_data) {
        sourceBadge = '<span style="font-size: 0.6rem; background: #3b82f6; color: white; padding: 1px 4px; border-radius: 3px; margin-left: 4px;">üîÑ Live+Excel</span>';
        sourceIcon = 'üîÑ';
    } else {
        sourceBadge = '<span style="font-size: 0.6rem; background: #10b981; color: white; padding: 1px 4px; border-radius: 3px; margin-left: 4px;">üíæ Live DB</span>';
        sourceIcon = 'üíæ';
    }
    
    customerCell.innerHTML = `
        <div class="customer-name-container">
            <div class="customer-name-main">${sourceIcon} ${customer.name || 'Unknown Customer'}${sourceBadge}</div>
            <div class="customer-last-run">Last run: ${lastRunInfo}</div>
        </div>
    `;
    row.appendChild(customerCell);
    
    // Country - Fix field mapping
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col customer-summary';
    const country = customer.country || customer.location || customer.region || 'Unknown';
    countryCell.textContent = country;
    countryCell.style.color = country === 'Unknown' ? '#9ca3af' : '#374151';
    row.appendChild(countryCell);
    
    // Networks Summary - Fix to use Excel data properly
    const networksCell = document.createElement('td');
    networksCell.className = 'networks-cell customer-summary';
    let networkCount = 0;
    if (customer.networks_count) {
        networkCount = customer.networks_count;
    } else if (customer.networks && customer.networks.length > 0) {
        networkCount = customer.networks.length;
    } else if (customer.excel_source && customer.runs > 0) {
        // For Excel customers without networks array, estimate from runs
        networkCount = Math.max(1, Math.floor(customer.runs / 5)); // Rough estimate
    }
    networksCell.innerHTML = `
        <div class="networks-summary">
            <span class="network-count-badge-large">${networkCount} network${networkCount !== 1 ? 's' : ''}</span>
        </div>
    `;
    row.appendChild(networksCell);
    
    // Node Qty - Enhanced logic to fetch from multiple sources
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col customer-summary';
    
    let nodeQty = 0;
    
    // Debug: Log available customer data fields
    console.log(`üîç DEBUG: Customer "${customer.name}" available fields:`, Object.keys(customer));
    console.log(`üîç DEBUG: Customer "${customer.name}" full data:`, customer);
    console.log(`üîç DEBUG: node_count = ${customer.node_count}, country = ${customer.country}`);
    console.log(`üîç DEBUG: runs = ${customer.runs}, networks = ${customer.networks_count}`);
    
    // Force update for testing
    if (customer.name && customer.name.toUpperCase().includes('BSNL')) {
        console.log(`üö® BSNL CUSTOMER DETECTED: ${customer.name}`);
        console.log('üö® Available fields:', Object.keys(customer));
        console.log('üö® Field values:', {
            node_count: customer.node_count,
            country: customer.country,
            runs: customer.runs,
            networks_count: customer.networks_count
        });
    }
    
    // Fix: Try multiple data sources for node quantity with Excel mapping
    nodeQty = customer.node_count || customer.node_qty || customer.total_nodes || 0;
    
    // Special handling for Excel data
    if (!nodeQty && customer.excel_source) {
        console.log(`Excel customer ${customer.name} - checking all fields:`, Object.keys(customer));
    }
    
    // If still no data, try to calculate from networks
    if (!nodeQty && customer.networks && customer.networks.length > 0) {
        nodeQty = customer.networks.reduce((total, network) => {
            return total + (network.node_count || network.nodes || network.total_nodes || 0);
        }, 0);
    }
    
    // Debug: Log what we found
    console.log(`üîç DEBUG: Customer "${customer.name}" - nodeQty found: ${nodeQty}, runs: ${customer.runs}, run_count: ${customer.run_count}`);
    
    // For now, show 0 instead of N/A to see the layout
    nodeQtyCell.textContent = nodeQty || '0';
    nodeQtyCell.style.fontWeight = '600';
    
    if (nodeQty > 0) {
        nodeQtyCell.style.color = '#059669'; // Green for real data
        nodeQtyCell.title = `${nodeQty} nodes from health check report`;
    } else if (customer.runs > 0 || customer.run_count > 0) {
        nodeQtyCell.style.color = '#f59e0b'; // Orange for missing data
        nodeQtyCell.title = 'Node count not found in API data - check available fields in console';
    } else {
        nodeQtyCell.style.color = '#9ca3af'; // Gray for no runs
        nodeQtyCell.title = 'No runs available';
    }
    
    row.appendChild(nodeQtyCell);
    
    // NE Type - Fix to use Excel data properly
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col customer-summary';
    neTypeCell.textContent = customer.nw_type || customer.ne_type || customer.network_type || '1830 PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#6b7280';
    row.appendChild(neTypeCell);
    
    // GTAC - Fix to use Excel data properly
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col customer-summary';
    const gtacType = customer.gtac_team || customer.gtac || customer.gtac_type || 'PSS';
    gtacCell.innerHTML = `<span style="background: ${gtacType.toLowerCase() === 'classic' ? '#dc2626' : '#059669'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">${gtacType}</span>`;
    row.appendChild(gtacCell);
    
    // Monthly data (Customer total) - Show ONLY FILTERED months if date filter applied
    let totalRuns = 0;
    let monthsToShow = months;
    
    // If date filter applied, only show filtered months
    if (currentStartDate && currentEndDate) {
        const startMonth = new Date(currentStartDate).getMonth();
        const endMonth = new Date(currentEndDate).getMonth();
        monthsToShow = months.slice(startMonth, endMonth + 1);
        console.log(`üìÖ Showing filtered months: ${startMonth + 1}-${endMonth + 1}`);
    }
    
    monthsToShow.forEach((month, filteredIndex) => {
        // Calculate actual month index based on filter
        const actualIndex = currentStartDate && currentEndDate ? 
                           new Date(currentStartDate).getMonth() + filteredIndex : 
                           filteredIndex;
        
        const monthCell = document.createElement('td');
        monthCell.className = 'run-count customer-summary';
        
        const monthRunData = getCustomerMonthRunDates(customer, currentYear, actualIndex + 1);
        if (monthRunData) {
            totalRuns += monthRunData.count;
        }
        
        if (monthRunData && monthRunData.count > 0 && monthRunData.date && monthRunData.date !== '0' && monthRunData.date !== 'undefined') {
            // Show the actual date of the run
            monthCell.textContent = monthRunData.date;
            monthCell.title = `${monthRunData.count} run${monthRunData.count > 1 ? 's' : ''} in ${month} - Latest: ${monthRunData.fullDate}`;
            monthCell.style.color = '#374151';
            if (monthRunData.count > 1) {
                monthCell.style.fontWeight = '700';
            }
        } else {
            // No runs found
            monthCell.textContent = '-';
            monthCell.title = `No runs in ${month}`;
            monthCell.style.color = '#9ca3af';
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs - Use calculated runs that exclude status strings
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell customer-summary';
    
    // ULTRA STRICT: Only recalculate if THIS specific customer has actual edited networks
    let thisCustomerHasEdits = false;
    
    // Very strict check - only for this customer's networks
    if (customer.networks && customer.networks.length > 0) {
        thisCustomerHasEdits = customer.networks.some(network => 
            network.editedData === true && network.months && Array.isArray(network.months)
        );
    }
    
    let displayRuns = 0;
    
    if (thisCustomerHasEdits) {
        // THIS CUSTOMER WAS EDITED: Recalculate total
        customer.networks.forEach(network => {
            if (network.editedData && network.months) {
                // Count valid dates from edited months
                const validDates = network.months.filter(monthValue => {
                    return monthValue && monthValue !== '-' && 
                           !monthValue.toLowerCase().includes('not') && 
                           !monthValue.toLowerCase().includes('never');
                }).length;
                displayRuns += validDates;
            } else {
                // Non-edited network in this customer - use original
                displayRuns += (network.runs || network.total_runs || 0);
            }
        });
        console.log(`‚öôÔ∏è RECALCULATED: ${customer.name} = ${displayRuns} runs (has edited networks)`);
    } else {
        // THIS CUSTOMER WAS NOT EDITED: Use exact original API data
        displayRuns = customer.excel_source ? 
            (customer.runs || customer.total_runs || 0) : 
            (customer.total_runs || customer.runs || customer.run_count || totalRuns || 0);
        console.log(`üîí PROTECTED: ${customer.name} = ${displayRuns} runs (untouched customer)`);
    }
    
    totalCell.textContent = displayRuns;
    row.appendChild(totalCell);
    console.log(`üîç CUSTOMER TOTAL DEBUG: ${customer.name}`);
    console.log(`   customer.total_runs: ${customer.total_runs}`);
    console.log(`   customer.runs: ${customer.runs}`);
    console.log(`   customer.run_count: ${customer.run_count}`);
    console.log(`   totalRuns (calculated): ${totalRuns}`);
    console.log(`   final displayRuns: ${displayRuns}`);
    
    totalCell.textContent = displayRuns;
    row.appendChild(totalCell);
    
    
    return row;
}

// CREATE NETWORK DETAIL ROW
function createNetworkDetailRow(customer, network, networkIndex, currentYear, months) {
    const row = document.createElement('tr');
    row.className = 'network-detail-row';
    
    // Clean network name - remove customer prefix like "Bsnl - "
    let networkName = network.network_name || network.name || network;
    
    // If network name is from network.name and has customer prefix, use network_name instead
    if (network.name && network.network_name && network.name.includes(`${customer.name} - `)) {
        networkName = network.network_name;
        console.log(`üßΩ CLEANED: "${network.name}" -> "${networkName}"`);
    } else if (typeof networkName === 'string' && networkName.includes(' - ')) {
        // Remove any prefix before " - " (like "Bsnl - Timedotcom Default" -> "Timedotcom Default")
        const cleanName = networkName.split(' - ').slice(1).join(' - ');
        if (cleanName) {
            console.log(`üßΩ CLEANED PREFIX: "${networkName}" -> "${cleanName}"`);
            networkName = cleanName;
        }
    }
    
    const networkRuns = getNetworkRuns(customer, networkName) || 0;
    
    // Network Name (indented)
    const networkCell = document.createElement('td');
    networkCell.className = 'customer-name-cell network-detail';
    networkCell.innerHTML = `
        <div class="network-name-container">
            <div class="network-name-main">‚îî‚îÄ ${networkName}</div>
            <div class="network-type">${network.network_type || 'Default Network'}</div>
        </div>
    `;
    row.appendChild(networkCell);
    
    // Country (empty for network rows)
    const countryCell = document.createElement('td');
    countryCell.className = 'info-col network-detail';
    countryCell.textContent = '';
    row.appendChild(countryCell);
    
    // Network Status/Info
    const statusCell = document.createElement('td');
    statusCell.className = 'networks-cell network-detail';
    statusCell.innerHTML = `
        <div class="network-status">
            <span class="network-runs-badge">${networkRuns} runs</span>
        </div>
    `;
    row.appendChild(statusCell);
    
    // Node Qty for this network - Enhanced logic
    const nodeQtyCell = document.createElement('td');
    nodeQtyCell.className = 'info-col network-detail';
    
    const networkNodeQty = network.node_count || 
                           network.nodes || 
                           network.total_nodes ||
                           network.node_quantity ||
                           (network.report_data && network.report_data.node_count) ||
                           0;
    
    if (networkNodeQty > 0) {
        nodeQtyCell.textContent = networkNodeQty;
        nodeQtyCell.style.color = '#6b7280';
        nodeQtyCell.title = `${networkNodeQty} nodes in this network`;
    } else {
        nodeQtyCell.textContent = '-';
        nodeQtyCell.style.color = '#9ca3af';
    }
    
    nodeQtyCell.style.fontSize = '0.75rem';
    row.appendChild(nodeQtyCell);
    
    // NE Type for this network
    const neTypeCell = document.createElement('td');
    neTypeCell.className = 'info-col network-detail';
    neTypeCell.textContent = network.ne_type || network.equipment_type || 'PSS';
    neTypeCell.style.fontSize = '0.7rem';
    neTypeCell.style.color = '#9ca3af';
    row.appendChild(neTypeCell);
    
    // GTAC (empty for network rows)
    const gtacCell = document.createElement('td');
    gtacCell.className = 'info-col network-detail';
    gtacCell.textContent = '';
    row.appendChild(gtacCell);
    
    // Monthly data for this specific network - Show ONLY FILTERED months
    let monthsToShow = months;
    
    // If date filter applied, only show filtered months
    if (currentStartDate && currentEndDate) {
        const startMonth = new Date(currentStartDate).getMonth();
        const endMonth = new Date(currentEndDate).getMonth();
        monthsToShow = months.slice(startMonth, endMonth + 1);
    }
    
    monthsToShow.forEach((month, filteredIndex) => {
        // Calculate actual month index based on filter
        const actualIndex = currentStartDate && currentEndDate ? 
                           new Date(currentStartDate).getMonth() + filteredIndex : 
                           filteredIndex;
        
        const monthCell = document.createElement('td');
        monthCell.className = 'run-count network-detail';
        
        // FIXED LOGIC: Use network's months array (formatted by backend)
        let networkDateValue = '-';
        
        // Find the specific network object
        const targetNetwork = customer.networks && customer.networks.find(net => {
            const netName = net.network_name || net.name || '';
            return netName === networkName || netName.includes(networkName) || networkName.includes(netName);
        });
        
        console.log(`üîç NETWORK DEBUG: Looking for "${networkName}" in customer "${customer.name}"`);
        
        if (targetNetwork) {
            console.log(`‚úÖ Found target network:`, targetNetwork.network_name || targetNetwork.name);
            console.log(`üìÖ Network months array:`, targetNetwork.months);
            
            // PRIORITY 1: Use the formatted months array from backend API
            if (targetNetwork.months && Array.isArray(targetNetwork.months) && actualIndex < targetNetwork.months.length) {
                const monthValue = targetNetwork.months[actualIndex];
                if (monthValue && monthValue !== '-') {
                    networkDateValue = monthValue;
                    console.log(`‚úÖ USING MONTHS ARRAY: ${networkName} month ${actualIndex + 1} = ${monthValue}`);
                }
            }
            // FALLBACK: Try monthly_runs dictionary if months array not available
            else if (targetNetwork.monthly_runs && typeof targetNetwork.monthly_runs === 'object') {
                const monthKey = `2025-${String(actualIndex + 1).padStart(2, '0')}`;
                const dbDate = targetNetwork.monthly_runs[monthKey];
                
                console.log(`üîÑ FALLBACK: Checking monthKey: ${monthKey} -> ${dbDate}`);
                
                if (dbDate && dbDate !== '-') {
                    if (dbDate === 'Not Started' || dbDate === 'No Report' || dbDate === 'Not Run') {
                        networkDateValue = dbDate;
                    } else {
                        try {
                            // Convert "2025-01-03" to "3-Jan"
                            const dateObj = new Date(dbDate);
                            if (!isNaN(dateObj.getTime())) {
                                const day = dateObj.getDate();
                                const monthName = dateObj.toLocaleDateString('en-US', { month: 'short' });
                                networkDateValue = `${day}-${monthName}`;
                                console.log(`‚úÖ FALLBACK SUCCESS: ${networkName} ${monthKey} = ${dbDate} -> ${networkDateValue}`);
                            }
                        } catch (e) {
                            networkDateValue = String(dbDate);
                            console.log(`‚ö†Ô∏è Using raw value: ${dbDate}`);
                        }
                    }
                }
            } else {
                console.log(`‚ùå No months array or monthly_runs data for ${networkName}`);
            }
        } else {
            console.log(`‚ùå Network "${networkName}" not found in customer.networks`);
        }
        
        // Render the date
        if (networkDateValue !== '-') {
            monthCell.textContent = networkDateValue;
            monthCell.title = `Network ${networkName} - ${networkDateValue}`;
            monthCell.style.color = '#374151';
            monthCell.style.fontWeight = '500';
        } else {
            monthCell.textContent = '-';
            monthCell.title = `No data for ${networkName} in ${month}`;
            monthCell.style.color = '#9ca3af';
        }
        
        row.appendChild(monthCell);
    });
    
    // Total Runs for this network
    const totalCell = document.createElement('td');
    totalCell.className = 'total-runs-cell network-detail';
    totalCell.textContent = networkRuns;
    row.appendChild(totalCell);
    
    
    return row;
}

// Get run counts for a specific network of a customer
function getNetworkRuns(customer, networkName) {
    console.log(`üîç Getting runs for network "${networkName}" of customer "${customer.name}"`);
    
    // ULTRA STRICT VALIDATION: First check if ANY customer has edits - if yes, be extra careful
    const allCustomers = Object.values(dashboardData.customers || {});
    const hasAnyEdits = allCustomers.some(cust => 
        cust.networks && cust.networks.some(net => net.editedData)
    );
    
    if (hasAnyEdits) {
        console.log(`‚ö†Ô∏è EDIT MODE DETECTED: Extra strict validation for ${customer.name} - ${networkName}`);
        
        // In edit mode, ONLY process networks that belong to customers with actual edits
        const thisCustomerHasEdits = customer.networks && customer.networks.some(net => net.editedData);
        
        if (!thisCustomerHasEdits) {
            // This customer has NO edits - restore original API data logic
            console.log(`üîí PROTECTED CUSTOMER MODE: ${customer.name} - ${networkName}`);
            
            // Check network_runs first (most accurate)
            if (customer.network_runs && customer.network_runs[networkName] !== undefined) {
                const runs = customer.network_runs[networkName];
                console.log(`üîí PROTECTED NETWORK_RUNS: ${networkName} = ${runs} runs`);
                return runs;
            }
            
            // For DB customers without network_runs, use original working logic from before edits were introduced
            if (customer.networks && Array.isArray(customer.networks)) {
                for (const network of customer.networks) {
                    const originalName = network.name;
                    const networkNameField = network.network_name;
                    const cleanedName = originalName && originalName.includes(' - ') ? 
                                        originalName.split(' - ').slice(1).join(' - ') : originalName;
                    
                    if ((originalName === networkName) || 
                        (networkNameField === networkName) || 
                        (cleanedName === networkName)) {
                        
                        // Check if individual network has run data
                        const individualRuns = network.runs || network.total_runs;
                        if (individualRuns && individualRuns > 0) {
                            console.log(`üîí PROTECTED INDIVIDUAL: ${networkName} = ${individualRuns} runs`);
                            return individualRuns;
                        }
                        
                        // For DB networks, use the original pre-edit logic
                        if (network.last_run_date && 
                            network.last_run_date !== 'Never' && 
                            network.last_run_date !== '-') {
                            
                            // This network has real data - return reasonable count based on presence of date
                            // Use the customer's total runs distributed among networks that have data
                            const customerTotalRuns = customer.total_runs || customer.runs || customer.run_count || 0;
                            const networksWithData = customer.networks.filter(net => 
                                net.last_run_date && net.last_run_date !== 'Never' && net.last_run_date !== '-'
                            ).length;
                            
                            if (networksWithData > 0 && customerTotalRuns > 0) {
                                const distributedRuns = Math.max(1, Math.floor(customerTotalRuns / networksWithData));
                                console.log(`üîí PROTECTED DISTRIBUTED: ${networkName} = ${distributedRuns} runs (${customerTotalRuns}/${networksWithData})`);
                                return distributedRuns;
                            } else {
                                console.log(`üîí PROTECTED DEFAULT: ${networkName} = 1 run (has date)`);
                                return 1;
                            }
                        } else {
                            console.log(`üîí PROTECTED NO DATA: ${networkName} = 0 runs (no date)`);
                            return 0;
                        }
                    }
                }
            }
            
            console.log(`üîí PROTECTED: ${networkName} not found, returning 0`);
            return 0;
        }
    }
    
    // ULTRA STRICT: Only check for edited months if EXACTLY this network was edited
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            const originalName = network.name;
            const networkNameField = network.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            return (originalName === networkName) || 
                   (networkNameField === networkName) || 
                   (cleanedName === networkName);
        });
        
        // CRITICAL CHECK: Only proceed with months logic if this SPECIFIC network has months array
        if (targetNetwork && targetNetwork.months && Array.isArray(targetNetwork.months) && targetNetwork.editedData) {
            console.log(`üîç EDITED CHECK: Network "${networkName}" has editedData flag: ${targetNetwork.editedData}`);
            
            if (customer.excel_source || customer.excel_data) {
                // Excel customers: Recalculate runs from months array
                const calculatedRuns = targetNetwork.months.filter(monthValue => {
                    return monthValue && 
                           monthValue !== '-' && 
                           monthValue !== 'Not Started' && 
                           monthValue !== 'Not Run' && 
                           monthValue !== 'No Report' &&
                           !monthValue.toLowerCase().includes('not');
                }).length;
                
                console.log(`‚úÖ Excel EDITED: Calculated ${calculatedRuns} runs for "${networkName}"`);
                return calculatedRuns;
            } else {
                // DB customers: CRITICAL FIX - NO DOUBLE COUNTING, JUST RETURN ORIGINAL + SINGLE ADJUSTMENT
                if (targetNetwork.originalMonths) {
                    
                    // SIMPLE FIX: Just count how many valid dates exist in edited months
                    const editedValidDates = targetNetwork.months.filter(monthValue => {
                        return monthValue && monthValue !== '-' && 
                               !monthValue.toLowerCase().includes('not') && 
                               !monthValue.toLowerCase().includes('never');
                    }).length;
                    
                    // Count how many valid dates existed originally  
                    const originalValidDates = targetNetwork.originalMonths.filter(monthValue => {
                        return monthValue && monthValue !== '-' && 
                               !monthValue.toLowerCase().includes('not') && 
                               !monthValue.toLowerCase().includes('never');
                    }).length;
                    
                    const originalNetworkRuns = targetNetwork.runs || targetNetwork.total_runs || 0;
                    
                    // SINGLE COUNTING: Original runs + ONLY the net difference
                    const netDifference = editedValidDates - originalValidDates;
                    const finalRuns = Math.max(0, originalNetworkRuns + netDifference);
                    
                    console.log(`‚úÖ DB SINGLE COUNT: "${networkName}" original:${originalNetworkRuns} + diff:(${editedValidDates}-${originalValidDates}) = ${finalRuns} runs`);
                    return finalRuns;
                }
            }
        }
    }
    
    // PRIORITY 2: For non-edited networks, return EXACT original runs
    if (customer.networks && Array.isArray(customer.networks)) {
        for (const network of customer.networks) {
            // Try multiple matching strategies for cleaned names
            const originalName = network.name;
            const networkNameField = network.network_name;
            const cleanedName = originalName && originalName.includes(' - ') ? 
                                originalName.split(' - ').slice(1).join(' - ') : originalName;
            
            // Match against all possible name variations
            if ((originalName === networkName) || 
                (networkNameField === networkName) || 
                (cleanedName === networkName)) {
                
                // STRICT: If this network was NOT edited, return EXACT original
                if (!network.editedData) {
                    const originalRuns = network.runs || network.total_runs || 0;
                    console.log(`‚úÖ DB UNTOUCHED: "${networkName}" keeping EXACT ${originalRuns} runs (never edited)`);
                    return originalRuns;
                } else {
                    // This should not happen - edited networks should be handled above
                    console.log(`‚ö†Ô∏è DB EDITED FALLBACK: "${networkName}" was edited but handled here`);
                    const originalRuns = network.runs || network.total_runs || 0;
                    return originalRuns;
                }
            }
        }
    }
    
    // PRIORITY 3: Check network_runs data
    if (customer.network_runs && customer.network_runs[networkName] !== undefined) {
        const runs = customer.network_runs[networkName];
        console.log(`‚úÖ Found ${runs} runs for network "${networkName}" from network_runs data`);
        return runs;
    }
    
    // CRITICAL FIX: NO FALLBACK DISTRIBUTION for DB customers - causes cross-contamination
    // Return 0 instead of trying to distribute runs, which affects other networks
    console.log(`‚ö†Ô∏è Network "${networkName}" not found in customer "${customer.name}" - returning 0 to prevent cross-contamination`);
    return 0;
}

// Get network-specific monthly runs
function getNetworkMonthRuns(customer, networkName, year, month) {
    console.log(`üîç Getting monthly runs for network "${networkName}" in month ${month}`);
    
    // Check if customer has network-specific monthly data
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        const runs = customer.network_monthly_runs[networkName][month];
        console.log(`‚úÖ Found ${runs} runs for ${networkName} in month ${month}`);
        return runs;
    }
    
    // CRITICAL FIX: NO FALLBACK DISTRIBUTION for monthly runs - causes cross-contamination
    // Return 0 instead of trying to distribute monthly runs among networks
    
    console.log(`‚ö†Ô∏è No monthly runs found for network "${networkName}" in month ${month}`);
    return 0;
}

// Get monthly run counts for a customer with CORRECT network-level date handling
function getCustomerMonthRuns(customer, year, month) {
    console.log(`üîç Getting monthly runs for ${customer.name}, month ${month}, total runs: ${customer.runs || 0}`);
    
    // PRIORITY 1: Use database network months array (0-based indexing)
    if (customer.networks && Array.isArray(customer.networks)) {
        let totalRunsFromNetworks = 0;
        
        customer.networks.forEach(network => {
            if (network.months && Array.isArray(network.months)) {
                const monthIndex = month - 1; // Convert 1-based month to 0-based index
                const monthValue = network.months[monthIndex];
                
                // Count actual runs (not status messages)
                if (monthValue && monthValue !== '-' && 
                    monthValue !== 'Not Started' && 
                    monthValue !== 'Not Run' && 
                    monthValue !== 'No Report' &&
                    !monthValue.toLowerCase().includes('not')) {
                    totalRunsFromNetworks++;
                    console.log(`‚úÖ Network ${network.name} has run in month ${month}: ${monthValue}`);
                }
            }
        });
        
        if (totalRunsFromNetworks > 0) {
            console.log(`‚úÖ NETWORK TOTAL: ${customer.name} has ${totalRunsFromNetworks} runs in month ${month} from networks`);
            return totalRunsFromNetworks;
        }
    }
    
    // Check if customer has monthly_runs data structure (fallback)
    if (customer.monthly_runs && customer.monthly_runs[month] !== undefined) {
        const monthValue = customer.monthly_runs[month];
        console.log(`‚úÖ Found API monthly data for month ${month}: ${monthValue}`);
        if (monthValue > 0) {
            return monthValue;
        }
    }
    
    // Check for month-specific fields like jan_runs, feb_runs, etc.
    const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
    const monthField = `${monthNames[month-1]}_runs`;
    if (customer[monthField] !== undefined) {
        console.log(`‚úÖ Found ${monthField}: ${customer[monthField]}`);
        return customer[monthField];
    }
    
    // Check monthlyStats array (old format)
    if (customer.monthlyStats && Array.isArray(customer.monthlyStats)) {
        const monthData = customer.monthlyStats.find(m => {
            // Match by month name or index
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return m.month === monthNames[month-1] || m.monthIndex === month-1;
        });
        if (monthData) {
            console.log(`‚úÖ Found monthlyStats for month ${month}: ${monthData.runs}`);
            return monthData.runs || 0;
        }
    }
    
    // USE REAL SESSION DATES ONLY: Check if customer has actual session dates
    if (customer.sessions || customer.run_history || customer.session_dates) {
        const sessions = customer.sessions || customer.run_history || customer.session_dates || [];
        let realMonthRuns = 0;
        
        console.log(`üìÖ Checking REAL session dates for ${customer.name}:`, sessions);
        
        if (Array.isArray(sessions)) {
            sessions.forEach(session => {
                const sessionDate = new Date(session.date || session.created_at || session.timestamp || session);
                if (!isNaN(sessionDate.getTime())) {
                    const sessionYear = sessionDate.getFullYear();
                    const sessionMonth = sessionDate.getMonth() + 1;
                    
                    if (sessionYear === year && sessionMonth === month) {
                        realMonthRuns++;
                        console.log(`‚úÖ REAL session found in ${month}/${year}: ${sessionDate.toDateString()}`);
                    }
                }
            });
        }
        
        if (realMonthRuns > 0) {
            console.log(`‚úÖ REAL monthly data: ${customer.name} has ${realMonthRuns} runs in ${month}/${year}`);
            return realMonthRuns;
        }
    }
    
    // DISABLED: last_run_date logic removed to prevent October spike
    // Only use network-level months data for accurate month calculations
    
    console.log(`‚ö™ No runs for ${customer.name} in month ${month}`);
    return 0;
}

// ENHANCED: Get monthly run dates for a customer with REAL session dates
function getCustomerMonthRunDates(customer, year, month) {
    console.log(`üìÖ ENHANCED: Getting REAL run dates for ${customer.name} for month ${month}/${year}`);
    
    // PRIORITY 1: Extract dates from database networks using months array
    if (customer.networks && Array.isArray(customer.networks)) {
        let totalRunsThisMonth = 0;
        let latestDate = null;
        let latestDateTime = null;
        
        // Check each network for runs in this month
        customer.networks.forEach(network => {
            // DATABASE NETWORKS: Use months array (index 0-11 for Jan-Dec)
            if (network.months && Array.isArray(network.months)) {
                const monthIndex = month - 1; // Convert to 0-based index
                const monthValue = network.months[monthIndex];
                
                if (monthValue && monthValue !== '-' && 
                    monthValue !== 'Not Started' && 
                    monthValue !== 'Not Run' && 
                    monthValue !== 'No Report') {
                    
                    totalRunsThisMonth++;
                    latestDate = monthValue; // This is already formatted as "11-Jan", "05-Feb" etc.
                    
                    console.log(`‚úÖ DB NETWORK MONTH: ${network.name} - month ${month} = "${monthValue}"`);
                }
            }
            // EXCEL NETWORKS: Use last_run_date (for backward compatibility)
            else if (network.last_run_date && 
                     network.last_run_date !== 'Never' && 
                     network.last_run_date !== '-' && 
                     network.runs > 0) {
                
                const networkDate = fixDateParsing(network.last_run_date);
                if (networkDate) {
                    const networkYear = networkDate.getFullYear();
                    const networkMonth = networkDate.getMonth() + 1;
                    
                    // If this network's last run was in the requested month/year
                    if (networkYear === year && networkMonth === month) {
                        totalRunsThisMonth += network.runs;
                        
                        // Keep track of the latest date from all networks in this month
                        if (!latestDateTime || networkDate > latestDateTime) {
                            latestDateTime = networkDate;
                            const day = networkDate.getDate();
                            const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                            const yearShort = networkDate.getFullYear().toString().slice(-2);
                            latestDate = `${day}-${monthName}-${yearShort}`;
                        }
                        
                        console.log(`‚úÖ EXCEL NETWORK DATE MATCH: ${network.name} - ${network.runs} runs on ${network.last_run_date} -> formatted as ${latestDate}`);
                    }
                }
            } else {
                // Only log for networks that have 0 runs
                if (network.runs === 0) {
                    console.log(`‚ö™ SKIPPED: ${network.name} - 0 runs (correctly showing no date)`);
                }
            }
        });
        
        if (totalRunsThisMonth > 0 && latestDate) {
            console.log(`‚úÖ API DATE SUCCESS: ${customer.name} has ${totalRunsThisMonth} runs in ${month}/${year} with latest date: ${latestDate}`);
            return {
                count: totalRunsThisMonth,
                date: latestDate,
                fullDate: latestDateTime ? latestDateTime.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                }) : latestDate  // Use formatted date as fallback for database networks
            };
        }
    }
    
    // EXCEL PRIORITY: Check Excel networks monthly data (months array)
    if (customer.excel_source || customer.excel_data) {
        console.log(`üìä EXCEL DATA: Processing monthly data for Excel customer: ${customer.name}`);
        
        if (customer.networks && Array.isArray(customer.networks)) {
            let totalRunsThisMonth = 0;
            let latestDate = null;
            
            // Check each Excel network for data in this month
            customer.networks.forEach(network => {
                const months = network.months || network.monthly_runs || [];
                const monthIndex = month - 1; // Convert to 0-based index (Jan=0)
                const monthValue = months[monthIndex];
                
                console.log(`   üîç Network ${network.name}: month ${month} (index ${monthIndex}) = "${monthValue}"`);
                
                // Show EXACT Excel data - whatever is in Excel file
                if (monthValue) {
                    // Count only actual date runs for statistics
                    if (monthValue !== '-' && 
                        monthValue !== 'Not Started' && 
                        monthValue !== 'Not Run' &&
                        monthValue !== 'No Report' &&
                        monthValue.includes('-') && 
                        !monthValue.toLowerCase().includes('not')) {
                        totalRunsThisMonth++;
                    }
                    
                    // Always show whatever is in Excel - dates, status, everything
                    latestDate = monthValue;
                    console.log(`     üìä Excel shows: ${monthValue}`);
                }
            });
            
            if (latestDate) {
                console.log(`‚úÖ EXCEL SUCCESS: ${customer.name} shows "${latestDate}" for month ${month} (${totalRunsThisMonth} actual runs)`);
                return {
                    count: totalRunsThisMonth, // Only count actual runs for stats
                    date: latestDate, // Show date OR status string
                    fullDate: latestDate
                };
            }
        }
        
        console.log(`   ‚ùå No Excel data found for ${customer.name} in month ${month}`);
    }
    
    // PRIORITY 1: Check Excel monthly_runs array (index 0-11 for Jan-Dec)
    if (customer.monthly_runs && Array.isArray(customer.monthly_runs)) {
        const monthIndex = month - 1; // Convert to 0-based index
        const monthValue = customer.monthly_runs[monthIndex];
        if (monthValue && monthValue !== '-' && monthValue !== 'Not Started') {
            return {
                count: 1,
                date: monthValue,
                fullDate: monthValue
            };
        }
    }
    
    // PRIORITY 2: Check if we have monthly_runs object format
    if (customer.monthly_runs && customer.monthly_runs[month]) {
        const monthData = customer.monthly_runs[month];
        
        // If it's an object with count and date (enhanced format)
        if (typeof monthData === 'object' && monthData.count !== undefined) {
            if (monthData.count > 0 && monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(`‚úÖ REAL DATA: ${customer.name} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,
                    fullDate: monthData.fullDate || monthData.date
                };
            } else if (monthData.count > 0) {
                // Has count but no date - this is the issue we're fixing!
                console.log(`‚ö†Ô∏è MISSING DATE: ${customer.name} has ${monthData.count} runs but no date for month ${month}`);
                // Try to get actual last run date
                const actualDate = getActualDateForCustomerMonth(customer, year, month);
                if (actualDate) {
                    return {
                        count: monthData.count,
                        date: actualDate,
                        fullDate: actualDate
                    };
                }
            }
        } else if (typeof monthData === 'number' && monthData > 0) {
            // Simple number format
            console.log(`üî¢ NUMERIC DATA: ${customer.name} has ${monthData} runs in month ${month}`);
            const actualDate = getActualDateForCustomerMonth(customer, year, month);
            if (actualDate) {
                return {
                    count: monthData,
                    date: actualDate,
                    fullDate: actualDate
                };
            }
        }
    }
    
    // SECOND PRIORITY: Check network monthly data for actual dates
    if (customer.network_monthly_runs) {
        for (const [networkName, networkMonthly] of Object.entries(customer.network_monthly_runs)) {
            if (networkMonthly[month] && networkMonthly[month].count > 0 && networkMonthly[month].date) {
                console.log(`‚úÖ NETWORK DATE: Found date from network ${networkName}: ${networkMonthly[month].date}`);
                return {
                    count: networkMonthly[month].count,
                    date: networkMonthly[month].date,
                    fullDate: networkMonthly[month].fullDate || networkMonthly[month].date
                };
            }
        }
    }
    
    // THIRD PRIORITY: Check if this customer's last run was in this specific month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate) {
            const lastRunYear = lastRunDate.getFullYear();
            const lastRunMonth = lastRunDate.getMonth() + 1;
            
            if (year === lastRunYear && month === lastRunMonth) {
                const totalRuns = customer.runs || customer.run_count || 0;
                if (totalRuns > 0) {
                    const day = lastRunDate.getDate();
                    const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = lastRunDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(`‚úÖ LAST RUN DATE MATCH: ${customer.name} - ${totalRuns} runs in ${month}/${year} on ${formattedDate}`);
                    return {
                        count: totalRuns,
                        date: formattedDate,
                        fullDate: lastRunDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        }
    }
    
    // FOURTH PRIORITY: Check if we have actual runs but no monthly breakdown
    const totalRuns = customer.runs || customer.run_count || 0;
    if (totalRuns > 0) {
        console.log(`‚ùå DATE INTEGRATION ISSUE: ${customer.name} has ${totalRuns} total runs but no monthly date data for month ${month}`);
    }
    
    // NO RUNS OR NO DATE DATA
    return { count: 0, date: '-', fullDate: 'No runs' };
}

// NEW HELPER FUNCTION: Get actual date for a specific customer month
function getActualDateForCustomerMonth(customer, year, month) {
    console.log(`üîç Getting actual date for ${customer.name} in ${month}/${year}`);
    
    // Try customer's actual_last_run field first
    if (customer.actual_last_run) {
        const actualDate = fixDateParsing(customer.actual_last_run);
        if (actualDate && actualDate.getFullYear() === year && (actualDate.getMonth() + 1) === month) {
            const day = actualDate.getDate();
            const monthName = actualDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = actualDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    // Try last_run_date
    if (customer.last_run_date && customer.last_run_date !== 'Never') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            return `${day}-${monthName}-${yearShort}`;
        }
    }
    
    console.log(`‚ö†Ô∏è No actual date found for ${customer.name} in ${month}/${year}`);
    return null;
}

// ENHANCED: Get monthly run dates for a specific network with REAL session dates
function getNetworkMonthRunDates(customer, networkName, year, month) {
    console.log(`üìÖ ENHANCED: Getting REAL run dates for network "${networkName}" in month ${month}`);
    
    // EDITED DATA PRIORITY: Check if network has edited months data (from edit modal)
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.Network === networkName ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.months && Array.isArray(targetNetwork.months)) {
            const monthIndex = month - 1; // Convert to 0-based index
            const monthValue = targetNetwork.months[monthIndex];
            
            if (monthValue && monthValue !== '-') {
                console.log(`   ‚úÖ Using EDITED data for ${networkName}: ${monthValue}`);
                return {
                    count: monthValue === 'Not Started' || monthValue === 'Not Run' ? 0 : 1,
                    date: monthValue,
                    fullDate: monthValue
                };
            }
        }
    }
    
    // EXCEL PRIORITY: Check Excel network monthly data first
    if (customer.excel_source || customer.excel_data) {
        console.log(`üìä EXCEL NETWORK: Processing Excel network "${networkName}"`);
        
        if (customer.networks && Array.isArray(customer.networks)) {
            const targetNetwork = customer.networks.find(network => {
                return network.network_name === networkName || 
                       network.name === networkName ||
                       network.Network === networkName ||
                       network.name.includes(networkName);
            });
            
            if (targetNetwork) {
                console.log(`   üîç Found Excel network: ${targetNetwork.name}`);
                
                // Check if this network has 0 runs
                if (targetNetwork.runs === 0) {
                    console.log(`   ‚õî Excel network has 0 runs - returning no date`);
                    return { count: 0, date: '-', fullDate: 'No runs' };
                }
                
                // Get Excel monthly data from months array
                const months = targetNetwork.months || targetNetwork.monthly_runs || [];
                const monthIndex = month - 1; // Convert to 0-based index
                const monthValue = months[monthIndex];
                
                console.log(`   üîç Excel network month ${month} (index ${monthIndex}) = "${monthValue}"`);
                
                // Show EXACT Excel data for this network - whatever is in Excel
                if (monthValue) {
                    // Count runs only for actual dates for statistics
                    let runCount = 0;
                    if (monthValue !== '-' && 
                        monthValue !== 'Not Started' && 
                        monthValue !== 'Not Run' &&
                        monthValue !== 'No Report' &&
                        monthValue.includes('-') && 
                        !monthValue.toLowerCase().includes('not')) {
                        runCount = 1;
                    }
                    
                    console.log(`   üìä Excel network shows: ${monthValue}`);
                    return {
                        count: runCount, // Count for statistics
                        date: monthValue, // Show EXACT Excel data
                        fullDate: monthValue
                    };
                } else {
                    console.log(`   ‚ùå Excel network no data for month ${month}`);
                    return { count: 0, date: '-', fullDate: 'No data' };
                }
            }
        }
    }
    
    // CRITICAL FIRST CHECK: If network has 0 runs, return immediately with no date
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(`‚õî ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && targetNetwork.runs === 0) {
            console.log(`‚ö™ ZERO RUNS: ${networkName} has 0 runs - returning no date`);
            return { count: 0, date: '-', fullDate: 'No runs' };
        }
    }
    
    // NEW PRIORITY 1: Extract dates directly from API response for this specific network
    if (customer.networks && Array.isArray(customer.networks)) {
        const targetNetwork = customer.networks.find(network => {
            return network.network_name === networkName || 
                   network.name === networkName ||
                   network.name === `${customer.name} - ${networkName}` ||
                   network.name.includes(networkName);
        });
        
        if (targetNetwork && 
            targetNetwork.last_run_date && 
            targetNetwork.last_run_date !== 'Never' && 
            targetNetwork.last_run_date !== '-' && 
            targetNetwork.runs > 0) {
            
            const networkDate = fixDateParsing(targetNetwork.last_run_date);
            if (networkDate) {
                const networkYear = networkDate.getFullYear();
                const networkMonth = networkDate.getMonth() + 1;
                
                // If this network's last run was in the requested month/year
                if (networkYear === year && networkMonth === month) {
                    const day = networkDate.getDate();
                    const monthName = networkDate.toLocaleDateString('en-US', { month: 'short' });
                    const yearShort = networkDate.getFullYear().toString().slice(-2);
                    const formattedDate = `${day}-${monthName}-${yearShort}`;
                    
                    console.log(`‚úÖ API NETWORK DATE: ${networkName} - ${targetNetwork.runs} runs on ${targetNetwork.last_run_date} -> formatted as ${formattedDate}`);
                    return {
                        count: targetNetwork.runs,
                        date: formattedDate,
                        fullDate: networkDate.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        })
                    };
                }
            }
        } else {
            // Only log for debugging Nokia East (0 runs case)
            if (targetNetwork && targetNetwork.runs === 0) {
                console.log(`‚ö™ NETWORK SKIPPED: ${networkName} - 0 runs (correctly showing no date)`);
            }
        }
    }
    
    // PRIORITY 2: Check if we have enhanced network monthly data with actual dates
    if (customer.network_monthly_runs && 
        customer.network_monthly_runs[networkName] && 
        customer.network_monthly_runs[networkName][month]) {
        
        const monthData = customer.network_monthly_runs[networkName][month];
        console.log(`üîç Network monthly data for ${networkName} month ${month}:`, monthData);
        
        // Enhanced format with actual session dates
        if (typeof monthData === 'object' && monthData.hasData && monthData.count > 0) {
            if (monthData.date && monthData.date !== '-' && monthData.date !== 'Never') {
                console.log(`‚úÖ REAL NETWORK DATE: ${networkName} has ${monthData.count} runs with actual date: ${monthData.date}`);
                return {
                    count: monthData.count,
                    date: monthData.date,  // Real date like "09-Sep-25" from session
                    fullDate: monthData.fullDate || monthData.date
                };
            } else {
                console.log(`‚ö†Ô∏è NETWORK MISSING DATE: ${networkName} has ${monthData.count} runs but no date for month ${month}`);
            }
        }
    }
    
    // PRIORITY 3: Check if customer has data for this network in this month
    const customerRunData = getCustomerMonthRunDates(customer, year, month);
    if (customerRunData && customerRunData.count > 0 && customerRunData.date !== '-') {
        // Get network-specific run count
        const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
        
        if (networkRuns > 0) {
            // FIXED: All networks with runs can inherit customer's actual run date
            // This fixes the issue where only primary networks showed dates
            console.log(`‚úÖ NETWORK INHERITS DATE: ${networkName} (${networkRuns} runs) inherits customer date: ${customerRunData.date}`);
            return {
                count: networkRuns,
                date: customerRunData.date,
                fullDate: customerRunData.fullDate
            };
        }
    }
    
    // PRIORITY 4: Get network-specific runs using old method
    const networkRuns = getNetworkMonthRuns(customer, networkName, year, month);
    
    // If no runs, return early
    if (networkRuns === 0) {
        return { count: 0, date: '-', fullDate: 'No runs' };
    }
    
    // PRIORITY 5: Check if customer has actual last run date for this month
    if (customer.last_run_date && customer.last_run_date !== 'Never' && customer.last_run_date !== '-') {
        const lastRunDate = fixDateParsing(customer.last_run_date);
        if (lastRunDate && lastRunDate.getFullYear() === year && (lastRunDate.getMonth() + 1) === month) {
            const day = lastRunDate.getDate();
            const monthName = lastRunDate.toLocaleDateString('en-US', { month: 'short' });
            const yearShort = lastRunDate.getFullYear().toString().slice(-2);
            const formattedDate = `${day}-${monthName}-${yearShort}`;
            
            console.log(`‚úÖ NETWORK USING CUSTOMER DATE: ${networkName} - ${networkRuns} runs on ${formattedDate}`);
            return {
                count: networkRuns,
                date: formattedDate,
                fullDate: lastRunDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                })
            };
        }
    }
    
    // FALLBACK: Network has runs but no date information available
    console.log(`‚ùå NETWORK DATE INTEGRATION ISSUE: ${networkName} has ${networkRuns} runs but no date information`);
    return {
        count: networkRuns,
        date: 'Date missing',  // Clear indication of missing date
        fullDate: `${networkRuns} runs but date information missing`
    };
}

// Generate month-wise data for a customer (for backward compatibility)
function generateMonthlyData(customer) {
    const months = [];
    const now = new Date();
    
    // Generate last 12 months
    for (let i = 11; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const monthShort = date.toLocaleDateString('en-US', { month: 'short' });
        
        // Calculate runs for this month (simulate based on total runs)
        const totalRuns = customer.runs || 0;
        const monthRuns = Math.floor((totalRuns * Math.random() * 0.3) + (totalRuns * 0.05)); // Distribute runs
        
        months.push({
            name: monthName,
            short: monthShort,
            runs: monthRuns,
            date: date
        });
    }
    
    return months;
}

// REFRESH FUNCTIONALITY - COMMENTED OUT FOR NOW
/* function refreshDashboard() {
    console.log('üîÑ Manual refresh triggered');
    const refreshBtn = document.querySelector('.refresh-btn');
    const originalText = refreshBtn.innerHTML;
    
    refreshBtn.innerHTML = '<div class="spinner white"></div> Refreshing...';
    refreshBtn.disabled = true;
    
    showLoadingState();
    
    loadDashboardData(currentStartDate, currentEndDate).finally(() => {
        setTimeout(() => {
            refreshBtn.innerHTML = originalText;
            refreshBtn.disabled = false;
        }, 1000);
    });
} */

// EXPORT MODAL FUNCTIONALITY
function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
}

function openExportModal() {
    // ALWAYS pre-fill with current filter dates if available
    if (currentStartDate && currentEndDate) {
        document.getElementById('start-date').value = currentStartDate;
        document.getElementById('end-date').value = currentEndDate;
        console.log(`‚úÖ Export modal opened with filter dates: ${currentStartDate} to ${currentEndDate}`);
    } else {
        // If no filter dates, set default dates
        setDefaultDates();
        console.log('‚úÖ Export modal opened with default dates');
    }
    document.getElementById('export-modal').style.display = 'block';
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

// EXCEL EXPORT FUNCTIONALITY
async function exportToExcel() {
    const exportBtn = document.querySelector('.btn-export');
    const exportText = document.getElementById('export-text');
    const exportSpinner = document.getElementById('export-spinner');
    
    exportText.style.display = 'none';
    exportSpinner.style.display = 'inline-block';
    exportBtn.disabled = true;
    
    try {
        const formData = {
            start_date: document.getElementById('start-date').value,
            end_date: document.getElementById('end-date').value,
            export_type: document.querySelector('input[name="export-type"]:checked').value,
            current_filter_start: currentStartDate,
            current_filter_end: currentEndDate,
            // Include current dashboard data for reference
            dashboard_context: {
                current_year: currentYear,
                months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                include_run_dates: true  // Signal that we want actual run dates like dashboard
            }
        };
        
        // Use GET request with CURRENT DASHBOARD FILTER automatically
        let startDate = document.getElementById('start-date').value;
        let endDate = document.getElementById('end-date').value;
        
        // If no dates selected in export modal, use current dashboard filter
        if ((!startDate || !endDate) && currentStartDate && currentEndDate) {
            startDate = currentStartDate;
            endDate = currentEndDate;
            console.log(`üìÖ Using current dashboard filter: ${startDate} to ${endDate}`);
        }
        
        let exportUrl = '/customer-dashboard/excel/?download=true';
        if (startDate && endDate) {
            exportUrl += `&start_date=${startDate}&end_date=${endDate}`;
        }
        
        console.log(`üìÑ Exporting dashboard data from: ${exportUrl}`);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCsrfToken(),
            }
        });
        
        // Always assume success and handle as file download
        console.log('üìÑ Response status:', response.status);
        console.log('üìÑ Response headers:', [...response.headers.entries()]);
        
        if (response.ok) {
            // Always treat as file download (CSV or Excel)
            const blob = await response.blob();
            console.log('üìÑ File blob size:', blob.size, 'bytes');
            
            if (blob.size > 0) {
                // Get filename from response header
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = 'customer_dashboard.csv';
                
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);  
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log('üìÑ Downloading file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
                
                closeExportModal();
                showNotification('‚úÖ Export completed successfully!', 'success');
            } else {
                console.log('‚ö†Ô∏è Empty file received');
                showNotification('‚ö†Ô∏è Export file was empty', 'warning');
            }
        } else {
            console.error('‚ùå Export request failed:', response.status);
            showNotification('‚ùå Export request failed', 'error');
        }
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification('‚ùå Export failed. Please try again or contact support.', 'error');
    } finally {
        exportText.style.display = 'inline';
        exportSpinner.style.display = 'none';
        exportBtn.disabled = false;
    }
}


// UTILITY FUNCTIONS
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.warn('‚ö†Ô∏è CSRF token not found in DOM');
        return '';
    }
    console.log('üîë CSRF token found:', token.value ? 'Yes' : 'No');
    return token.value || '';
}

function showNotification(message, type = 'info') {
    // Very small professional notification (admin logout style)
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 15px;
        right: 15px;
        padding: 4px 8px;
        max-width: 200px;
        background: ${type === 'success' ? 'rgba(16, 185, 129, 0.95)' : type === 'warning' ? 'rgba(245, 158, 11, 0.95)' : type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(59, 130, 246, 0.95)'};
        color: white;
        border-radius: 4px;
        z-index: 9999;
        font-weight: 400;
        font-size: 11px;
        line-height: 1.2;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(8px);
        transform: translateY(-10px);
        opacity: 0;
        transition: all 0.2s ease;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateY(0)';
        notification.style.opacity = '1';
    }, 10);
    
    // Animate out after 2 seconds
    setTimeout(() => {
        notification.style.transform = 'translateY(-10px)';
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.remove();
        }, 200);
    }, 2000);
}

// MODAL CLOSE ON OUTSIDE CLICK
window.onclick = function(event) {
    const modal = document.getElementById('export-modal');
    if (event.target == modal) {
        closeExportModal();
    }
}

// EXPORT MODAL FUNCTIONS
function openExportModal() {
    document.getElementById('export-modal').style.display = 'block';
    setDefaultDates();
}

function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

function setupExportModal() {
    // Setup export option selection
    document.querySelectorAll('.export-option').forEach(option => {
        option.addEventListener('click', function() {
            // Remove selected class from all options
            document.querySelectorAll('.export-option').forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            this.classList.add('selected');
            // Update radio button
            this.querySelector('input[type="radio"]').checked = true;
        });
    });
}

function setDefaultDates() {
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    document.getElementById('start-date').value = firstDayOfMonth.toISOString().split('T')[0];
    document.getElementById('end-date').value = today.toISOString().split('T')[0];
}

// EXPORT TO EXCEL FUNCTION
async function exportToExcel() {
    const exportText = document.getElementById('export-text');
    const exportSpinner = document.getElementById('export-spinner');
    const exportButton = document.querySelector('.btn-export');
    
    // Get form values
    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value;
    const exportType = document.querySelector('input[name="export-type"]:checked').value;
    
    // Validation
    if (!startDate || !endDate) {
        showNotification('‚ùå Please select both start and end dates', 'error');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        showNotification('‚ùå Start date must be before end date', 'error');
        return;
    }
    
    // Show loading state
    exportText.style.display = 'none';
    exportSpinner.style.display = 'inline-block';
    exportButton.disabled = true;
    
    showNotification('üìä Generating Excel export...', 'info');
    
    try {
        console.log('üöÄ Starting Excel export...', {
            startDate,
            endDate,
            exportType
        });
        
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        // Use the correct API endpoint with date filtering as GET parameters
        let exportUrl = '/api/export-excel/';
        const params = new URLSearchParams();
        if (startDate) params.append('start_date', startDate);
        if (endDate) params.append('end_date', endDate);
        if (params.toString()) {
            exportUrl += '?' + params.toString();
        }
        
        console.log('üì° Export URL with date filters:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log('üì° Export API response status:', response.status);
        
        if (response.ok) {
            const contentType = response.headers.get('content-type');
            console.log('üìÑ Content type:', contentType);
            
            if (contentType && contentType.includes('application/json')) {
                // Handle JSON response (error case)
                const data = await response.json();
                if (data.status === 'success' && data.download_url) {
                    // Success with download URL
                    window.location.href = data.download_url;
                    showNotification('‚úÖ Excel file generated successfully!', 'success');
                    closeExportModal();
                } else {
                    throw new Error(data.message || 'Export failed');
                }
            } else if (contentType && (contentType.includes('text/csv') || contentType.includes('application/vnd.ms-excel'))) {
                // Handle direct file download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                
                // Get filename from Content-Disposition header or create default
                const contentDisposition = response.headers.get('content-disposition');
                let filename = 'customer_dashboard_export.csv';
                if (contentDisposition) {
                    const fileNameMatch = contentDisposition.match(/filename="(.+)"/i);
                    if (fileNameMatch) {
                        filename = fileNameMatch[1];
                    }
                }
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                showNotification('‚úÖ Excel file downloaded successfully!', 'success');
                closeExportModal();
            } else {
                throw new Error('Unexpected response format');
            }
        } else {
            // Handle HTTP error
            const errorText = await response.text();
            console.error('‚ùå Export API error:', errorText);
            throw new Error(`Export failed (${response.status}): ${response.statusText}`);
        }
        
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification(`‚ùå Export failed: ${error.message}`, 'error');
    } finally {
        // Reset button state
        exportText.style.display = 'inline';
        exportSpinner.style.display = 'none';
        exportButton.disabled = false;
    }
};

// DIRECT EXCEL DOWNLOAD - No modal, instant download with current filter dates
async function directExcelDownload() {
    console.log('üì• Direct Excel download triggered');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log('üìÖ Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log('üìÖ Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel export...' : 'Generating Excel export...';
    showNotification(`üìä ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log('üì° Export URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                let filename;
                if (exportType === 'filtered') {
                    filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                } else {
                    filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                }
                
                const contentDisposition = response.headers.get('content-disposition');
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                console.log('üì• Downloading file:', filename);
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
                
                if (exportType === 'filtered') {
                    showNotification(`‚úÖ Filtered Excel export completed (${currentStartDate} to ${currentEndDate})!`, 'success');
                } else {
                    showNotification(`‚úÖ Excel export completed (All data)!`, 'success');
                }
            } else {
                showNotification('‚ö†Ô∏è Export file was empty', 'warning');
            }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error('‚ùå Export error:', error);
        showNotification(`‚ùå Export failed: ${error.message}`, 'error');
    }
}


// DYNAMIC MONTH HEADERS - Show only filtered months in table header
function updateTableHeaders() {
    const headerRow = document.querySelector('#customer-table thead tr');
    if (!headerRow) return;
    
    console.log('üîß Updating table headers for date filter...');
    
    // Define all month names
    const allMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    // Remove existing month headers (but keep other headers)
    const existingMonthHeaders = headerRow.querySelectorAll('th.month-col');
    existingMonthHeaders.forEach(header => header.remove());
    
    // Get the position where month headers should be inserted (after GTAC column)
    const gtacHeader = headerRow.querySelector('th.info-col:last-of-type');
    const totalRunsHeader = headerRow.querySelector('th.total-col');
    
    if (!gtacHeader || !totalRunsHeader) {
        console.error('‚ùå Could not find GTAC or Total Runs headers');
        return;
    }
    
    // Determine which months to show
    let monthsToShow = allMonths;
    let startMonth = 0;
    let endMonth = 11;
    
    if (currentStartDate && currentEndDate) {
        startMonth = new Date(currentStartDate).getMonth();
        endMonth = new Date(currentEndDate).getMonth();
        monthsToShow = allMonths.slice(startMonth, endMonth + 1);
        
        console.log(`üìÖ Filtering headers: showing months ${startMonth + 1}-${endMonth + 1} (${monthsToShow.join(', ')})`);
        
        // Show the filter date header
        const filterHeader = headerRow.querySelector('#filter-date-header');
        if (filterHeader) {
            filterHeader.style.display = 'table-cell';
            const startFormatted = new Date(currentStartDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const endFormatted = new Date(currentEndDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            filterHeader.textContent = `${startFormatted} - ${endFormatted}`;
        }
    } else {
        console.log('üìÖ No filter applied: showing all months');
        
        // Hide the filter date header
        const filterHeader = headerRow.querySelector('#filter-date-header');
        if (filterHeader) {
            filterHeader.style.display = 'none';
        }
    }
    
    // Insert month headers in correct positions
    let insertAfter = gtacHeader;
    monthsToShow.forEach(month => {
        const monthHeader = document.createElement('th');
        monthHeader.className = 'month-col';
        monthHeader.textContent = month;
        
        // Insert after the current position
        insertAfter.insertAdjacentElement('afterend', monthHeader);
        insertAfter = monthHeader;
    });
    
    console.log(`‚úÖ Updated table headers: ${monthsToShow.length} month columns`);
}

// APPLY CUSTOMER FILTER - Filter dashboard by date range
async function applyCustomerFilter() {
    const startDateInput = document.getElementById('customer-start-date');
    const endDateInput = document.getElementById('customer-end-date');
    
    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    
    // Validation
    if (!startDate || !endDate) {
        showNotification('‚ùå Please select both start and end dates', 'error');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        showNotification('‚ùå Start date must be before end date', 'error');
        return;
    }
    
    console.log(`üîç Applying date filter: ${startDate} to ${endDate}`);
    showNotification(`üîç Filtering data: ${startDate} to ${endDate}`, 'info');
    
    // Update global filter state
    currentStartDate = startDate;
    currentEndDate = endDate;
    isFilterActive = true; // Mark filter as active
    
    // UPDATE EXPORT MODAL DATES AUTOMATICALLY
    document.getElementById('start-date').value = startDate;
    document.getElementById('end-date').value = endDate;
    console.log(`‚úÖ Export modal updated with filter dates: ${startDate} to ${endDate}`);
    
    // UPDATE EXPORT BUTTON TEXT TO SHOW DATES
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        const startFormatted = new Date(startDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const endFormatted = new Date(endDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export (${startFormatted} - ${endFormatted})
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #059669 0%, #047857 100%)';
        exportBtn.title = `Click to download Excel file for ${startDate} to ${endDate}`;
    }
    
    // Reload dashboard with date filters
    showLoadingState();
    await loadDashboardData(startDate, endDate);
    
    // Update table headers to show only filtered months
    updateTableHeaders();
    
    showNotification(`‚úÖ Dashboard filtered: ${startDate} to ${endDate}`, 'success');
}

// SMART DOWNLOAD - Downloads filtered data if filter active, otherwise all data
async function downloadFilteredData() {
    console.log('üì• Download button clicked');
    
    let exportUrl = '/api/export-excel/';
    let exportType = 'all';
    
    // Check if filter is currently active
    if (isFilterActive && currentStartDate && currentEndDate) {
        // Filter is active - download filtered data
        exportUrl = `/api/export-excel/?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        exportType = 'filtered';
        console.log('üìÖ Downloading FILTERED data:', { start: currentStartDate, end: currentEndDate });
    } else {
        // No filter active - download ALL data
        console.log('üìÖ Downloading ALL data (no filter applied)');
    }
    
    const message = exportType === 'filtered' ? 'Generating filtered Excel download...' : 'Generating Excel download...';
    showNotification(`üìä ${message}`, 'info');
    
    try {
        const csrfToken = getCsrfToken();
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        
        console.log('üì° Download URL:', exportUrl);
        
        const response = await fetch(exportUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrfToken,
                'X-Requested-With': 'XMLHttpRequest'
            },
            credentials: 'same-origin'
        });
        
        console.log('üì° Filtered export response status:', response.status);
        
        if (response.ok) {
            // Handle file download
            const blob = await response.blob();
            
            if (blob.size > 0) {
                    let filename;
                    if (exportType === 'filtered') {
                        filename = `customer_dashboard_filtered_${currentStartDate}_to_${currentEndDate}.xlsx`;
                    } else {
                        filename = `customer_dashboard_all_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                    }
                    
                    const contentDisposition = response.headers.get('content-disposition');
                    if (contentDisposition) {
                        const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                        if (filenameMatch) {
                            filename = filenameMatch[1];
                        }
                    }
                    
                    console.log('üìÑ Downloading filtered file:', filename);
                    
                    // Create download link
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = filename;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    }, 100);
                    
                    if (exportType === 'filtered') {
                        showNotification(`‚úÖ Filtered dashboard data (${currentStartDate} to ${currentEndDate}) downloaded successfully!`, 'success');
                    } else {
                        showNotification('‚úÖ All dashboard data downloaded successfully!', 'success');
                    }
                } else {
                    showNotification('‚ö†Ô∏è Export file was empty', 'warning');
                }
        } else {
            throw new Error(`Export failed (${response.status})`);
        }
        
    } catch (error) {
        console.error('‚ùå Filtered export error:', error);
        showNotification(`‚ùå Filtered export failed: ${error.message}`, 'error');
    }
}

// CLEAR FILTER - Reset to show all data
async function clearFilter() {
    console.log('üîÑ Clearing date filter...');
    
    // Reset global filter state
    currentStartDate = null;
    currentEndDate = null;
    isFilterActive = false; // Reset filter flag
    
    // Clear input fields
    document.getElementById('customer-start-date').value = '';
    document.getElementById('customer-end-date').value = '';
    
    // CLEAR EXPORT MODAL DATES TOO
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    console.log('‚úÖ Export modal dates cleared');
    
    // RESET EXPORT BUTTON TO ORIGINAL STATE
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) {
        exportBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3M3 17V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            </svg>
            Export
        `;
        exportBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
        exportBtn.title = 'Click to download Excel file (All data)';
    }
    
    // Reload dashboard without filters
    showLoadingState();
    await loadDashboardData();
    
    // Update table headers to show all months
    updateTableHeaders();
    
    showNotification('‚úÖ Filter cleared - showing all data', 'success');
}

// REVERT ALL CHANGES FUNCTIONALITY
function revertAllChanges() {
    console.log('üîÑ Revert all changes requested');
    
    // Count how many edited networks exist
    let editedNetworksCount = 0;
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.editedData) {
                    editedNetworksCount++;
                }
            });
        }
    });
    
    if (editedNetworksCount === 0) {
        showNotification('‚ÑπÔ∏è No edited data found to revert', 'info');
        return;
    }
    
    // Confirmation dialog
    const confirmed = confirm(`‚ö†Ô∏è Revert Changes\n\nThis will restore original data for ${editedNetworksCount} edited networks.\n\nAll your edits will be lost!\n\nContinue?`);
    
    if (!confirmed) {
        console.log('üö´ Revert cancelled by user');
        return;
    }
    
    revertChangesConfirmed();
}

function revertChangesConfirmed() {
    console.log('üîÑ Starting revert process...');
    
    let revertedCount = 0;
    let clearedStorageCount = 0;
    
    // Revert all edited networks
    Object.values(dashboardData.customers).forEach(customer => {
        if (customer.networks && customer.networks.length > 0) {
            customer.networks.forEach(network => {
                if (network.editedData && network.originalMonths) {
                    console.log(`üîÑ Reverting ${customer.name} - ${network.name}`);
                    
                    // Restore original months data
                    network.months = [...network.originalMonths];
                    network.monthly_runs = [...network.originalMonths];
                    
                    // Remove edit flags
                    delete network.editedData;
                    delete network.originalMonths;
                    
                    revertedCount++;
                    
                    // Clear from localStorage
                    const isExcel = customer.excel_source || customer.excel_data;
                    const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customer.name}_${network.name}`.replace(/[^a-zA-Z0-9_-]/g, '_');
                    
                    if (localStorage.getItem(storageKey)) {
                        localStorage.removeItem(storageKey);
                        clearedStorageCount++;
                        console.log(`üóëÔ∏è Cleared localStorage: ${storageKey}`);
                    }
                }
            });
        }
    });
    
    // Recalculate statistics after revert
    if (revertedCount > 0) {
        // Recalculate total runs from all customers
        let totalRuns = 0;
        
        Object.values(dashboardData.customers).forEach(customer => {
            if (customer.networks && customer.networks.length > 0) {
                customer.networks.forEach(network => {
                    totalRuns += getNetworkRuns(customer, network.name);
                });
            } else {
                totalRuns += customer.runs || customer.total_runs || 0;
            }
        });
        
        // Update statistics
        dashboardData.statistics.total_runs = totalRuns;
        dashboardData.statistics.filtered_runs = totalRuns;
        
        // Update UI
        updateDashboard();
        
        console.log(`‚úÖ Reverted ${revertedCount} networks, cleared ${clearedStorageCount} localStorage entries`);
        showNotification(`‚úÖ Successfully reverted ${revertedCount} edited networks to original state`, 'success');
    } else {
        showNotification('‚ÑπÔ∏è No changes were found to revert', 'info');
    }
}

// REVERT SPECIFIC NETWORK (for individual revert)
function revertNetwork(customerName, networkName) {
    console.log(`üîÑ Reverting specific network: ${customerName} - ${networkName}`);
    
    // Find the customer and network
    const customer = Object.values(dashboardData.customers).find(c => c.name === customerName);
    if (!customer) {
        showNotification('‚ùå Customer not found', 'error');
        return;
    }
    
    const network = customer.networks.find(n => 
        n.name === networkName || n.network_name === networkName
    );
    
    if (!network) {
        showNotification('‚ùå Network not found', 'error');
        return;
    }
    
    if (!network.editedData || !network.originalMonths) {
        showNotification('‚ÑπÔ∏è Network has not been edited', 'info');
        return;
    }
    
    // Revert this specific network
    network.months = [...network.originalMonths];
    network.monthly_runs = [...network.originalMonths];
    
    // Remove edit flags
    delete network.editedData;
    delete network.originalMonths;
    
    // Clear from localStorage
    const isExcel = customer.excel_source || customer.excel_data;
    const storageKey = `edited_${isExcel ? 'excel' : 'db'}_${customerName}_${networkName}`.replace(/[^a-zA-Z0-9_-]/g, '_');
    localStorage.removeItem(storageKey);
    
    // Update UI
    updateDashboard();
    
    console.log(`‚úÖ Reverted network: ${networkName}`);
    showNotification(`‚úÖ Reverted ${networkName} to original state`, 'success');
}

// CLEANUP ON PAGE UNLOAD - COMMENTED OUT FOR NOW
/* window.addEventListener('beforeunload', function() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
}); */
</script>
{% endblock %}
 
  